import{Se as L$,Te as n0,Ue as TJ,Ve as E0,We as XJ,Xe as KJ,_e as S$,af as k$,ef as s0,ff as H$,gf as t0,if as u0,kf as _0,lf as F$,mf as HJ}from"./chunk-kcet18sy.js";import{cg as E8,eg as w8,fg as oJ}from"./chunk-g7j062ka.js";var GJ=w8((CQ,C$)=>{var R8=Object.prototype.hasOwnProperty,Q0="~";function y0(){}if(Object.create){if(y0.prototype=Object.create(null),!new y0().__proto__)Q0=!1}function f8(J,Q,$){this.fn=J,this.context=Q,this.once=$||!1}function qJ(J,Q,$,I,q){if(typeof $!=="function")throw new TypeError("The listener must be a function");var G=new f8($,I||J,q),M=Q0?Q0+Q:Q;if(!J._events[M])J._events[M]=G,J._eventsCount++;else if(!J._events[M].fn)J._events[M].push(G);else J._events[M]=[J._events[M],G];return J}function o0(J,Q){if(--J._eventsCount===0)J._events=new y0;else delete J._events[Q]}function e(){this._events=new y0,this._eventsCount=0}e.prototype.eventNames=function J(){var Q=[],$,I;if(this._eventsCount===0)return Q;for(I in $=this._events)if(R8.call($,I))Q.push(Q0?I.slice(1):I);if(Object.getOwnPropertySymbols)return Q.concat(Object.getOwnPropertySymbols($));return Q};e.prototype.listeners=function J(Q){var $=Q0?Q0+Q:Q,I=this._events[$];if(!I)return[];if(I.fn)return[I.fn];for(var q=0,G=I.length,M=new Array(G);q<G;q++)M[q]=I[q].fn;return M};e.prototype.listenerCount=function J(Q){var $=Q0?Q0+Q:Q,I=this._events[$];if(!I)return 0;if(I.fn)return 1;return I.length};e.prototype.emit=function J(Q,$,I,q,G,M){var K=Q0?Q0+Q:Q;if(!this._events[K])return!1;var Y=this._events[K],j=arguments.length,X,U;if(Y.fn){if(Y.once)this.removeListener(Q,Y.fn,void 0,!0);switch(j){case 1:return Y.fn.call(Y.context),!0;case 2:return Y.fn.call(Y.context,$),!0;case 3:return Y.fn.call(Y.context,$,I),!0;case 4:return Y.fn.call(Y.context,$,I,q),!0;case 5:return Y.fn.call(Y.context,$,I,q,G),!0;case 6:return Y.fn.call(Y.context,$,I,q,G,M),!0}for(U=1,X=new Array(j-1);U<j;U++)X[U-1]=arguments[U];Y.fn.apply(Y.context,X)}else{var W=Y.length,H;for(U=0;U<W;U++){if(Y[U].once)this.removeListener(Q,Y[U].fn,void 0,!0);switch(j){case 1:Y[U].fn.call(Y[U].context);break;case 2:Y[U].fn.call(Y[U].context,$);break;case 3:Y[U].fn.call(Y[U].context,$,I);break;case 4:Y[U].fn.call(Y[U].context,$,I,q);break;default:if(!X)for(H=1,X=new Array(j-1);H<j;H++)X[H-1]=arguments[H];Y[U].fn.apply(Y[U].context,X)}}}return!0};e.prototype.on=function J(Q,$,I){return qJ(this,Q,$,I,!1)};e.prototype.once=function J(Q,$,I){return qJ(this,Q,$,I,!0)};e.prototype.removeListener=function J(Q,$,I,q){var G=Q0?Q0+Q:Q;if(!this._events[G])return this;if(!$)return o0(this,G),this;var M=this._events[G];if(M.fn){if(M.fn===$&&(!q||M.once)&&(!I||M.context===I))o0(this,G)}else{for(var K=0,Y=[],j=M.length;K<j;K++)if(M[K].fn!==$||q&&!M[K].once||I&&M[K].context!==I)Y.push(M[K]);if(Y.length)this._events[G]=Y.length===1?Y[0]:Y;else o0(this,G)}return this};e.prototype.removeAllListeners=function J(Q){var $;if(Q){if($=Q0?Q0+Q:Q,this._events[$])o0(this,$)}else this._events=new y0,this._eventsCount=0;return this};e.prototype.off=e.prototype.removeListener;e.prototype.addListener=e.prototype.on;e.prefixed=Q0;e.EventEmitter=e;if(typeof C$!=="undefined")C$.exports=e});var F0=BigInt(4294967295),$$=BigInt(32);function c$(J,Q=!1){if(Q)return{h:Number(J&F0),l:Number(J>>$$&F0)};return{h:Number(J>>$$&F0)|0,l:Number(J&F0)|0}}function J$(J,Q=!1){let $=new Uint32Array(J.length),I=new Uint32Array(J.length);for(let q=0;q<J.length;q++){let{h:G,l:M}=c$(J[q],Q);[$[q],I[q]]=[G,M]}return[$,I]}var EJ=(J,Q)=>BigInt(J>>>0)<<$$|BigInt(Q>>>0),gJ=(J,Q,$)=>J>>>$,bJ=(J,Q,$)=>J<<32-$|Q>>>$,PJ=(J,Q,$)=>J>>>$|Q<<32-$,xJ=(J,Q,$)=>J<<32-$|Q>>>$,_J=(J,Q,$)=>J<<64-$|Q>>>$-32,yJ=(J,Q,$)=>J>>>$-32|Q<<64-$,vJ=(J,Q)=>Q,cJ=(J,Q)=>J,Q$=(J,Q,$)=>J<<$|Q>>>32-$,I$=(J,Q,$)=>Q<<$|J>>>32-$,q$=(J,Q,$)=>Q<<$-32|J>>>64-$,G$=(J,Q,$)=>J<<$-32|Q>>>64-$;function FJ(J,Q,$,I){let q=(Q>>>0)+(I>>>0);return{h:J+$+(q/4294967296|0)|0,l:q|0}}var uJ=(J,Q,$)=>(J>>>0)+(Q>>>0)+($>>>0),hJ=(J,Q,$,I)=>Q+$+I+(J/4294967296|0)|0,mJ=(J,Q,$,I)=>(J>>>0)+(Q>>>0)+($>>>0)+(I>>>0),dJ=(J,Q,$,I,q)=>Q+$+I+q+(J/4294967296|0)|0,lJ=(J,Q,$,I,q)=>(J>>>0)+(Q>>>0)+($>>>0)+(I>>>0)+(q>>>0),rJ=(J,Q,$,I,q,G)=>Q+$+I+q+G+(J/4294967296|0)|0;var aJ={fromBig:c$,split:J$,toBig:EJ,shrSH:gJ,shrSL:bJ,rotrSH:PJ,rotrSL:xJ,rotrBH:_J,rotrBL:yJ,rotr32H:vJ,rotr32L:cJ,rotlSH:Q$,rotlSL:I$,rotlBH:q$,rotlBL:G$,add:FJ,add3L:uJ,add3H:hJ,add4L:mJ,add4H:dJ,add5H:rJ,add5L:lJ},_=aJ;var[pJ,iJ]=(()=>_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((J)=>BigInt(J))))(),z0=new Uint32Array(80),A0=new Uint32Array(80);class u$ extends F${constructor(){super(128,64,16,!1);this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:J,Al:Q,Bh:$,Bl:I,Ch:q,Cl:G,Dh:M,Dl:K,Eh:Y,El:j,Fh:X,Fl:U,Gh:W,Gl:H,Hh:g,Hl:N}=this;return[J,Q,$,I,q,G,M,K,Y,j,X,U,W,H,g,N]}set(J,Q,$,I,q,G,M,K,Y,j,X,U,W,H,g,N){this.Ah=J|0,this.Al=Q|0,this.Bh=$|0,this.Bl=I|0,this.Ch=q|0,this.Cl=G|0,this.Dh=M|0,this.Dl=K|0,this.Eh=Y|0,this.El=j|0,this.Fh=X|0,this.Fl=U|0,this.Gh=W|0,this.Gl=H|0,this.Hh=g|0,this.Hl=N|0}process(J,Q){for(let V=0;V<16;V++,Q+=4)z0[V]=J.getUint32(Q),A0[V]=J.getUint32(Q+=4);for(let V=16;V<80;V++){let O=z0[V-15]|0,k=A0[V-15]|0,E=_.rotrSH(O,k,1)^_.rotrSH(O,k,8)^_.shrSH(O,k,7),L=_.rotrSL(O,k,1)^_.rotrSL(O,k,8)^_.shrSL(O,k,7),w=z0[V-2]|0,S=A0[V-2]|0,F=_.rotrSH(w,S,19)^_.rotrBH(w,S,61)^_.shrSH(w,S,6),c=_.rotrSL(w,S,19)^_.rotrBL(w,S,61)^_.shrSL(w,S,6),f=_.add4L(L,c,A0[V-7],A0[V-16]),a=_.add4H(f,E,F,z0[V-7],z0[V-16]);z0[V]=a|0,A0[V]=f|0}let{Ah:$,Al:I,Bh:q,Bl:G,Ch:M,Cl:K,Dh:Y,Dl:j,Eh:X,El:U,Fh:W,Fl:H,Gh:g,Gl:N,Hh:D,Hl:B}=this;for(let V=0;V<80;V++){let O=_.rotrSH(X,U,14)^_.rotrSH(X,U,18)^_.rotrBH(X,U,41),k=_.rotrSL(X,U,14)^_.rotrSL(X,U,18)^_.rotrBL(X,U,41),E=X&W^~X&g,L=U&H^~U&N,w=_.add5L(B,k,L,iJ[V],A0[V]),S=_.add5H(w,D,O,E,pJ[V],z0[V]),F=w|0,c=_.rotrSH($,I,28)^_.rotrBH($,I,34)^_.rotrBH($,I,39),f=_.rotrSL($,I,28)^_.rotrBL($,I,34)^_.rotrBL($,I,39),a=$&q^$&M^q&M,p=I&G^I&K^G&K;D=g|0,B=N|0,g=W|0,N=H|0,W=X|0,H=U|0,{h:X,l:U}=_.add(Y|0,j|0,S|0,F|0),Y=M|0,j=K|0,M=q|0,K=G|0,q=$|0,G=I|0;let A=_.add3L(F,f,p);$=_.add3H(A,S,c,a),I=A|0}({h:$,l:I}=_.add(this.Ah|0,this.Al|0,$|0,I|0)),{h:q,l:G}=_.add(this.Bh|0,this.Bl|0,q|0,G|0),{h:M,l:K}=_.add(this.Ch|0,this.Cl|0,M|0,K|0),{h:Y,l:j}=_.add(this.Dh|0,this.Dl|0,Y|0,j|0),{h:X,l:U}=_.add(this.Eh|0,this.El|0,X|0,U|0),{h:W,l:H}=_.add(this.Fh|0,this.Fl|0,W|0,H|0),{h:g,l:N}=_.add(this.Gh|0,this.Gl|0,g|0,N|0),{h:D,l:B}=_.add(this.Hh|0,this.Hl|0,D|0,B|0),this.set($,I,q,G,M,K,Y,j,X,U,W,H,g,N,D,B)}roundClean(){z0.fill(0),A0.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var h$=u0(()=>new u$);var d0={};oJ(d0,{validateObject:()=>Y0,utf8ToBytes:()=>$8,numberToVarBytesBE:()=>tJ,numberToHexUnpadded:()=>S0,numberToBytesLE:()=>T0,numberToBytesBE:()=>C0,notImplemented:()=>q8,memoized:()=>B0,isBytes:()=>H0,inRange:()=>g0,hexToNumber:()=>X$,hexToBytes:()=>k0,equalBytes:()=>eJ,ensureBytes:()=>m,createHmacDrbg:()=>Z$,concatBytes:()=>O0,bytesToNumberLE:()=>X0,bytesToNumberBE:()=>V0,bytesToHex:()=>j0,bitSet:()=>Q8,bitMask:()=>b0,bitLen:()=>K$,bitGet:()=>J8,abytes:()=>R0,abool:()=>M0,aInRange:()=>t});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var h0=BigInt(0),m0=BigInt(1),nJ=BigInt(2);function H0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function R0(J){if(!H0(J))throw new Error("Uint8Array expected")}function M0(J,Q){if(typeof Q!=="boolean")throw new Error(J+" boolean expected, got "+Q)}var sJ=Array.from({length:256},(J,Q)=>Q.toString(16).padStart(2,"0"));function j0(J){R0(J);let Q="";for(let $=0;$<J.length;$++)Q+=sJ[J[$]];return Q}function S0(J){let Q=J.toString(16);return Q.length&1?"0"+Q:Q}function X$(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?h0:BigInt("0x"+J)}var N0={_0:48,_9:57,A:65,F:70,a:97,f:102};function m$(J){if(J>=N0._0&&J<=N0._9)return J-N0._0;if(J>=N0.A&&J<=N0.F)return J-(N0.A-10);if(J>=N0.a&&J<=N0.f)return J-(N0.a-10);return}function k0(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);let Q=J.length,$=Q/2;if(Q%2)throw new Error("hex string expected, got unpadded hex of length "+Q);let I=new Uint8Array($);for(let q=0,G=0;q<$;q++,G+=2){let M=m$(J.charCodeAt(G)),K=m$(J.charCodeAt(G+1));if(M===void 0||K===void 0){let Y=J[G]+J[G+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+G)}I[q]=M*16+K}return I}function V0(J){return X$(j0(J))}function X0(J){return R0(J),X$(j0(Uint8Array.from(J).reverse()))}function C0(J,Q){return k0(J.toString(16).padStart(Q*2,"0"))}function T0(J,Q){return C0(J,Q).reverse()}function tJ(J){return k0(S0(J))}function m(J,Q,$){let I;if(typeof Q==="string")try{I=k0(Q)}catch(G){throw new Error(J+" must be hex string or Uint8Array, cause: "+G)}else if(H0(Q))I=Uint8Array.from(Q);else throw new Error(J+" must be hex string or Uint8Array");let q=I.length;if(typeof $==="number"&&q!==$)throw new Error(J+" of length "+$+" expected, got "+q);return I}function O0(...J){let Q=0;for(let I=0;I<J.length;I++){let q=J[I];R0(q),Q+=q.length}let $=new Uint8Array(Q);for(let I=0,q=0;I<J.length;I++){let G=J[I];$.set(G,q),q+=G.length}return $}function eJ(J,Q){if(J.length!==Q.length)return!1;let $=0;for(let I=0;I<J.length;I++)$|=J[I]^Q[I];return $===0}function $8(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(J))}var Y$=(J)=>typeof J==="bigint"&&h0<=J;function g0(J,Q,$){return Y$(J)&&Y$(Q)&&Y$($)&&Q<=J&&J<$}function t(J,Q,$,I){if(!g0(Q,$,I))throw new Error("expected valid "+J+": "+$+" <= n < "+I+", got "+Q)}function K$(J){let Q;for(Q=0;J>h0;J>>=m0,Q+=1);return Q}function J8(J,Q){return J>>BigInt(Q)&m0}function Q8(J,Q,$){return J|($?m0:h0)<<BigInt(Q)}var b0=(J)=>(nJ<<BigInt(J-1))-m0,M$=(J)=>new Uint8Array(J),d$=(J)=>Uint8Array.from(J);function Z$(J,Q,$){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof $!=="function")throw new Error("hmacFn must be a function");let I=M$(J),q=M$(J),G=0,M=()=>{I.fill(1),q.fill(0),G=0},K=(...U)=>$(q,I,...U),Y=(U=M$())=>{if(q=K(d$([0]),U),I=K(),U.length===0)return;q=K(d$([1]),U),I=K()},j=()=>{if(G++>=1000)throw new Error("drbg: tried 1000 values");let U=0,W=[];while(U<Q){I=K();let H=I.slice();W.push(H),U+=I.length}return O0(...W)};return(U,W)=>{M(),Y(U);let H=void 0;while(!(H=W(j())))Y();return M(),H}}var I8={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||H0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,Q)=>Q.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)};function Y0(J,Q,$={}){let I=(q,G,M)=>{let K=I8[G];if(typeof K!=="function")throw new Error("invalid validator function");let Y=J[q];if(M&&Y===void 0)return;if(!K(Y,J))throw new Error("param "+String(q)+" is invalid. Expected "+G+", got "+Y)};for(let[q,G]of Object.entries(Q))I(q,G,!1);for(let[q,G]of Object.entries($))I(q,G,!0);return J}var q8=()=>{throw new Error("not implemented")};function B0(J){let Q=new WeakMap;return($,...I)=>{let q=Q.get($);if(q!==void 0)return q;let G=J($,...I);return Q.set($,G),G}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var o=BigInt(0),l=BigInt(1),w0=BigInt(2),G8=BigInt(3),N$=BigInt(4),l$=BigInt(5),r$=BigInt(8),Y8=BigInt(9),M8=BigInt(16);function h(J,Q){let $=J%Q;return $>=o?$:Q+$}function j$(J,Q,$){if(Q<o)throw new Error("invalid exponent, negatives unsupported");if($<=o)throw new Error("invalid modulus");if($===l)return o;let I=l;while(Q>o){if(Q&l)I=I*J%$;J=J*J%$,Q>>=l}return I}function d(J,Q,$){let I=J;while(Q-- >o)I*=I,I%=$;return I}function l0(J,Q){if(J===o)throw new Error("invert: expected non-zero number");if(Q<=o)throw new Error("invert: expected positive modulus, got "+Q);let $=h(J,Q),I=Q,q=o,G=l,M=l,K=o;while($!==o){let j=I/$,X=I%$,U=q-M*j,W=G-K*j;I=$,$=X,q=M,G=K,M=U,K=W}if(I!==l)throw new Error("invert: does not exist");return h(q,Q)}function X8(J){let Q=(J-l)/w0,$,I,q;for($=J-l,I=0;$%w0===o;$/=w0,I++);for(q=w0;q<J&&j$(q,Q,J)!==J-l;q++)if(q>1000)throw new Error("Cannot find square root: likely non-prime P");if(I===1){let M=(J+l)/N$;return function K(Y,j){let X=Y.pow(j,M);if(!Y.eql(Y.sqr(X),j))throw new Error("Cannot find square root");return X}}let G=($+l)/w0;return function M(K,Y){if(K.pow(Y,Q)===K.neg(K.ONE))throw new Error("Cannot find square root");let j=I,X=K.pow(K.mul(K.ONE,q),$),U=K.pow(Y,G),W=K.pow(Y,$);while(!K.eql(W,K.ONE)){if(K.eql(W,K.ZERO))return K.ZERO;let H=1;for(let N=K.sqr(W);H<j;H++){if(K.eql(N,K.ONE))break;N=K.sqr(N)}let g=K.pow(X,l<<BigInt(j-H-1));X=K.sqr(g),U=K.mul(U,g),W=K.mul(W,X),j=H}return U}}function K8(J){if(J%N$===G8){let Q=(J+l)/N$;return function $(I,q){let G=I.pow(q,Q);if(!I.eql(I.sqr(G),q))throw new Error("Cannot find square root");return G}}if(J%r$===l$){let Q=(J-l$)/r$;return function $(I,q){let G=I.mul(q,w0),M=I.pow(G,Q),K=I.mul(q,M),Y=I.mul(I.mul(K,w0),M),j=I.mul(K,I.sub(Y,I.ONE));if(!I.eql(I.sqr(j),q))throw new Error("Cannot find square root");return j}}if(J%M8===Y8);return X8(J)}var a$=(J,Q)=>(h(J,Q)&l)===l,Z8=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function V$(J){let Q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},$=Z8.reduce((I,q)=>{return I[q]="function",I},Q);return Y0(J,$)}function N8(J,Q,$){if($<o)throw new Error("invalid exponent, negatives unsupported");if($===o)return J.ONE;if($===l)return Q;let I=J.ONE,q=Q;while($>o){if($&l)I=J.mul(I,q);q=J.sqr(q),$>>=l}return I}function j8(J,Q){let $=new Array(Q.length),I=Q.reduce((G,M,K)=>{if(J.is0(M))return G;return $[K]=G,J.mul(G,M)},J.ONE),q=J.inv(I);return Q.reduceRight((G,M,K)=>{if(J.is0(M))return G;return $[K]=J.mul(G,$[K]),J.mul(G,M)},q),$}function T$(J,Q){let $=Q!==void 0?Q:J.toString(2).length,I=Math.ceil($/8);return{nBitLength:$,nByteLength:I}}function L0(J,Q,$=!1,I={}){if(J<=o)throw new Error("invalid field: expected ORDER > 0, got "+J);let{nBitLength:q,nByteLength:G}=T$(J,Q);if(G>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let M,K=Object.freeze({ORDER:J,BITS:q,BYTES:G,MASK:b0(q),ZERO:o,ONE:l,create:(Y)=>h(Y,J),isValid:(Y)=>{if(typeof Y!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof Y);return o<=Y&&Y<J},is0:(Y)=>Y===o,isOdd:(Y)=>(Y&l)===l,neg:(Y)=>h(-Y,J),eql:(Y,j)=>Y===j,sqr:(Y)=>h(Y*Y,J),add:(Y,j)=>h(Y+j,J),sub:(Y,j)=>h(Y-j,J),mul:(Y,j)=>h(Y*j,J),pow:(Y,j)=>N8(K,Y,j),div:(Y,j)=>h(Y*l0(j,J),J),sqrN:(Y)=>Y*Y,addN:(Y,j)=>Y+j,subN:(Y,j)=>Y-j,mulN:(Y,j)=>Y*j,inv:(Y)=>l0(Y,J),sqrt:I.sqrt||((Y)=>{if(!M)M=K8(J);return M(K,Y)}),invertBatch:(Y)=>j8(K,Y),cmov:(Y,j,X)=>X?j:Y,toBytes:(Y)=>$?T0(Y,G):C0(Y,G),fromBytes:(Y)=>{if(Y.length!==G)throw new Error("Field.fromBytes: expected "+G+" bytes, got "+Y.length);return $?X0(Y):V0(Y)}});return Object.freeze(K)}function p$(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");let Q=J.toString(2).length;return Math.ceil(Q/8)}function O$(J){let Q=p$(J);return Q+Math.ceil(Q/2)}function i$(J,Q,$=!1){let I=J.length,q=p$(Q),G=O$(Q);if(I<16||I<G||I>1024)throw new Error("expected "+G+"-1024 bytes of input, got "+I);let M=$?V0(J):X0(J),K=h(M,Q-l)+l;return $?T0(K,q):C0(K,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var o$=BigInt(0),r0=BigInt(1);function U$(J,Q){let $=Q.negate();return J?$:Q}function n$(J,Q){if(!Number.isSafeInteger(J)||J<=0||J>Q)throw new Error("invalid window size, expected [1.."+Q+"], got W="+J)}function W$(J,Q){n$(J,Q);let $=Math.ceil(Q/J)+1,I=2**(J-1);return{windows:$,windowSize:I}}function T8(J,Q){if(!Array.isArray(J))throw new Error("array expected");J.forEach(($,I)=>{if(!($ instanceof Q))throw new Error("invalid point at index "+I)})}function O8(J,Q){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach(($,I)=>{if(!Q.isValid($))throw new Error("invalid scalar at index "+I)})}var D$=new WeakMap,s$=new WeakMap;function z$(J){return s$.get(J)||1}function a0(J,Q){return{constTimeNegate:U$,hasPrecomputes($){return z$($)!==1},unsafeLadder($,I,q=J.ZERO){let G=$;while(I>o$){if(I&r0)q=q.add(G);G=G.double(),I>>=r0}return q},precomputeWindow($,I){let{windows:q,windowSize:G}=W$(I,Q),M=[],K=$,Y=K;for(let j=0;j<q;j++){Y=K,M.push(Y);for(let X=1;X<G;X++)Y=Y.add(K),M.push(Y);K=Y.double()}return M},wNAF($,I,q){let{windows:G,windowSize:M}=W$($,Q),K=J.ZERO,Y=J.BASE,j=BigInt(2**$-1),X=2**$,U=BigInt($);for(let W=0;W<G;W++){let H=W*M,g=Number(q&j);if(q>>=U,g>M)g-=X,q+=r0;let N=H,D=H+Math.abs(g)-1,B=W%2!==0,V=g<0;if(g===0)Y=Y.add(U$(B,I[N]));else K=K.add(U$(V,I[D]))}return{p:K,f:Y}},wNAFUnsafe($,I,q,G=J.ZERO){let{windows:M,windowSize:K}=W$($,Q),Y=BigInt(2**$-1),j=2**$,X=BigInt($);for(let U=0;U<M;U++){let W=U*K;if(q===o$)break;let H=Number(q&Y);if(q>>=X,H>K)H-=j,q+=r0;if(H===0)continue;let g=I[W+Math.abs(H)-1];if(H<0)g=g.negate();G=G.add(g)}return G},getPrecomputes($,I,q){let G=D$.get(I);if(!G){if(G=this.precomputeWindow(I,$),$!==1)D$.set(I,q(G))}return G},wNAFCached($,I,q){let G=z$($);return this.wNAF(G,this.getPrecomputes(G,$,q),I)},wNAFCachedUnsafe($,I,q,G){let M=z$($);if(M===1)return this.unsafeLadder($,I,G);return this.wNAFUnsafe(M,this.getPrecomputes(M,$,q),I,G)},setWindowSize($,I){n$(I,Q),s$.set($,I),D$.delete($)}}}function p0(J,Q,$,I){if(T8($,J),O8(I,Q),$.length!==I.length)throw new Error("arrays of points and scalars must have equal length");let q=J.ZERO,G=K$(BigInt($.length)),M=G>12?G-3:G>4?G-2:G?2:1,K=(1<<M)-1,Y=new Array(K+1).fill(q),j=Math.floor((Q.BITS-1)/M)*M,X=q;for(let U=j;U>=0;U-=M){Y.fill(q);for(let H=0;H<I.length;H++){let g=I[H],N=Number(g>>BigInt(U)&BigInt(K));Y[N]=Y[N].add($[H])}let W=q;for(let H=Y.length-1,g=q;H>0;H--)g=g.add(Y[H]),W=W.add(g);if(X=X.add(W),U!==0)for(let H=0;H<M;H++)X=X.double()}return X}function P0(J){return V$(J.Fp),Y0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...T$(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var K0=BigInt(0),I0=BigInt(1),i0=BigInt(2),U8=BigInt(8),W8={zip215:!0};function D8(J){let Q=P0(J);return Y0(J,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...Q})}function t$(J){let Q=D8(J),{Fp:$,n:I,prehash:q,hash:G,randomBytes:M,nByteLength:K,h:Y}=Q,j=i0<<BigInt(K*8)-I0,X=$.create,U=L0(Q.n,Q.nBitLength),W=Q.uvRatio||((Z,T)=>{try{return{isValid:!0,value:$.sqrt(Z*$.inv(T))}}catch(z){return{isValid:!1,value:K0}}}),H=Q.adjustScalarBytes||((Z)=>Z),g=Q.domain||((Z,T,z)=>{if(M0("phflag",z),T.length||z)throw new Error("Contexts/pre-hash are not supported");return Z});function N(Z,T){t("coordinate "+Z,T,K0,j)}function D(Z){if(!(Z instanceof O))throw new Error("ExtendedPoint expected")}let B=B0((Z,T)=>{let{ex:z,ey:R,ez:P}=Z,b=Z.is0();if(T==null)T=b?U8:$.inv(P);let y=X(z*T),v=X(R*T),x=X(P*T);if(b)return{x:K0,y:I0};if(x!==I0)throw new Error("invZ was invalid");return{x:y,y:v}}),V=B0((Z)=>{let{a:T,d:z}=Q;if(Z.is0())throw new Error("bad point: ZERO");let{ex:R,ey:P,ez:b,et:y}=Z,v=X(R*R),x=X(P*P),u=X(b*b),r=X(u*u),$0=X(v*T),n=X(u*X($0+x)),i=X(r+X(z*X(v*x)));if(n!==i)throw new Error("bad point: equation left != right (1)");let q0=X(R*P),J0=X(b*y);if(q0!==J0)throw new Error("bad point: equation left != right (2)");return!0});class O{constructor(Z,T,z,R){this.ex=Z,this.ey=T,this.ez=z,this.et=R,N("x",Z),N("y",T),N("z",z),N("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(Z){if(Z instanceof O)throw new Error("extended point not allowed");let{x:T,y:z}=Z||{};return N("x",T),N("y",z),new O(T,z,I0,X(T*z))}static normalizeZ(Z){let T=$.invertBatch(Z.map((z)=>z.ez));return Z.map((z,R)=>z.toAffine(T[R])).map(O.fromAffine)}static msm(Z,T){return p0(O,U,Z,T)}_setWindowSize(Z){L.setWindowSize(this,Z)}assertValidity(){V(this)}equals(Z){D(Z);let{ex:T,ey:z,ez:R}=this,{ex:P,ey:b,ez:y}=Z,v=X(T*y),x=X(P*R),u=X(z*y),r=X(b*R);return v===x&&u===r}is0(){return this.equals(O.ZERO)}negate(){return new O(X(-this.ex),this.ey,this.ez,X(-this.et))}double(){let{a:Z}=Q,{ex:T,ey:z,ez:R}=this,P=X(T*T),b=X(z*z),y=X(i0*X(R*R)),v=X(Z*P),x=T+z,u=X(X(x*x)-P-b),r=v+b,$0=r-y,n=v-b,i=X(u*$0),q0=X(r*n),J0=X(u*n),G0=X($0*r);return new O(i,q0,G0,J0)}add(Z){D(Z);let{a:T,d:z}=Q,{ex:R,ey:P,ez:b,et:y}=this,{ex:v,ey:x,ez:u,et:r}=Z;if(T===BigInt(-1)){let g$=X((P-R)*(x+v)),b$=X((P+R)*(x-v)),e0=X(b$-g$);if(e0===K0)return this.double();let P$=X(b*i0*r),x$=X(y*i0*u),_$=x$+P$,y$=b$+g$,v$=x$-P$,BJ=X(_$*e0),wJ=X(y$*v$),RJ=X(_$*v$),fJ=X(e0*y$);return new O(BJ,wJ,fJ,RJ)}let $0=X(R*v),n=X(P*x),i=X(y*z*r),q0=X(b*u),J0=X((R+P)*(v+x)-$0-n),G0=q0-i,D0=q0+i,Z0=X(n-T*$0),c0=X(J0*G0),LJ=X(D0*Z0),SJ=X(J0*Z0),kJ=X(G0*D0);return new O(c0,LJ,kJ,SJ)}subtract(Z){return this.add(Z.negate())}wNAF(Z){return L.wNAFCached(this,Z,O.normalizeZ)}multiply(Z){let T=Z;t("scalar",T,I0,I);let{p:z,f:R}=this.wNAF(T);return O.normalizeZ([z,R])[0]}multiplyUnsafe(Z,T=O.ZERO){let z=Z;if(t("scalar",z,K0,I),z===K0)return E;if(this.is0()||z===I0)return this;return L.wNAFCachedUnsafe(this,z,O.normalizeZ,T)}isSmallOrder(){return this.multiplyUnsafe(Y).is0()}isTorsionFree(){return L.unsafeLadder(this,I).is0()}toAffine(Z){return B(this,Z)}clearCofactor(){let{h:Z}=Q;if(Z===I0)return this;return this.multiplyUnsafe(Z)}static fromHex(Z,T=!1){let{d:z,a:R}=Q,P=$.BYTES;Z=m("pointHex",Z,P),M0("zip215",T);let b=Z.slice(),y=Z[P-1];b[P-1]=y&-129;let v=X0(b),x=T?j:$.ORDER;t("pointHex.y",v,K0,x);let u=X(v*v),r=X(u-I0),$0=X(z*u-R),{isValid:n,value:i}=W(r,$0);if(!n)throw new Error("Point.fromHex: invalid y coordinate");let q0=(i&I0)===I0,J0=(y&128)!==0;if(!T&&i===K0&&J0)throw new Error("Point.fromHex: x=0 and x_0=1");if(J0!==q0)i=X(-i);return O.fromAffine({x:i,y:v})}static fromPrivateKey(Z){return F(Z).point}toRawBytes(){let{x:Z,y:T}=this.toAffine(),z=T0(T,$.BYTES);return z[z.length-1]|=Z&I0?128:0,z}toHex(){return j0(this.toRawBytes())}}O.BASE=new O(Q.Gx,Q.Gy,I0,X(Q.Gx*Q.Gy)),O.ZERO=new O(K0,I0,I0,K0);let{BASE:k,ZERO:E}=O,L=a0(O,K*8);function w(Z){return h(Z,I)}function S(Z){return w(X0(Z))}function F(Z){let T=$.BYTES;Z=m("private key",Z,T);let z=m("hashed private key",G(Z),2*T),R=H(z.slice(0,T)),P=z.slice(T,2*T),b=S(R),y=k.multiply(b),v=y.toRawBytes();return{head:R,prefix:P,scalar:b,point:y,pointBytes:v}}function c(Z){return F(Z).pointBytes}function f(Z=new Uint8Array,...T){let z=O0(...T);return S(G(g(z,m("context",Z),!!q)))}function a(Z,T,z={}){if(Z=m("message",Z),q)Z=q(Z);let{prefix:R,scalar:P,pointBytes:b}=F(T),y=f(z.context,R,Z),v=k.multiply(y).toRawBytes(),x=f(z.context,v,b,Z),u=w(y+x*P);t("signature.s",u,K0,I);let r=O0(v,T0(u,$.BYTES));return m("result",r,$.BYTES*2)}let p=W8;function A(Z,T,z,R=p){let{context:P,zip215:b}=R,y=$.BYTES;if(Z=m("signature",Z,2*y),T=m("message",T),z=m("publicKey",z,y),b!==void 0)M0("zip215",b);if(q)T=q(T);let v=X0(Z.slice(y,2*y)),x,u,r;try{x=O.fromHex(z,b),u=O.fromHex(Z.slice(0,y),b),r=k.multiplyUnsafe(v)}catch(i){return!1}if(!b&&x.isSmallOrder())return!1;let $0=f(P,u.toRawBytes(),x.toRawBytes(),T);return u.add(x.multiplyUnsafe($0)).subtract(r).clearCofactor().equals(O.ZERO)}return k._setWindowSize(8),{CURVE:Q,getPublicKey:c,sign:a,verify:A,ExtendedPoint:O,utils:{getExtendedPublicKey:F,randomPrivateKey:()=>M($.BYTES),precompute(Z=8,T=O.BASE){return T._setWindowSize(Z),T.multiply(BigInt(3)),T}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var f0=BigInt(0),A$=BigInt(1);function z8(J){return Y0(J,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...J})}function e$(J){let Q=z8(J),{P:$}=Q,I=(V)=>h(V,$),q=Q.montgomeryBits,G=Math.ceil(q/8),M=Q.nByteLength,K=Q.adjustScalarBytes||((V)=>V),Y=Q.powPminus2||((V)=>j$(V,$-BigInt(2),$));function j(V,O,k){let E=I(V*(O-k));return O=I(O-E),k=I(k+E),[O,k]}let X=(Q.a-BigInt(2))/BigInt(4);function U(V,O){t("u",V,f0,$),t("scalar",O,f0,$);let k=O,E=V,L=A$,w=f0,S=V,F=A$,c=f0,f;for(let p=BigInt(q-1);p>=f0;p--){let A=k>>p&A$;c^=A,f=j(c,L,S),L=f[0],S=f[1],f=j(c,w,F),w=f[0],F=f[1],c=A;let C=L+w,Z=I(C*C),T=L-w,z=I(T*T),R=Z-z,P=S+F,b=S-F,y=I(b*C),v=I(P*T),x=y+v,u=y-v;S=I(x*x),F=I(E*I(u*u)),L=I(Z*z),w=I(R*(Z+I(X*R)))}f=j(c,L,S),L=f[0],S=f[1],f=j(c,w,F),w=f[0],F=f[1];let a=Y(w);return I(L*a)}function W(V){return T0(I(V),G)}function H(V){let O=m("u coordinate",V,G);if(M===32)O[31]&=127;return X0(O)}function g(V){let O=m("scalar",V),k=O.length;if(k!==G&&k!==M){let E=""+G+" or "+M;throw new Error("invalid scalar, expected "+E+" bytes, got "+k)}return X0(K(O))}function N(V,O){let k=H(O),E=g(V),L=U(k,E);if(L===f0)throw new Error("invalid private or public key received");return W(L)}let D=W(Q.Gu);function B(V){return N(V,D)}return{scalarMult:N,scalarMultBase:B,getSharedSecret:(V,O)=>N(V,O),getPublicKey:(V)=>B(V),utils:{randomPrivateKey:()=>Q.randomBytes(Q.nByteLength)},GuBytes:D}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var x0=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),$J=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),DQ=BigInt(0),A8=BigInt(1),JJ=BigInt(2),H8=BigInt(3),C8=BigInt(5),L8=BigInt(8);function QJ(J){let Q=BigInt(10),$=BigInt(20),I=BigInt(40),q=BigInt(80),G=x0,K=J*J%G*J%G,Y=d(K,JJ,G)*K%G,j=d(Y,A8,G)*J%G,X=d(j,C8,G)*j%G,U=d(X,Q,G)*X%G,W=d(U,$,G)*U%G,H=d(W,I,G)*W%G,g=d(H,q,G)*H%G,N=d(g,q,G)*H%G,D=d(N,Q,G)*X%G;return{pow_p_5_8:d(D,JJ,G)*J%G,b2:K}}function IJ(J){return J[0]&=248,J[31]&=127,J[31]|=64,J}function S8(J,Q){let $=x0,I=h(Q*Q*Q,$),q=h(I*I*Q,$),G=QJ(J*q).pow_p_5_8,M=h(J*I*G,$),K=h(Q*M*M,$),Y=M,j=h(M*$J,$),X=K===J,U=K===h(-J,$),W=K===h(-J*$J,$);if(X)M=Y;if(U||W)M=j;if(a$(M,$))M=h(-M,$);return{isValid:X||U,value:M}}var k8=(()=>L0(x0,void 0,!0))(),B8=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:k8,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:L8,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:h$,randomBytes:_0,adjustScalarBytes:IJ,uvRatio:S8}))(),zQ=(()=>t$(B8))();var AQ=(()=>e$({P:x0,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:(J)=>{let Q=x0,{pow_p_5_8:$,b2:I}=QJ(J);return h(d($,H8,Q)*I,Q)},adjustScalarBytes:IJ,randomBytes:_0}))();var g8=E8(GJ(),1);var ZJ=[],NJ=[],jJ=[],b8=BigInt(0),v0=BigInt(1),P8=BigInt(2),x8=BigInt(7),_8=BigInt(256),y8=BigInt(113);for(let J=0,Q=v0,$=1,I=0;J<24;J++){[$,I]=[I,(2*$+3*I)%5],ZJ.push(2*(5*I+$)),NJ.push((J+1)*(J+2)/2%64);let q=b8;for(let G=0;G<7;G++)if(Q=(Q<<v0^(Q>>x8)*y8)%_8,Q&P8)q^=v0<<(v0<<BigInt(G))-v0;jJ.push(q)}var[v8,c8]=J$(jJ,!0),YJ=(J,Q,$)=>$>32?q$(J,Q,$):Q$(J,Q,$),MJ=(J,Q,$)=>$>32?G$(J,Q,$):I$(J,Q,$);function F8(J,Q=24){let $=new Uint32Array(10);for(let I=24-Q;I<24;I++){for(let M=0;M<10;M++)$[M]=J[M]^J[M+10]^J[M+20]^J[M+30]^J[M+40];for(let M=0;M<10;M+=2){let K=(M+8)%10,Y=(M+2)%10,j=$[Y],X=$[Y+1],U=YJ(j,X,1)^$[K],W=MJ(j,X,1)^$[K+1];for(let H=0;H<50;H+=10)J[M+H]^=U,J[M+H+1]^=W}let q=J[2],G=J[3];for(let M=0;M<24;M++){let K=NJ[M],Y=YJ(q,G,K),j=MJ(q,G,K),X=ZJ[M];q=J[X],G=J[X+1],J[X]=Y,J[X+1]=j}for(let M=0;M<50;M+=10){for(let K=0;K<10;K++)$[K]=J[M+K];for(let K=0;K<10;K++)J[M+K]^=~$[(K+2)%10]&$[(K+4)%10]}J[0]^=v8[I],J[1]^=c8[I]}$.fill(0)}class B$ extends t0{constructor(J,Q,$,I=!1,q=24){super();if(this.blockLen=J,this.suffix=Q,this.outputLen=$,this.enableXOF=I,this.rounds=q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,L$($),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=KJ(this.state)}keccak(){if(!S$)k$(this.state32);if(F8(this.state32,this.rounds),!S$)k$(this.state32);this.posOut=0,this.pos=0}update(J){E0(this);let{blockLen:Q,state:$}=this;J=s0(J);let I=J.length;for(let q=0;q<I;){let G=Math.min(Q-this.pos,I-q);for(let M=0;M<G;M++)$[this.pos++]^=J[q++];if(this.pos===Q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:J,suffix:Q,pos:$,blockLen:I}=this;if(J[$]^=Q,(Q&128)!==0&&$===I-1)this.keccak();J[I-1]^=128,this.keccak()}writeInto(J){E0(this,!1),n0(J),this.finish();let Q=this.state,{blockLen:$}=this;for(let I=0,q=J.length;I<q;){if(this.posOut>=$)this.keccak();let G=Math.min($-this.posOut,q-I);J.set(Q.subarray(this.posOut,this.posOut+G),I),this.posOut+=G,I+=G}return J}xofInto(J){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(J)}xof(J){return L$(J),this.xofInto(new Uint8Array(J))}digestInto(J){if(XJ(J,this),this.finished)throw new Error("digest() was already called");return this.writeInto(J),this.destroy(),J}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(J){let{blockLen:Q,suffix:$,outputLen:I,rounds:q,enableXOF:G}=this;return J||(J=new B$(Q,$,I,G,q)),J.state32.set(this.state32),J.pos=this.pos,J.posOut=this.posOut,J.finished=this.finished,J.rounds=q,J.suffix=$,J.outputLen=I,J.enableXOF=G,J.destroyed=this.destroyed,J}}var VJ=(J,Q,$)=>u0(()=>new B$(Q,J,$));var RQ=VJ(1,136,32);var fQ=VJ(1,72,64);class w$ extends t0{constructor(J,Q){super();this.finished=!1,this.destroyed=!1,TJ(J);let $=s0(Q);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let I=this.blockLen,q=new Uint8Array(I);q.set($.length>I?J.create().update($).digest():$);for(let G=0;G<q.length;G++)q[G]^=54;this.iHash.update(q),this.oHash=J.create();for(let G=0;G<q.length;G++)q[G]^=106;this.oHash.update(q),q.fill(0)}update(J){return E0(this),this.iHash.update(J),this}digestInto(J){E0(this),n0(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){let J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));let{oHash:Q,iHash:$,finished:I,destroyed:q,blockLen:G,outputLen:M}=this;return J=J,J.finished=I,J.destroyed=q,J.blockLen=G,J.outputLen=M,J.oHash=Q._cloneInto(J.oHash),J.iHash=$._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var R$=(J,Q,$)=>new w$(J,Q).update($).digest();R$.create=(J,Q)=>new w$(J,Q);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function OJ(J){if(J.lowS!==void 0)M0("lowS",J.lowS);if(J.prehash!==void 0)M0("prehash",J.prehash)}function u8(J){let Q=P0(J);Y0(Q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:$,Fp:I,a:q}=Q;if($){if(!I.eql(q,I.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof $!=="object"||typeof $.beta!=="bigint"||typeof $.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...Q})}var{bytesToNumberBE:h8,hexToBytes:m8}=d0,U0={Err:class J extends Error{constructor(Q=""){super(Q)}},_tlv:{encode:(J,Q)=>{let{Err:$}=U0;if(J<0||J>256)throw new $("tlv.encode: wrong tag");if(Q.length&1)throw new $("tlv.encode: unpadded data");let I=Q.length/2,q=S0(I);if(q.length/2&128)throw new $("tlv.encode: long form length too big");let G=I>127?S0(q.length/2|128):"";return S0(J)+G+q+Q},decode(J,Q){let{Err:$}=U0,I=0;if(J<0||J>256)throw new $("tlv.encode: wrong tag");if(Q.length<2||Q[I++]!==J)throw new $("tlv.decode: wrong tlv");let q=Q[I++],G=!!(q&128),M=0;if(!G)M=q;else{let Y=q&127;if(!Y)throw new $("tlv.decode(long): indefinite length not supported");if(Y>4)throw new $("tlv.decode(long): byte length is too big");let j=Q.subarray(I,I+Y);if(j.length!==Y)throw new $("tlv.decode: length bytes not complete");if(j[0]===0)throw new $("tlv.decode(long): zero leftmost byte");for(let X of j)M=M<<8|X;if(I+=Y,M<128)throw new $("tlv.decode(long): not minimal encoding")}let K=Q.subarray(I,I+M);if(K.length!==M)throw new $("tlv.decode: wrong value length");return{v:K,l:Q.subarray(I+M)}}},_int:{encode(J){let{Err:Q}=U0;if(J<W0)throw new Q("integer: negative integers are not allowed");let $=S0(J);if(Number.parseInt($[0],16)&8)$="00"+$;if($.length&1)throw new Q("unexpected DER parsing assertion: unpadded hex");return $},decode(J){let{Err:Q}=U0;if(J[0]&128)throw new Q("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new Q("invalid signature integer: unnecessary leading zero");return h8(J)}},toSig(J){let{Err:Q,_int:$,_tlv:I}=U0,q=typeof J==="string"?m8(J):J;R0(q);let{v:G,l:M}=I.decode(48,q);if(M.length)throw new Q("invalid signature: left bytes after parsing");let{v:K,l:Y}=I.decode(2,G),{v:j,l:X}=I.decode(2,Y);if(X.length)throw new Q("invalid signature: left bytes after parsing");return{r:$.decode(K),s:$.decode(j)}},hexFromSig(J){let{_tlv:Q,_int:$}=U0,I=Q.encode(2,$.encode(J.r)),q=Q.encode(2,$.encode(J.s)),G=I+q;return Q.encode(48,G)}},W0=BigInt(0),s=BigInt(1),yQ=BigInt(2),UJ=BigInt(3),vQ=BigInt(4);function d8(J){let Q=u8(J),{Fp:$}=Q,I=L0(Q.n,Q.nBitLength),q=Q.toBytes||((N,D,B)=>{let V=D.toAffine();return O0(Uint8Array.from([4]),$.toBytes(V.x),$.toBytes(V.y))}),G=Q.fromBytes||((N)=>{let D=N.subarray(1),B=$.fromBytes(D.subarray(0,$.BYTES)),V=$.fromBytes(D.subarray($.BYTES,2*$.BYTES));return{x:B,y:V}});function M(N){let{a:D,b:B}=Q,V=$.sqr(N),O=$.mul(V,N);return $.add($.add(O,$.mul(N,D)),B)}if(!$.eql($.sqr(Q.Gy),M(Q.Gx)))throw new Error("bad generator point: equation left != right");function K(N){return g0(N,s,Q.n)}function Y(N){let{allowedPrivateKeyLengths:D,nByteLength:B,wrapPrivateKey:V,n:O}=Q;if(D&&typeof N!=="bigint"){if(H0(N))N=j0(N);if(typeof N!=="string"||!D.includes(N.length))throw new Error("invalid private key");N=N.padStart(B*2,"0")}let k;try{k=typeof N==="bigint"?N:V0(m("private key",N,B))}catch(E){throw new Error("invalid private key, expected hex or "+B+" bytes, got "+typeof N)}if(V)k=h(k,O);return t("private key",k,s,O),k}function j(N){if(!(N instanceof W))throw new Error("ProjectivePoint expected")}let X=B0((N,D)=>{let{px:B,py:V,pz:O}=N;if($.eql(O,$.ONE))return{x:B,y:V};let k=N.is0();if(D==null)D=k?$.ONE:$.inv(O);let E=$.mul(B,D),L=$.mul(V,D),w=$.mul(O,D);if(k)return{x:$.ZERO,y:$.ZERO};if(!$.eql(w,$.ONE))throw new Error("invZ was invalid");return{x:E,y:L}}),U=B0((N)=>{if(N.is0()){if(Q.allowInfinityPoint&&!$.is0(N.py))return;throw new Error("bad point: ZERO")}let{x:D,y:B}=N.toAffine();if(!$.isValid(D)||!$.isValid(B))throw new Error("bad point: x or y not FE");let V=$.sqr(B),O=M(D);if(!$.eql(V,O))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class W{constructor(N,D,B){if(this.px=N,this.py=D,this.pz=B,N==null||!$.isValid(N))throw new Error("x required");if(D==null||!$.isValid(D))throw new Error("y required");if(B==null||!$.isValid(B))throw new Error("z required");Object.freeze(this)}static fromAffine(N){let{x:D,y:B}=N||{};if(!N||!$.isValid(D)||!$.isValid(B))throw new Error("invalid affine point");if(N instanceof W)throw new Error("projective point not allowed");let V=(O)=>$.eql(O,$.ZERO);if(V(D)&&V(B))return W.ZERO;return new W(D,B,$.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(N){let D=$.invertBatch(N.map((B)=>B.pz));return N.map((B,V)=>B.toAffine(D[V])).map(W.fromAffine)}static fromHex(N){let D=W.fromAffine(G(m("pointHex",N)));return D.assertValidity(),D}static fromPrivateKey(N){return W.BASE.multiply(Y(N))}static msm(N,D){return p0(W,I,N,D)}_setWindowSize(N){g.setWindowSize(this,N)}assertValidity(){U(this)}hasEvenY(){let{y:N}=this.toAffine();if($.isOdd)return!$.isOdd(N);throw new Error("Field doesn't support isOdd")}equals(N){j(N);let{px:D,py:B,pz:V}=this,{px:O,py:k,pz:E}=N,L=$.eql($.mul(D,E),$.mul(O,V)),w=$.eql($.mul(B,E),$.mul(k,V));return L&&w}negate(){return new W(this.px,$.neg(this.py),this.pz)}double(){let{a:N,b:D}=Q,B=$.mul(D,UJ),{px:V,py:O,pz:k}=this,E=$.ZERO,L=$.ZERO,w=$.ZERO,S=$.mul(V,V),F=$.mul(O,O),c=$.mul(k,k),f=$.mul(V,O);return f=$.add(f,f),w=$.mul(V,k),w=$.add(w,w),E=$.mul(N,w),L=$.mul(B,c),L=$.add(E,L),E=$.sub(F,L),L=$.add(F,L),L=$.mul(E,L),E=$.mul(f,E),w=$.mul(B,w),c=$.mul(N,c),f=$.sub(S,c),f=$.mul(N,f),f=$.add(f,w),w=$.add(S,S),S=$.add(w,S),S=$.add(S,c),S=$.mul(S,f),L=$.add(L,S),c=$.mul(O,k),c=$.add(c,c),S=$.mul(c,f),E=$.sub(E,S),w=$.mul(c,F),w=$.add(w,w),w=$.add(w,w),new W(E,L,w)}add(N){j(N);let{px:D,py:B,pz:V}=this,{px:O,py:k,pz:E}=N,L=$.ZERO,w=$.ZERO,S=$.ZERO,F=Q.a,c=$.mul(Q.b,UJ),f=$.mul(D,O),a=$.mul(B,k),p=$.mul(V,E),A=$.add(D,B),C=$.add(O,k);A=$.mul(A,C),C=$.add(f,a),A=$.sub(A,C),C=$.add(D,V);let Z=$.add(O,E);return C=$.mul(C,Z),Z=$.add(f,p),C=$.sub(C,Z),Z=$.add(B,V),L=$.add(k,E),Z=$.mul(Z,L),L=$.add(a,p),Z=$.sub(Z,L),S=$.mul(F,C),L=$.mul(c,p),S=$.add(L,S),L=$.sub(a,S),S=$.add(a,S),w=$.mul(L,S),a=$.add(f,f),a=$.add(a,f),p=$.mul(F,p),C=$.mul(c,C),a=$.add(a,p),p=$.sub(f,p),p=$.mul(F,p),C=$.add(C,p),f=$.mul(a,C),w=$.add(w,f),f=$.mul(Z,C),L=$.mul(A,L),L=$.sub(L,f),f=$.mul(A,a),S=$.mul(Z,S),S=$.add(S,f),new W(L,w,S)}subtract(N){return this.add(N.negate())}is0(){return this.equals(W.ZERO)}wNAF(N){return g.wNAFCached(this,N,W.normalizeZ)}multiplyUnsafe(N){let{endo:D,n:B}=Q;t("scalar",N,W0,B);let V=W.ZERO;if(N===W0)return V;if(this.is0()||N===s)return this;if(!D||g.hasPrecomputes(this))return g.wNAFCachedUnsafe(this,N,W.normalizeZ);let{k1neg:O,k1:k,k2neg:E,k2:L}=D.splitScalar(N),w=V,S=V,F=this;while(k>W0||L>W0){if(k&s)w=w.add(F);if(L&s)S=S.add(F);F=F.double(),k>>=s,L>>=s}if(O)w=w.negate();if(E)S=S.negate();return S=new W($.mul(S.px,D.beta),S.py,S.pz),w.add(S)}multiply(N){let{endo:D,n:B}=Q;t("scalar",N,s,B);let V,O;if(D){let{k1neg:k,k1:E,k2neg:L,k2:w}=D.splitScalar(N),{p:S,f:F}=this.wNAF(E),{p:c,f}=this.wNAF(w);S=g.constTimeNegate(k,S),c=g.constTimeNegate(L,c),c=new W($.mul(c.px,D.beta),c.py,c.pz),V=S.add(c),O=F.add(f)}else{let{p:k,f:E}=this.wNAF(N);V=k,O=E}return W.normalizeZ([V,O])[0]}multiplyAndAddUnsafe(N,D,B){let V=W.BASE,O=(E,L)=>L===W0||L===s||!E.equals(V)?E.multiplyUnsafe(L):E.multiply(L),k=O(this,D).add(O(N,B));return k.is0()?void 0:k}toAffine(N){return X(this,N)}isTorsionFree(){let{h:N,isTorsionFree:D}=Q;if(N===s)return!0;if(D)return D(W,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:N,clearCofactor:D}=Q;if(N===s)return this;if(D)return D(W,this);return this.multiplyUnsafe(Q.h)}toRawBytes(N=!0){return M0("isCompressed",N),this.assertValidity(),q(W,this,N)}toHex(N=!0){return M0("isCompressed",N),j0(this.toRawBytes(N))}}W.BASE=new W(Q.Gx,Q.Gy,$.ONE),W.ZERO=new W($.ZERO,$.ONE,$.ZERO);let H=Q.nBitLength,g=a0(W,Q.endo?Math.ceil(H/2):H);return{CURVE:Q,ProjectivePoint:W,normPrivateKeyToScalar:Y,weierstrassEquation:M,isWithinCurveOrder:K}}function l8(J){let Q=P0(J);return Y0(Q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Q})}function WJ(J){let Q=l8(J),{Fp:$,n:I}=Q,q=$.BYTES+1,G=2*$.BYTES+1;function M(A){return h(A,I)}function K(A){return l0(A,I)}let{ProjectivePoint:Y,normPrivateKeyToScalar:j,weierstrassEquation:X,isWithinCurveOrder:U}=d8({...Q,toBytes(A,C,Z){let T=C.toAffine(),z=$.toBytes(T.x),R=O0;if(M0("isCompressed",Z),Z)return R(Uint8Array.from([C.hasEvenY()?2:3]),z);else return R(Uint8Array.from([4]),z,$.toBytes(T.y))},fromBytes(A){let C=A.length,Z=A[0],T=A.subarray(1);if(C===q&&(Z===2||Z===3)){let z=V0(T);if(!g0(z,s,$.ORDER))throw new Error("Point is not on curve");let R=X(z),P;try{P=$.sqrt(R)}catch(v){let x=v instanceof Error?": "+v.message:"";throw new Error("Point is not on curve"+x)}let b=(P&s)===s;if((Z&1)===1!==b)P=$.neg(P);return{x:z,y:P}}else if(C===G&&Z===4){let z=$.fromBytes(T.subarray(0,$.BYTES)),R=$.fromBytes(T.subarray($.BYTES,2*$.BYTES));return{x:z,y:R}}else{let z=q,R=G;throw new Error("invalid Point, expected length of "+z+", or uncompressed "+R+", got "+C)}}}),W=(A)=>j0(C0(A,Q.nByteLength));function H(A){let C=I>>s;return A>C}function g(A){return H(A)?M(-A):A}let N=(A,C,Z)=>V0(A.slice(C,Z));class D{constructor(A,C,Z){this.r=A,this.s=C,this.recovery=Z,this.assertValidity()}static fromCompact(A){let C=Q.nByteLength;return A=m("compactSignature",A,C*2),new D(N(A,0,C),N(A,C,2*C))}static fromDER(A){let{r:C,s:Z}=U0.toSig(m("DER",A));return new D(C,Z)}assertValidity(){t("r",this.r,s,I),t("s",this.s,s,I)}addRecoveryBit(A){return new D(this.r,this.s,A)}recoverPublicKey(A){let{r:C,s:Z,recovery:T}=this,z=L(m("msgHash",A));if(T==null||![0,1,2,3].includes(T))throw new Error("recovery id invalid");let R=T===2||T===3?C+Q.n:C;if(R>=$.ORDER)throw new Error("recovery id 2 or 3 invalid");let P=(T&1)===0?"02":"03",b=Y.fromHex(P+W(R)),y=K(R),v=M(-z*y),x=M(Z*y),u=Y.BASE.multiplyAndAddUnsafe(b,v,x);if(!u)throw new Error("point at infinify");return u.assertValidity(),u}hasHighS(){return H(this.s)}normalizeS(){return this.hasHighS()?new D(this.r,M(-this.s),this.recovery):this}toDERRawBytes(){return k0(this.toDERHex())}toDERHex(){return U0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return k0(this.toCompactHex())}toCompactHex(){return W(this.r)+W(this.s)}}let B={isValidPrivateKey(A){try{return j(A),!0}catch(C){return!1}},normPrivateKeyToScalar:j,randomPrivateKey:()=>{let A=O$(Q.n);return i$(Q.randomBytes(A),Q.n)},precompute(A=8,C=Y.BASE){return C._setWindowSize(A),C.multiply(BigInt(3)),C}};function V(A,C=!0){return Y.fromPrivateKey(A).toRawBytes(C)}function O(A){let C=H0(A),Z=typeof A==="string",T=(C||Z)&&A.length;if(C)return T===q||T===G;if(Z)return T===2*q||T===2*G;if(A instanceof Y)return!0;return!1}function k(A,C,Z=!0){if(O(A))throw new Error("first arg must be private key");if(!O(C))throw new Error("second arg must be public key");return Y.fromHex(C).multiply(j(A)).toRawBytes(Z)}let E=Q.bits2int||function(A){if(A.length>8192)throw new Error("input is too large");let C=V0(A),Z=A.length*8-Q.nBitLength;return Z>0?C>>BigInt(Z):C},L=Q.bits2int_modN||function(A){return M(E(A))},w=b0(Q.nBitLength);function S(A){return t("num < 2^"+Q.nBitLength,A,W0,w),C0(A,Q.nByteLength)}function F(A,C,Z=c){if(["recovered","canonical"].some((n)=>(n in Z)))throw new Error("sign() legacy options not supported");let{hash:T,randomBytes:z}=Q,{lowS:R,prehash:P,extraEntropy:b}=Z;if(R==null)R=!0;if(A=m("msgHash",A),OJ(Z),P)A=m("prehashed msgHash",T(A));let y=L(A),v=j(C),x=[S(v),S(y)];if(b!=null&&b!==!1){let n=b===!0?z($.BYTES):b;x.push(m("extraEntropy",n))}let u=O0(...x),r=y;function $0(n){let i=E(n);if(!U(i))return;let q0=K(i),J0=Y.BASE.multiply(i).toAffine(),G0=M(J0.x);if(G0===W0)return;let D0=M(q0*M(r+G0*v));if(D0===W0)return;let Z0=(J0.x===G0?0:2)|Number(J0.y&s),c0=D0;if(R&&H(D0))c0=g(D0),Z0^=1;return new D(G0,c0,Z0)}return{seed:u,k2sig:$0}}let c={lowS:Q.lowS,prehash:!1},f={lowS:Q.lowS,prehash:!1};function a(A,C,Z=c){let{seed:T,k2sig:z}=F(A,C,Z),R=Q;return Z$(R.hash.outputLen,R.nByteLength,R.hmac)(T,z)}Y.BASE._setWindowSize(8);function p(A,C,Z,T=f){let z=A;C=m("msgHash",C),Z=m("publicKey",Z);let{lowS:R,prehash:P,format:b}=T;if(OJ(T),"strict"in T)throw new Error("options.strict was renamed to lowS");if(b!==void 0&&b!=="compact"&&b!=="der")throw new Error("format must be compact or der");let y=typeof z==="string"||H0(z),v=!y&&!b&&typeof z==="object"&&z!==null&&typeof z.r==="bigint"&&typeof z.s==="bigint";if(!y&&!v)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let x=void 0,u;try{if(v)x=new D(z.r,z.s);if(y){try{if(b!=="compact")x=D.fromDER(z)}catch(Z0){if(!(Z0 instanceof U0.Err))throw Z0}if(!x&&b!=="der")x=D.fromCompact(z)}u=Y.fromHex(Z)}catch(Z0){return!1}if(!x)return!1;if(R&&x.hasHighS())return!1;if(P)C=Q.hash(C);let{r,s:$0}=x,n=L(C),i=K($0),q0=M(n*i),J0=M(r*i),G0=Y.BASE.multiplyAndAddUnsafe(u,q0,J0)?.toAffine();if(!G0)return!1;return M(G0.x)===r}return{CURVE:Q,getPublicKey:V,getSharedSecret:k,sign:a,verify:p,ProjectivePoint:Y,Signature:D,utils:B}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function r8(J){return{hash:J,hmac:(Q,...$)=>R$(J,Q,H$(...$)),randomBytes:_0}}function DJ(J,Q){let $=(I)=>WJ({...J,...r8(I)});return Object.freeze({...$(Q),create:$})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var CJ=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),zJ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),a8=BigInt(1),f$=BigInt(2),AJ=(J,Q)=>(J+Q/f$)/Q;function p8(J){let Q=CJ,$=BigInt(3),I=BigInt(6),q=BigInt(11),G=BigInt(22),M=BigInt(23),K=BigInt(44),Y=BigInt(88),j=J*J*J%Q,X=j*j*J%Q,U=d(X,$,Q)*X%Q,W=d(U,$,Q)*X%Q,H=d(W,f$,Q)*j%Q,g=d(H,q,Q)*H%Q,N=d(g,G,Q)*g%Q,D=d(N,K,Q)*N%Q,B=d(D,Y,Q)*D%Q,V=d(B,K,Q)*N%Q,O=d(V,$,Q)*X%Q,k=d(O,M,Q)*g%Q,E=d(k,I,Q)*j%Q,L=d(E,f$,Q);if(!E$.eql(E$.sqr(L),J))throw new Error("Cannot find square root");return L}var E$=L0(CJ,void 0,void 0,{sqrt:p8}),i8=DJ({a:BigInt(0),b:BigInt(7),Fp:E$,n:zJ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{let Q=zJ,$=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),I=-a8*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),G=$,M=BigInt("0x100000000000000000000000000000000"),K=AJ(G*J,Q),Y=AJ(-I*J,Q),j=h(J-K*$-Y*q,Q),X=h(-K*I-Y*G,Q),U=j>M,W=X>M;if(U)j=Q-j;if(W)X=Q-X;if(j>M||X>M)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:U,k1:j,k2neg:W,k2:X}}}},HJ),aQ=BigInt(0);var pQ=i8.ProjectivePoint;
export{_ as Fe,h$ as Ge,zQ as He,AQ as Ie,g8 as Je,RQ as Ke,fQ as Le,R$ as Me,i8 as Ne};

//# debugId=FDD0C123CB1B1EAF64756E2164756E21
