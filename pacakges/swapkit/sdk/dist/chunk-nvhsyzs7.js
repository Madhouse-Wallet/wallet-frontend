import{He as h0,Je as k8,Ke as y8,Ne as y1}from"./chunk-vfvjtfb5.js";import{Oe as Z2}from"./chunk-cr99dd54.js";import{Re as J2}from"./chunk-kfwf4q2g.js";import{mf as b8}from"./chunk-kcet18sy.js";import{nf as I,of as XX,pf as r1}from"./chunk-002j43qk.js";import{cg as g0,dg as A1,eg as n0,fg as $2,gg as t}from"./chunk-g7j062ka.js";var Q2={};$2(Q2,{TextEncoder:()=>z1,TextDecoder:()=>q1});function q0(X,$,Q){return $<=X&&X<=Q}function F1(X){if(X===void 0)return{};if(X===Object(X))return X;throw TypeError("Could not convert argument to dictionary")}function m4(X){var $=String(X),Q=$.length,Y=0,Z=[];while(Y<Q){var J=$.charCodeAt(Y);if(J<55296||J>57343)Z.push(J);else if(56320<=J&&J<=57343)Z.push(65533);else if(55296<=J&&J<=56319)if(Y===Q-1)Z.push(65533);else{var M=X.charCodeAt(Y+1);if(56320<=M&&M<=57343){var K=J&1023,H=M&1023;Z.push(65536+(K<<10)+H),Y+=1}else Z.push(65533)}Y+=1}return Z}function b4(X){var $="";for(var Q=0;Q<X.length;++Q){var Y=X[Q];if(Y<=65535)$+=String.fromCharCode(Y);else Y-=65536,$+=String.fromCharCode((Y>>10)+55296,(Y&1023)+56320)}return $}function n1(X){this.tokens=[].slice.call(X)}function u1(X,$){if(X)throw TypeError("Decoder error");return $||65533}function y4(){}function d4(){}function q1(X,$){if(!(this instanceof q1))return new q1(X,$);if(X=X!==void 0?String(X).toLowerCase():W1,X!==W1)throw new Error("Encoding not supported. Only utf-8 is supported");$=F1($),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean($.fatal),this._ignoreBOM=Boolean($.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}function z1(X,$){if(!(this instanceof z1))return new z1(X,$);if(X=X!==void 0?String(X).toLowerCase():W1,X!==W1)throw new Error("Encoding not supported. Only utf-8 is supported");$=F1($),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean($.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}function f4(X){var $=X.fatal,Q=0,Y=0,Z=0,J=128,M=191;this.handler=function(K,H){if(H===P1&&Z!==0)return Z=0,u1($);if(H===P1)return m0;if(Z===0){if(q0(H,0,127))return H;if(q0(H,194,223))Z=1,Q=H-192;else if(q0(H,224,239)){if(H===224)J=160;if(H===237)M=159;Z=2,Q=H-224}else if(q0(H,240,244)){if(H===240)J=144;if(H===244)M=143;Z=3,Q=H-240}else return u1($);return Q=Q<<6*Z,null}if(!q0(H,J,M))return Q=Z=Y=0,J=128,M=191,K.prepend(H),u1($);if(J=128,M=191,Y+=1,Q+=H-128<<6*(Z-Y),Y!==Z)return null;var P=Q;return Q=Z=Y=0,P}}function p4(X){var $=X.fatal;this.handler=function(Q,Y){if(Y===P1)return m0;if(q0(Y,0,127))return Y;var Z,J;if(q0(Y,128,2047))Z=1,J=192;else if(q0(Y,2048,65535))Z=2,J=224;else if(q0(Y,65536,1114111))Z=3,J=240;var M=[(Y>>6*Z)+J];while(Z>0){var K=Y>>6*(Z-1);M.push(128|K&63),Z-=1}return M}}var P1=-1,m0=-1,W1="utf-8";var Y2=t(()=>{n1.prototype={endOfStream:function(){return!this.tokens.length},read:function(){if(!this.tokens.length)return P1;return this.tokens.shift()},prepend:function(X){if(Array.isArray(X)){var $=X;while($.length)this.tokens.unshift($.pop())}else this.tokens.unshift(X)},push:function(X){if(Array.isArray(X)){var $=X;while($.length)this.tokens.push($.shift())}else this.tokens.push(X)}};y4.prototype={handler:function(X,$){}};d4.prototype={handler:function(X,$){}};q1.prototype={decode:function X($,Q){var Y;if(typeof $==="object"&&$ instanceof ArrayBuffer)Y=new Uint8Array($);else if(typeof $==="object"&&"buffer"in $&&$.buffer instanceof ArrayBuffer)Y=new Uint8Array($.buffer,$.byteOffset,$.byteLength);else Y=new Uint8Array(0);if(Q=F1(Q),!this._streaming)this._decoder=new f4({fatal:this._fatal}),this._BOMseen=!1;this._streaming=Boolean(Q.stream);var Z=new n1(Y),J=[],M;while(!Z.endOfStream()){if(M=this._decoder.handler(Z,Z.read()),M===m0)break;if(M===null)continue;if(Array.isArray(M))J.push.apply(J,M);else J.push(M)}if(!this._streaming){do{if(M=this._decoder.handler(Z,Z.read()),M===m0)break;if(M===null)continue;if(Array.isArray(M))J.push.apply(J,M);else J.push(M)}while(!Z.endOfStream());this._decoder=null}if(J.length){if(["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen)if(J[0]===65279)this._BOMseen=!0,J.shift();else this._BOMseen=!0}return b4(J)}};z1.prototype={encode:function X($,Q){if($=$?String($):"",Q=F1(Q),!this._streaming)this._encoder=new p4(this._options);this._streaming=Boolean(Q.stream);var Y=[],Z=new n1(m4($)),J;while(!Z.endOfStream()){if(J=this._encoder.handler(Z,Z.read()),J===m0)break;if(Array.isArray(J))Y.push.apply(Y,J);else Y.push(J)}if(!this._streaming){while(!0){if(J=this._encoder.handler(Z,Z.read()),J===m0)break;if(Array.isArray(J))Y.push.apply(Y,J);else Y.push(J)}this._encoder=null}return new Uint8Array(Y)}}});var V2=n0((x)=>{var c4=x&&x.__createBinding||(Object.create?function(X,$,Q,Y){if(Y===void 0)Y=Q;Object.defineProperty(X,Y,{enumerable:!0,get:function(){return $[Q]}})}:function(X,$,Q,Y){if(Y===void 0)Y=Q;X[Y]=$[Q]}),l4=x&&x.__setModuleDefault||(Object.create?function(X,$){Object.defineProperty(X,"default",{enumerable:!0,value:$})}:function(X,$){X.default=$}),P0=x&&x.__decorate||function(X,$,Q,Y){var Z=arguments.length,J=Z<3?$:Y===null?Y=Object.getOwnPropertyDescriptor($,Q):Y,M;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")J=Reflect.decorate(X,$,Q,Y);else for(var K=X.length-1;K>=0;K--)if(M=X[K])J=(Z<3?M(J):Z>3?M($,Q,J):M($,Q))||J;return Z>3&&J&&Object.defineProperty($,Q,J),J},u4=x&&x.__importStar||function(X){if(X&&X.__esModule)return X;var $={};if(X!=null){for(var Q in X)if(Q!=="default"&&Object.hasOwnProperty.call(X,Q))c4($,X,Q)}return l4($,X),$},M2=x&&x.__importDefault||function(X){return X&&X.__esModule?X:{default:X}};Object.defineProperty(x,"__esModule",{value:!0});x.deserializeUnchecked=x.deserialize=x.serialize=x.BinaryReader=x.BinaryWriter=x.BorshError=x.baseDecode=x.baseEncode=void 0;var A0=M2(Z2()),K2=M2(J2()),n4=u4((Y2(),A1(Q2))),i4=typeof TextDecoder!=="function"?n4.TextDecoder:TextDecoder,o4=new i4("utf-8",{fatal:!0});function a4(X){if(typeof X==="string")X=Buffer.from(X,"utf8");return K2.default.encode(Buffer.from(X))}x.baseEncode=a4;function s4(X){return Buffer.from(K2.default.decode(X))}x.baseDecode=s4;var i1=1024;class u extends Error{constructor(X){super(X);this.fieldPath=[],this.originalMessage=X}addToFieldPath(X){this.fieldPath.splice(0,0,X),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}x.BorshError=u;class o1{constructor(){this.buf=Buffer.alloc(i1),this.length=0}maybeResize(){if(this.buf.length<16+this.length)this.buf=Buffer.concat([this.buf,Buffer.alloc(i1)])}writeU8(X){this.maybeResize(),this.buf.writeUInt8(X,this.length),this.length+=1}writeU16(X){this.maybeResize(),this.buf.writeUInt16LE(X,this.length),this.length+=2}writeU32(X){this.maybeResize(),this.buf.writeUInt32LE(X,this.length),this.length+=4}writeU64(X){this.maybeResize(),this.writeBuffer(Buffer.from(new A0.default(X).toArray("le",8)))}writeU128(X){this.maybeResize(),this.writeBuffer(Buffer.from(new A0.default(X).toArray("le",16)))}writeU256(X){this.maybeResize(),this.writeBuffer(Buffer.from(new A0.default(X).toArray("le",32)))}writeU512(X){this.maybeResize(),this.writeBuffer(Buffer.from(new A0.default(X).toArray("le",64)))}writeBuffer(X){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),X,Buffer.alloc(i1)]),this.length+=X.length}writeString(X){this.maybeResize();let $=Buffer.from(X,"utf8");this.writeU32($.length),this.writeBuffer($)}writeFixedArray(X){this.writeBuffer(Buffer.from(X))}writeArray(X,$){this.maybeResize(),this.writeU32(X.length);for(let Q of X)this.maybeResize(),$(Q)}toArray(){return this.buf.subarray(0,this.length)}}x.BinaryWriter=o1;function W0(X,$,Q){let Y=Q.value;Q.value=function(...Z){try{return Y.apply(this,Z)}catch(J){if(J instanceof RangeError){let M=J.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(M)>=0)throw new u("Reached the end of buffer when deserializing")}throw J}}}class X0{constructor(X){this.buf=X,this.offset=0}readU8(){let X=this.buf.readUInt8(this.offset);return this.offset+=1,X}readU16(){let X=this.buf.readUInt16LE(this.offset);return this.offset+=2,X}readU32(){let X=this.buf.readUInt32LE(this.offset);return this.offset+=4,X}readU64(){let X=this.readBuffer(8);return new A0.default(X,"le")}readU128(){let X=this.readBuffer(16);return new A0.default(X,"le")}readU256(){let X=this.readBuffer(32);return new A0.default(X,"le")}readU512(){let X=this.readBuffer(64);return new A0.default(X,"le")}readBuffer(X){if(this.offset+X>this.buf.length)throw new u(`Expected buffer length ${X} isn't within bounds`);let $=this.buf.slice(this.offset,this.offset+X);return this.offset+=X,$}readString(){let X=this.readU32(),$=this.readBuffer(X);try{return o4.decode($)}catch(Q){throw new u(`Error decoding UTF-8 string: ${Q}`)}}readFixedArray(X){return new Uint8Array(this.readBuffer(X))}readArray(X){let $=this.readU32(),Q=Array();for(let Y=0;Y<$;++Y)Q.push(X());return Q}}P0([W0],X0.prototype,"readU8",null);P0([W0],X0.prototype,"readU16",null);P0([W0],X0.prototype,"readU32",null);P0([W0],X0.prototype,"readU64",null);P0([W0],X0.prototype,"readU128",null);P0([W0],X0.prototype,"readU256",null);P0([W0],X0.prototype,"readU512",null);P0([W0],X0.prototype,"readString",null);P0([W0],X0.prototype,"readFixedArray",null);P0([W0],X0.prototype,"readArray",null);x.BinaryReader=X0;function G2(X){return X.charAt(0).toUpperCase()+X.slice(1)}function L0(X,$,Q,Y,Z){try{if(typeof Y==="string")Z[`write${G2(Y)}`](Q);else if(Y instanceof Array)if(typeof Y[0]==="number"){if(Q.length!==Y[0])throw new u(`Expecting byte array of length ${Y[0]}, but got ${Q.length} bytes`);Z.writeFixedArray(Q)}else if(Y.length===2&&typeof Y[1]==="number"){if(Q.length!==Y[1])throw new u(`Expecting byte array of length ${Y[1]}, but got ${Q.length} bytes`);for(let J=0;J<Y[1];J++)L0(X,null,Q[J],Y[0],Z)}else Z.writeArray(Q,(J)=>{L0(X,$,J,Y[0],Z)});else if(Y.kind!==void 0)switch(Y.kind){case"option":{if(Q===null||Q===void 0)Z.writeU8(0);else Z.writeU8(1),L0(X,$,Q,Y.type,Z);break}case"map":{Z.writeU32(Q.size),Q.forEach((J,M)=>{L0(X,$,M,Y.key,Z),L0(X,$,J,Y.value,Z)});break}default:throw new u(`FieldType ${Y} unrecognized`)}else H2(X,Q,Z)}catch(J){if(J instanceof u)J.addToFieldPath($);throw J}}function H2(X,$,Q){if(typeof $.borshSerialize==="function"){$.borshSerialize(Q);return}let Y=X.get($.constructor);if(!Y)throw new u(`Class ${$.constructor.name} is missing in schema`);if(Y.kind==="struct")Y.fields.map(([Z,J])=>{L0(X,Z,$[Z],J,Q)});else if(Y.kind==="enum"){let Z=$[Y.field];for(let J=0;J<Y.values.length;++J){let[M,K]=Y.values[J];if(M===Z){Q.writeU8(J),L0(X,M,$[M],K,Q);break}}}else throw new u(`Unexpected schema kind: ${Y.kind} for ${$.constructor.name}`)}function r4(X,$,Q=o1){let Y=new Q;return H2(X,$,Y),Y.toArray()}x.serialize=r4;function E0(X,$,Q,Y){try{if(typeof Q==="string")return Y[`read${G2(Q)}`]();if(Q instanceof Array)if(typeof Q[0]==="number")return Y.readFixedArray(Q[0]);else if(typeof Q[1]==="number"){let Z=[];for(let J=0;J<Q[1];J++)Z.push(E0(X,null,Q[0],Y));return Z}else return Y.readArray(()=>E0(X,$,Q[0],Y));if(Q.kind==="option"){if(Y.readU8())return E0(X,$,Q.type,Y);return}if(Q.kind==="map"){let Z=new Map,J=Y.readU32();for(let M=0;M<J;M++){let K=E0(X,$,Q.key,Y),H=E0(X,$,Q.value,Y);Z.set(K,H)}return Z}return a1(X,Q,Y)}catch(Z){if(Z instanceof u)Z.addToFieldPath($);throw Z}}function a1(X,$,Q){if(typeof $.borshDeserialize==="function")return $.borshDeserialize(Q);let Y=X.get($);if(!Y)throw new u(`Class ${$.name} is missing in schema`);if(Y.kind==="struct"){let Z={};for(let[J,M]of X.get($).fields)Z[J]=E0(X,J,M,Q);return new $(Z)}if(Y.kind==="enum"){let Z=Q.readU8();if(Z>=Y.values.length)throw new u(`Enum index: ${Z} is out of range`);let[J,M]=Y.values[Z],K=E0(X,J,M,Q);return new $({[J]:K})}throw new u(`Unexpected schema kind: ${Y.kind} for ${$.constructor.name}`)}function t4(X,$,Q,Y=X0){let Z=new Y(Q),J=a1(X,$,Z);if(Z.offset<Q.length)throw new u(`Unexpected ${Q.length-Z.offset} bytes after deserialized data`);return J}x.deserialize=t4;function e4(X,$,Q,Y=X0){let Z=new Y(Q);return a1(X,$,Z)}x.deserializeUnchecked=e4});var D8=n0((P2)=>{Object.defineProperty(P2,"__esModule",{value:!0});P2.s16=P2.s8=P2.nu64be=P2.u48be=P2.u40be=P2.u32be=P2.u24be=P2.u16be=P2.nu64=P2.u48=P2.u40=P2.u32=P2.u24=P2.u16=P2.u8=P2.offset=P2.greedy=P2.Constant=P2.UTF8=P2.CString=P2.Blob=P2.Boolean=P2.BitField=P2.BitStructure=P2.VariantLayout=P2.Union=P2.UnionLayoutDiscriminator=P2.UnionDiscriminator=P2.Structure=P2.Sequence=P2.DoubleBE=P2.Double=P2.FloatBE=P2.Float=P2.NearInt64BE=P2.NearInt64=P2.NearUInt64BE=P2.NearUInt64=P2.IntBE=P2.Int=P2.UIntBE=P2.UInt=P2.OffsetLayout=P2.GreedyCount=P2.ExternalLayout=P2.bindConstructorLayout=P2.nameWithProperty=P2.Layout=P2.uint8ArrayToBuffer=P2.checkUint8Array=void 0;P2.constant=P2.utf8=P2.cstr=P2.blob=P2.unionLayoutDiscriminator=P2.union=P2.seq=P2.bits=P2.struct=P2.f64be=P2.f64=P2.f32be=P2.f32=P2.ns64be=P2.s48be=P2.s40be=P2.s32be=P2.s24be=P2.s16be=P2.ns64=P2.s48=P2.s40=P2.s32=P2.s24=void 0;var t1=(r1(),A1(XX));function y0(X){if(!(X instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}P2.checkUint8Array=y0;function _(X){return y0(X),t1.Buffer.from(X.buffer,X.byteOffset,X.length)}P2.uint8ArrayToBuffer=_;class g{constructor(X,$){if(!Number.isInteger(X))throw new TypeError("span must be an integer");this.span=X,this.property=$}makeDestinationObject(){return{}}getSpan(X,$){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(X){let $=Object.create(this.constructor.prototype);return Object.assign($,this),$.property=X,$}fromArray(X){return}}P2.Layout=g;function e1(X,$){if($.property)return X+"["+$.property+"]";return X}P2.nameWithProperty=e1;function $X(X,$){if(typeof X!=="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(X,"layout_"))throw new Error("Class is already bound to a layout");if(!($&&$ instanceof g))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call($,"boundConstructor_"))throw new Error("layout is already bound to a constructor");X.layout_=$,$.boundConstructor_=X,$.makeDestinationObject=()=>new X,Object.defineProperty(X.prototype,"encode",{value(Q,Y){return $.encode(this,Q,Y)},writable:!0}),Object.defineProperty(X,"decode",{value(Q,Y){return $.decode(Q,Y)},writable:!0})}P2.bindConstructorLayout=$X;class e extends g{isCount(){throw new Error("ExternalLayout is abstract")}}P2.ExternalLayout=e;class X8 extends e{constructor(X=1,$){if(!Number.isInteger(X)||0>=X)throw new TypeError("elementSpan must be a (positive) integer");super(-1,$);this.elementSpan=X}isCount(){return!0}decode(X,$=0){y0(X);let Q=X.length-$;return Math.floor(Q/this.elementSpan)}encode(X,$,Q){return 0}}P2.GreedyCount=X8;class D1 extends e{constructor(X,$=0,Q){if(!(X instanceof g))throw new TypeError("layout must be a Layout");if(!Number.isInteger($))throw new TypeError("offset must be integer or undefined");super(X.span,Q||X.property);this.layout=X,this.offset=$}isCount(){return this.layout instanceof $0||this.layout instanceof Q0}decode(X,$=0){return this.layout.decode(X,$+this.offset)}encode(X,$,Q=0){return this.layout.encode(X,$,Q+this.offset)}}P2.OffsetLayout=D1;class $0 extends g{constructor(X,$){super(X,$);if(6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(X,$=0){return _(X).readUIntLE($,this.span)}encode(X,$,Q=0){return _($).writeUIntLE(X,Q,this.span),this.span}}P2.UInt=$0;class Q0 extends g{constructor(X,$){super(X,$);if(6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(X,$=0){return _(X).readUIntBE($,this.span)}encode(X,$,Q=0){return _($).writeUIntBE(X,Q,this.span),this.span}}P2.UIntBE=Q0;class D0 extends g{constructor(X,$){super(X,$);if(6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(X,$=0){return _(X).readIntLE($,this.span)}encode(X,$,Q=0){return _($).writeIntLE(X,Q,this.span),this.span}}P2.Int=D0;class S0 extends g{constructor(X,$){super(X,$);if(6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(X,$=0){return _(X).readIntBE($,this.span)}encode(X,$,Q=0){return _($).writeIntBE(X,Q,this.span),this.span}}P2.IntBE=S0;var s1=Math.pow(2,32);function C1(X){let $=Math.floor(X/s1),Q=X-$*s1;return{hi32:$,lo32:Q}}function O1(X,$){return X*s1+$}class $8 extends g{constructor(X){super(8,X)}decode(X,$=0){let Q=_(X),Y=Q.readUInt32LE($),Z=Q.readUInt32LE($+4);return O1(Z,Y)}encode(X,$,Q=0){let Y=C1(X),Z=_($);return Z.writeUInt32LE(Y.lo32,Q),Z.writeUInt32LE(Y.hi32,Q+4),8}}P2.NearUInt64=$8;class Q8 extends g{constructor(X){super(8,X)}decode(X,$=0){let Q=_(X),Y=Q.readUInt32BE($),Z=Q.readUInt32BE($+4);return O1(Y,Z)}encode(X,$,Q=0){let Y=C1(X),Z=_($);return Z.writeUInt32BE(Y.hi32,Q),Z.writeUInt32BE(Y.lo32,Q+4),8}}P2.NearUInt64BE=Q8;class Y8 extends g{constructor(X){super(8,X)}decode(X,$=0){let Q=_(X),Y=Q.readUInt32LE($),Z=Q.readInt32LE($+4);return O1(Z,Y)}encode(X,$,Q=0){let Y=C1(X),Z=_($);return Z.writeUInt32LE(Y.lo32,Q),Z.writeInt32LE(Y.hi32,Q+4),8}}P2.NearInt64=Y8;class Z8 extends g{constructor(X){super(8,X)}decode(X,$=0){let Q=_(X),Y=Q.readInt32BE($),Z=Q.readUInt32BE($+4);return O1(Y,Z)}encode(X,$,Q=0){let Y=C1(X),Z=_($);return Z.writeInt32BE(Y.hi32,Q),Z.writeUInt32BE(Y.lo32,Q+4),8}}P2.NearInt64BE=Z8;class J8 extends g{constructor(X){super(4,X)}decode(X,$=0){return _(X).readFloatLE($)}encode(X,$,Q=0){return _($).writeFloatLE(X,Q),4}}P2.Float=J8;class M8 extends g{constructor(X){super(4,X)}decode(X,$=0){return _(X).readFloatBE($)}encode(X,$,Q=0){return _($).writeFloatBE(X,Q),4}}P2.FloatBE=M8;class K8 extends g{constructor(X){super(8,X)}decode(X,$=0){return _(X).readDoubleLE($)}encode(X,$,Q=0){return _($).writeDoubleLE(X,Q),8}}P2.Double=K8;class G8 extends g{constructor(X){super(8,X)}decode(X,$=0){return _(X).readDoubleBE($)}encode(X,$,Q=0){return _($).writeDoubleBE(X,Q),8}}P2.DoubleBE=G8;class H8 extends g{constructor(X,$,Q){if(!(X instanceof g))throw new TypeError("elementLayout must be a Layout");if(!($ instanceof e&&$.isCount()||Number.isInteger($)&&0<=$))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let Y=-1;if(!($ instanceof e)&&0<X.span)Y=$*X.span;super(Y,Q);this.elementLayout=X,this.count=$}getSpan(X,$=0){if(0<=this.span)return this.span;let Q=0,Y=this.count;if(Y instanceof e)Y=Y.decode(X,$);if(0<this.elementLayout.span)Q=Y*this.elementLayout.span;else{let Z=0;while(Z<Y)Q+=this.elementLayout.getSpan(X,$+Q),++Z}return Q}decode(X,$=0){let Q=[],Y=0,Z=this.count;if(Z instanceof e)Z=Z.decode(X,$);while(Y<Z)Q.push(this.elementLayout.decode(X,$)),$+=this.elementLayout.getSpan(X,$),Y+=1;return Q}encode(X,$,Q=0){let Y=this.elementLayout,Z=X.reduce((J,M)=>{return J+Y.encode(M,$,Q+J)},0);if(this.count instanceof e)this.count.encode(X.length,$,Q);return Z}}P2.Sequence=H8;class V8 extends g{constructor(X,$,Q){if(!(Array.isArray(X)&&X.reduce((Z,J)=>Z&&J instanceof g,!0)))throw new TypeError("fields must be array of Layout instances");if(typeof $==="boolean"&&Q===void 0)Q=$,$=void 0;for(let Z of X)if(0>Z.span&&Z.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let Y=-1;try{Y=X.reduce((Z,J)=>Z+J.getSpan(),0)}catch(Z){}super(Y,$);this.fields=X,this.decodePrefixes=!!Q}getSpan(X,$=0){if(0<=this.span)return this.span;let Q=0;try{Q=this.fields.reduce((Y,Z)=>{let J=Z.getSpan(X,$);return $+=J,Y+J},0)}catch(Y){throw new RangeError("indeterminate span")}return Q}decode(X,$=0){y0(X);let Q=this.makeDestinationObject();for(let Y of this.fields){if(Y.property!==void 0)Q[Y.property]=Y.decode(X,$);if($+=Y.getSpan(X,$),this.decodePrefixes&&X.length===$)break}return Q}encode(X,$,Q=0){let Y=Q,Z=0,J=0;for(let M of this.fields){let K=M.span;if(J=0<K?K:0,M.property!==void 0){let H=X[M.property];if(H!==void 0){if(J=M.encode(H,$,Q),0>K)K=M.getSpan($,Q)}}Z=Q,Q+=K}return Z+J-Y}fromArray(X){let $=this.makeDestinationObject();for(let Q of this.fields)if(Q.property!==void 0&&0<X.length)$[Q.property]=X.shift();return $}layoutFor(X){if(typeof X!=="string")throw new TypeError("property must be string");for(let $ of this.fields)if($.property===X)return $;return}offsetOf(X){if(typeof X!=="string")throw new TypeError("property must be string");let $=0;for(let Q of this.fields){if(Q.property===X)return $;if(0>Q.span)$=-1;else if(0<=$)$+=Q.span}return}}P2.Structure=V8;class R1{constructor(X){this.property=X}decode(X,$){throw new Error("UnionDiscriminator is abstract")}encode(X,$,Q){throw new Error("UnionDiscriminator is abstract")}}P2.UnionDiscriminator=R1;class i0 extends R1{constructor(X,$){if(!(X instanceof e&&X.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super($||X.property||"variant");this.layout=X}decode(X,$){return this.layout.decode(X,$)}encode(X,$,Q){return this.layout.encode(X,$,Q)}}P2.UnionLayoutDiscriminator=i0;class N1 extends g{constructor(X,$,Q){let Y;if(X instanceof $0||X instanceof Q0)Y=new i0(new D1(X));else if(X instanceof e&&X.isCount())Y=new i0(X);else if(!(X instanceof R1))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");else Y=X;if($===void 0)$=null;if(!($===null||$ instanceof g))throw new TypeError("defaultLayout must be null or a Layout");if($!==null){if(0>$.span)throw new Error("defaultLayout must have constant span");if($.property===void 0)$=$.replicate("content")}let Z=-1;if($){if(Z=$.span,0<=Z&&(X instanceof $0||X instanceof Q0))Z+=Y.layout.span}super(Z,Q);this.discriminator=Y,this.usesPrefixDiscriminator=X instanceof $0||X instanceof Q0,this.defaultLayout=$,this.registry={};let J=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(M){return J(M)},this.configGetSourceVariant=function(M){J=M.bind(this)}}getSpan(X,$=0){if(0<=this.span)return this.span;let Q=this.getVariant(X,$);if(!Q)throw new Error("unable to determine span for unrecognized variant");return Q.getSpan(X,$)}defaultGetSourceVariant(X){if(Object.prototype.hasOwnProperty.call(X,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(X,this.defaultLayout.property))return;let $=this.registry[X[this.discriminator.property]];if($&&(!$.layout||$.property&&Object.prototype.hasOwnProperty.call(X,$.property)))return $}else for(let $ in this.registry){let Q=this.registry[$];if(Q.property&&Object.prototype.hasOwnProperty.call(X,Q.property))return Q}throw new Error("unable to infer src variant")}decode(X,$=0){let Q,Y=this.discriminator,Z=Y.decode(X,$),J=this.registry[Z];if(J===void 0){let M=this.defaultLayout,K=0;if(this.usesPrefixDiscriminator)K=Y.layout.span;Q=this.makeDestinationObject(),Q[Y.property]=Z,Q[M.property]=M.decode(X,$+K)}else Q=J.decode(X,$);return Q}encode(X,$,Q=0){let Y=this.getSourceVariant(X);if(Y===void 0){let Z=this.discriminator,J=this.defaultLayout,M=0;if(this.usesPrefixDiscriminator)M=Z.layout.span;return Z.encode(X[Z.property],$,Q),M+J.encode(X[J.property],$,Q+M)}return Y.encode(X,$,Q)}addVariant(X,$,Q){let Y=new P8(this,X,$,Q);return this.registry[X]=Y,Y}getVariant(X,$=0){let Q;if(X instanceof Uint8Array)Q=this.discriminator.decode(X,$);else Q=X;return this.registry[Q]}}P2.Union=N1;class P8 extends g{constructor(X,$,Q,Y){if(!(X instanceof N1))throw new TypeError("union must be a Union");if(!Number.isInteger($)||0>$)throw new TypeError("variant must be a (non-negative) integer");if(typeof Q==="string"&&Y===void 0)Y=Q,Q=null;if(Q){if(!(Q instanceof g))throw new TypeError("layout must be a Layout");if(X.defaultLayout!==null&&0<=Q.span&&Q.span>X.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof Y!=="string")throw new TypeError("variant must have a String property")}let Z=X.span;if(0>X.span){if(Z=Q?Q.span:0,0<=Z&&X.usesPrefixDiscriminator)Z+=X.discriminator.layout.span}super(Z,Y);this.union=X,this.variant=$,this.layout=Q||null}getSpan(X,$=0){if(0<=this.span)return this.span;let Q=0;if(this.union.usesPrefixDiscriminator)Q=this.union.discriminator.layout.span;let Y=0;if(this.layout)Y=this.layout.getSpan(X,$+Q);return Q+Y}decode(X,$=0){let Q=this.makeDestinationObject();if(this!==this.union.getVariant(X,$))throw new Error("variant mismatch");let Y=0;if(this.union.usesPrefixDiscriminator)Y=this.union.discriminator.layout.span;if(this.layout)Q[this.property]=this.layout.decode(X,$+Y);else if(this.property)Q[this.property]=!0;else if(this.union.usesPrefixDiscriminator)Q[this.union.discriminator.property]=this.variant;return Q}encode(X,$,Q=0){let Y=0;if(this.union.usesPrefixDiscriminator)Y=this.union.discriminator.layout.span;if(this.layout&&!Object.prototype.hasOwnProperty.call(X,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,$,Q);let Z=Y;if(this.layout){if(this.layout.encode(X[this.property],$,Q+Y),Z+=this.layout.getSpan($,Q+Y),0<=this.union.span&&Z>this.union.span)throw new Error("encoded variant overruns containing union")}return Z}fromArray(X){if(this.layout)return this.layout.fromArray(X);return}}P2.VariantLayout=P8;function b0(X){if(0>X)X+=4294967296;return X}class j1 extends g{constructor(X,$,Q){if(!(X instanceof $0||X instanceof Q0))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof $==="string"&&Q===void 0)Q=$,$=!1;if(4<X.span)throw new RangeError("word cannot exceed 32 bits");super(X.span,Q);this.word=X,this.msb=!!$,this.fields=[];let Y=0;this._packedSetValue=function(Z){return Y=b0(Z),this},this._packedGetValue=function(){return Y}}decode(X,$=0){let Q=this.makeDestinationObject(),Y=this.word.decode(X,$);this._packedSetValue(Y);for(let Z of this.fields)if(Z.property!==void 0)Q[Z.property]=Z.decode(X);return Q}encode(X,$,Q=0){let Y=this.word.decode($,Q);this._packedSetValue(Y);for(let Z of this.fields)if(Z.property!==void 0){let J=X[Z.property];if(J!==void 0)Z.encode(J)}return this.word.encode(this._packedGetValue(),$,Q)}addField(X,$){let Q=new w1(this,X,$);return this.fields.push(Q),Q}addBoolean(X){let $=new W8(this,X);return this.fields.push($),$}fieldFor(X){if(typeof X!=="string")throw new TypeError("property must be string");for(let $ of this.fields)if($.property===X)return $;return}}P2.BitStructure=j1;class w1{constructor(X,$,Q){if(!(X instanceof j1))throw new TypeError("container must be a BitStructure");if(!Number.isInteger($)||0>=$)throw new TypeError("bits must be positive integer");let Y=8*X.span,Z=X.fields.reduce((J,M)=>J+M.bits,0);if($+Z>Y)throw new Error("bits too long for span remainder ("+(Y-Z)+" of "+Y+" remain)");if(this.container=X,this.bits=$,this.valueMask=(1<<$)-1,$===32)this.valueMask=4294967295;if(this.start=Z,this.container.msb)this.start=Y-Z-$;this.wordMask=b0(this.valueMask<<this.start),this.property=Q}decode(X,$){let Q=this.container._packedGetValue();return b0(Q&this.wordMask)>>>this.start}encode(X){if(typeof X!=="number"||!Number.isInteger(X)||X!==b0(X&this.valueMask))throw new TypeError(e1("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let $=this.container._packedGetValue(),Q=b0(X<<this.start);this.container._packedSetValue(b0($&~this.wordMask)|Q)}}P2.BitField=w1;class W8 extends w1{constructor(X,$){super(X,1,$)}decode(X,$){return!!super.decode(X,$)}encode(X){if(typeof X==="boolean")X=+X;super.encode(X)}}P2.Boolean=W8;class q8 extends g{constructor(X,$){if(!(X instanceof e&&X.isCount()||Number.isInteger(X)&&0<=X))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let Q=-1;if(!(X instanceof e))Q=X;super(Q,$);this.length=X}getSpan(X,$){let Q=this.span;if(0>Q)Q=this.length.decode(X,$);return Q}decode(X,$=0){let Q=this.span;if(0>Q)Q=this.length.decode(X,$);return _(X).slice($,$+Q)}encode(X,$,Q){let Y=this.length;if(this.length instanceof e)Y=X.length;if(!(X instanceof Uint8Array&&Y===X.length))throw new TypeError(e1("Blob.encode",this)+" requires (length "+Y+") Uint8Array as src");if(Q+Y>$.length)throw new RangeError("encoding overruns Uint8Array");let Z=_(X);if(_($).write(Z.toString("hex"),Q,Y,"hex"),this.length instanceof e)this.length.encode(Y,$,Q);return Y}}P2.Blob=q8;class z8 extends g{constructor(X){super(-1,X)}getSpan(X,$=0){y0(X);let Q=$;while(Q<X.length&&X[Q]!==0)Q+=1;return 1+Q-$}decode(X,$=0){let Q=this.getSpan(X,$);return _(X).slice($,$+Q-1).toString("utf-8")}encode(X,$,Q=0){if(typeof X!=="string")X=String(X);let Y=t1.Buffer.from(X,"utf8"),Z=Y.length;if(Q+Z>$.length)throw new RangeError("encoding overruns Buffer");let J=_($);return Y.copy(J,Q),J[Q+Z]=0,Z+1}}P2.CString=z8;class F8 extends g{constructor(X,$){if(typeof X==="string"&&$===void 0)$=X,X=void 0;if(X===void 0)X=-1;else if(!Number.isInteger(X))throw new TypeError("maxSpan must be an integer");super(-1,$);this.maxSpan=X}getSpan(X,$=0){return y0(X),X.length-$}decode(X,$=0){let Q=this.getSpan(X,$);if(0<=this.maxSpan&&this.maxSpan<Q)throw new RangeError("text length exceeds maxSpan");return _(X).slice($,$+Q).toString("utf-8")}encode(X,$,Q=0){if(typeof X!=="string")X=String(X);let Y=t1.Buffer.from(X,"utf8"),Z=Y.length;if(0<=this.maxSpan&&this.maxSpan<Z)throw new RangeError("text length exceeds maxSpan");if(Q+Z>$.length)throw new RangeError("encoding overruns Buffer");return Y.copy(_($),Q),Z}}P2.UTF8=F8;class A8 extends g{constructor(X,$){super(0,$);this.value=X}decode(X,$){return this.value}encode(X,$,Q){return 0}}P2.Constant=A8;P2.greedy=(X,$)=>new X8(X,$);P2.offset=(X,$,Q)=>new D1(X,$,Q);P2.u8=(X)=>new $0(1,X);P2.u16=(X)=>new $0(2,X);P2.u24=(X)=>new $0(3,X);P2.u32=(X)=>new $0(4,X);P2.u40=(X)=>new $0(5,X);P2.u48=(X)=>new $0(6,X);P2.nu64=(X)=>new $8(X);P2.u16be=(X)=>new Q0(2,X);P2.u24be=(X)=>new Q0(3,X);P2.u32be=(X)=>new Q0(4,X);P2.u40be=(X)=>new Q0(5,X);P2.u48be=(X)=>new Q0(6,X);P2.nu64be=(X)=>new Q8(X);P2.s8=(X)=>new D0(1,X);P2.s16=(X)=>new D0(2,X);P2.s24=(X)=>new D0(3,X);P2.s32=(X)=>new D0(4,X);P2.s40=(X)=>new D0(5,X);P2.s48=(X)=>new D0(6,X);P2.ns64=(X)=>new Y8(X);P2.s16be=(X)=>new S0(2,X);P2.s24be=(X)=>new S0(3,X);P2.s32be=(X)=>new S0(4,X);P2.s40be=(X)=>new S0(5,X);P2.s48be=(X)=>new S0(6,X);P2.ns64be=(X)=>new Z8(X);P2.f32=(X)=>new J8(X);P2.f32be=(X)=>new M8(X);P2.f64=(X)=>new K8(X);P2.f64be=(X)=>new G8(X);P2.struct=(X,$,Q)=>new V8(X,$,Q);P2.bits=(X,$,Q)=>new j1(X,$,Q);P2.seq=(X,$,Q)=>new H8(X,$,Q);P2.union=(X,$,Q)=>new N1(X,$,Q);P2.unionLayoutDiscriminator=(X,$)=>new i0(X,$);P2.blob=(X,$)=>new q8(X,$);P2.cstr=(X)=>new z8(X);P2.utf8=(X,$)=>new F8(X,$);P2.constant=(X,$)=>new A8(X,$)});var F2=n0((z2)=>{Object.defineProperty(z2,"__esModule",{value:!0});var U1;function R$(X){{let $=Buffer.from(X);$.reverse();let Q=$.toString("hex");if(Q.length===0)return BigInt(0);return BigInt(`0x${Q}`)}return U1.toBigInt(X,!1)}z2.toBigIntLE=R$;function N$(X){{let $=X.toString("hex");if($.length===0)return BigInt(0);return BigInt(`0x${$}`)}return U1.toBigInt(X,!0)}z2.toBigIntBE=N$;function j$(X,$){{let Q=X.toString(16),Y=Buffer.from(Q.padStart($*2,"0").slice(0,$*2),"hex");return Y.reverse(),Y}return U1.fromBigInt(X,Buffer.allocUnsafe($),!1)}z2.toBufferLE=j$;function w$(X,$){{let Q=X.toString(16);return Buffer.from(Q.padStart($*2,"0").slice(0,$*2),"hex")}return U1.fromBigInt(X,Buffer.allocUnsafe($),!0)}z2.toBufferBE=w$});function s0(){if(!S1){if(S1=typeof crypto!=="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!=="undefined"&&typeof msCrypto.getRandomValues==="function"&&msCrypto.getRandomValues.bind(msCrypto),!S1)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported")}return S1(g$)}var S1,g$;var R8=t(()=>{g$=new Uint8Array(16)});var N2;var j2=t(()=>{N2=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i});function h$(X){return typeof X==="string"&&N2.test(X)}var C0;var r0=t(()=>{j2();C0=h$});function x$(X){var $=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,Q=(l[X[$+0]]+l[X[$+1]]+l[X[$+2]]+l[X[$+3]]+"-"+l[X[$+4]]+l[X[$+5]]+"-"+l[X[$+6]]+l[X[$+7]]+"-"+l[X[$+8]]+l[X[$+9]]+"-"+l[X[$+10]]+l[X[$+11]]+l[X[$+12]]+l[X[$+13]]+l[X[$+14]]+l[X[$+15]]).toLowerCase();if(!C0(Q))throw TypeError("Stringified UUID is invalid");return Q}var l,k1,O0;var t0=t(()=>{r0();l=[];for(k1=0;k1<256;++k1)l.push((k1+256).toString(16).substr(1));O0=x$});function v$(X,$,Q){var Y=$&&Q||0,Z=$||new Array(16);X=X||{};var J=X.node||w2,M=X.clockseq!==void 0?X.clockseq:N8;if(J==null||M==null){var K=X.random||(X.rng||s0)();if(J==null)J=w2=[K[0]|1,K[1],K[2],K[3],K[4],K[5]];if(M==null)M=N8=(K[6]<<8|K[7])&16383}var H=X.msecs!==void 0?X.msecs:Date.now(),P=X.nsecs!==void 0?X.nsecs:w8+1,q=H-j8+(P-w8)/1e4;if(q<0&&X.clockseq===void 0)M=M+1&16383;if((q<0||H>j8)&&X.nsecs===void 0)P=0;if(P>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");j8=H,w8=P,N8=M,H+=12219292800000;var N=((H&268435455)*1e4+P)%4294967296;Z[Y++]=N>>>24&255,Z[Y++]=N>>>16&255,Z[Y++]=N>>>8&255,Z[Y++]=N&255;var z=H/4294967296*1e4&268435455;Z[Y++]=z>>>8&255,Z[Y++]=z&255,Z[Y++]=z>>>24&15|16,Z[Y++]=z>>>16&255,Z[Y++]=M>>>8|128,Z[Y++]=M&255;for(var C=0;C<6;++C)Z[Y+C]=J[C];return $||O0(Z)}var w2,N8,j8=0,w8=0,U2;var I2=t(()=>{R8();t0();U2=v$});function m$(X){if(!C0(X))throw TypeError("Invalid UUID");var $,Q=new Uint8Array(16);return Q[0]=($=parseInt(X.slice(0,8),16))>>>24,Q[1]=$>>>16&255,Q[2]=$>>>8&255,Q[3]=$&255,Q[4]=($=parseInt(X.slice(9,13),16))>>>8,Q[5]=$&255,Q[6]=($=parseInt(X.slice(14,18),16))>>>8,Q[7]=$&255,Q[8]=($=parseInt(X.slice(19,23),16))>>>8,Q[9]=$&255,Q[10]=($=parseInt(X.slice(24,36),16))/1099511627776&255,Q[11]=$/4294967296&255,Q[12]=$>>>24&255,Q[13]=$>>>16&255,Q[14]=$>>>8&255,Q[15]=$&255,Q}var T1;var U8=t(()=>{r0();T1=m$});function b$(X){X=unescape(encodeURIComponent(X));var $=[];for(var Q=0;Q<X.length;++Q)$.push(X.charCodeAt(Q));return $}function e0(X,$,Q){function Y(Z,J,M,K){if(typeof Z==="string")Z=b$(Z);if(typeof J==="string")J=T1(J);if(J.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var H=new Uint8Array(16+Z.length);if(H.set(J),H.set(Z,J.length),H=Q(H),H[6]=H[6]&15|$,H[8]=H[8]&63|128,M){K=K||0;for(var P=0;P<16;++P)M[K+P]=H[P];return M}return O0(H)}try{Y.name=X}catch(Z){}return Y.DNS=y$,Y.URL=d$,Y}var y$="6ba7b810-9dad-11d1-80b4-00c04fd430c8",d$="6ba7b811-9dad-11d1-80b4-00c04fd430c8";var I8=t(()=>{t0();U8()});function f$(X){if(typeof X==="string"){var $=unescape(encodeURIComponent(X));X=new Uint8Array($.length);for(var Q=0;Q<$.length;++Q)X[Q]=$.charCodeAt(Q)}return p$(c$(l$(X),X.length*8))}function p$(X){var $=[],Q=X.length*32,Y="0123456789abcdef";for(var Z=0;Z<Q;Z+=8){var J=X[Z>>5]>>>Z%32&255,M=parseInt(Y.charAt(J>>>4&15)+Y.charAt(J&15),16);$.push(M)}return $}function L2(X){return(X+64>>>9<<4)+14+1}function c$(X,$){X[$>>5]|=128<<$%32,X[L2($)-1]=$;var Q=1732584193,Y=-271733879,Z=-1732584194,J=271733878;for(var M=0;M<X.length;M+=16){var K=Q,H=Y,P=Z,q=J;Q=i(Q,Y,Z,J,X[M],7,-680876936),J=i(J,Q,Y,Z,X[M+1],12,-389564586),Z=i(Z,J,Q,Y,X[M+2],17,606105819),Y=i(Y,Z,J,Q,X[M+3],22,-1044525330),Q=i(Q,Y,Z,J,X[M+4],7,-176418897),J=i(J,Q,Y,Z,X[M+5],12,1200080426),Z=i(Z,J,Q,Y,X[M+6],17,-1473231341),Y=i(Y,Z,J,Q,X[M+7],22,-45705983),Q=i(Q,Y,Z,J,X[M+8],7,1770035416),J=i(J,Q,Y,Z,X[M+9],12,-1958414417),Z=i(Z,J,Q,Y,X[M+10],17,-42063),Y=i(Y,Z,J,Q,X[M+11],22,-1990404162),Q=i(Q,Y,Z,J,X[M+12],7,1804603682),J=i(J,Q,Y,Z,X[M+13],12,-40341101),Z=i(Z,J,Q,Y,X[M+14],17,-1502002290),Y=i(Y,Z,J,Q,X[M+15],22,1236535329),Q=o(Q,Y,Z,J,X[M+1],5,-165796510),J=o(J,Q,Y,Z,X[M+6],9,-1069501632),Z=o(Z,J,Q,Y,X[M+11],14,643717713),Y=o(Y,Z,J,Q,X[M],20,-373897302),Q=o(Q,Y,Z,J,X[M+5],5,-701558691),J=o(J,Q,Y,Z,X[M+10],9,38016083),Z=o(Z,J,Q,Y,X[M+15],14,-660478335),Y=o(Y,Z,J,Q,X[M+4],20,-405537848),Q=o(Q,Y,Z,J,X[M+9],5,568446438),J=o(J,Q,Y,Z,X[M+14],9,-1019803690),Z=o(Z,J,Q,Y,X[M+3],14,-187363961),Y=o(Y,Z,J,Q,X[M+8],20,1163531501),Q=o(Q,Y,Z,J,X[M+13],5,-1444681467),J=o(J,Q,Y,Z,X[M+2],9,-51403784),Z=o(Z,J,Q,Y,X[M+7],14,1735328473),Y=o(Y,Z,J,Q,X[M+12],20,-1926607734),Q=a(Q,Y,Z,J,X[M+5],4,-378558),J=a(J,Q,Y,Z,X[M+8],11,-2022574463),Z=a(Z,J,Q,Y,X[M+11],16,1839030562),Y=a(Y,Z,J,Q,X[M+14],23,-35309556),Q=a(Q,Y,Z,J,X[M+1],4,-1530992060),J=a(J,Q,Y,Z,X[M+4],11,1272893353),Z=a(Z,J,Q,Y,X[M+7],16,-155497632),Y=a(Y,Z,J,Q,X[M+10],23,-1094730640),Q=a(Q,Y,Z,J,X[M+13],4,681279174),J=a(J,Q,Y,Z,X[M],11,-358537222),Z=a(Z,J,Q,Y,X[M+3],16,-722521979),Y=a(Y,Z,J,Q,X[M+6],23,76029189),Q=a(Q,Y,Z,J,X[M+9],4,-640364487),J=a(J,Q,Y,Z,X[M+12],11,-421815835),Z=a(Z,J,Q,Y,X[M+15],16,530742520),Y=a(Y,Z,J,Q,X[M+2],23,-995338651),Q=s(Q,Y,Z,J,X[M],6,-198630844),J=s(J,Q,Y,Z,X[M+7],10,1126891415),Z=s(Z,J,Q,Y,X[M+14],15,-1416354905),Y=s(Y,Z,J,Q,X[M+5],21,-57434055),Q=s(Q,Y,Z,J,X[M+12],6,1700485571),J=s(J,Q,Y,Z,X[M+3],10,-1894986606),Z=s(Z,J,Q,Y,X[M+10],15,-1051523),Y=s(Y,Z,J,Q,X[M+1],21,-2054922799),Q=s(Q,Y,Z,J,X[M+8],6,1873313359),J=s(J,Q,Y,Z,X[M+15],10,-30611744),Z=s(Z,J,Q,Y,X[M+6],15,-1560198380),Y=s(Y,Z,J,Q,X[M+13],21,1309151649),Q=s(Q,Y,Z,J,X[M+4],6,-145523070),J=s(J,Q,Y,Z,X[M+11],10,-1120210379),Z=s(Z,J,Q,Y,X[M+2],15,718787259),Y=s(Y,Z,J,Q,X[M+9],21,-343485551),Q=R0(Q,K),Y=R0(Y,H),Z=R0(Z,P),J=R0(J,q)}return[Q,Y,Z,J]}function l$(X){if(X.length===0)return[];var $=X.length*8,Q=new Uint32Array(L2($));for(var Y=0;Y<$;Y+=8)Q[Y>>5]|=(X[Y/8]&255)<<Y%32;return Q}function R0(X,$){var Q=(X&65535)+($&65535),Y=(X>>16)+($>>16)+(Q>>16);return Y<<16|Q&65535}function u$(X,$){return X<<$|X>>>32-$}function B1(X,$,Q,Y,Z,J){return R0(u$(R0(R0($,X),R0(Y,J)),Z),Q)}function i(X,$,Q,Y,Z,J,M){return B1($&Q|~$&Y,X,$,Z,J,M)}function o(X,$,Q,Y,Z,J,M){return B1($&Y|Q&~Y,X,$,Z,J,M)}function a(X,$,Q,Y,Z,J,M){return B1($^Q^Y,X,$,Z,J,M)}function s(X,$,Q,Y,Z,J,M){return B1(Q^($|~Y),X,$,Z,J,M)}var E2;var S2=t(()=>{E2=f$});var n$,k2;var T2=t(()=>{I8();S2();n$=e0("v3",48,E2),k2=n$});function i$(X,$,Q){X=X||{};var Y=X.random||(X.rng||s0)();if(Y[6]=Y[6]&15|64,Y[8]=Y[8]&63|128,$){Q=Q||0;for(var Z=0;Z<16;++Z)$[Q+Z]=Y[Z];return $}return O0(Y)}var B2;var _2=t(()=>{R8();t0();B2=i$});function o$(X,$,Q,Y){switch(X){case 0:return $&Q^~$&Y;case 1:return $^Q^Y;case 2:return $&Q^$&Y^Q&Y;case 3:return $^Q^Y}}function L8(X,$){return X<<$|X>>>32-$}function a$(X){var $=[1518500249,1859775393,2400959708,3395469782],Q=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof X==="string"){var Y=unescape(encodeURIComponent(X));X=[];for(var Z=0;Z<Y.length;++Z)X.push(Y.charCodeAt(Z))}else if(!Array.isArray(X))X=Array.prototype.slice.call(X);X.push(128);var J=X.length/4+2,M=Math.ceil(J/16),K=new Array(M);for(var H=0;H<M;++H){var P=new Uint32Array(16);for(var q=0;q<16;++q)P[q]=X[H*64+q*4]<<24|X[H*64+q*4+1]<<16|X[H*64+q*4+2]<<8|X[H*64+q*4+3];K[H]=P}K[M-1][14]=(X.length-1)*8/Math.pow(2,32),K[M-1][14]=Math.floor(K[M-1][14]),K[M-1][15]=(X.length-1)*8&4294967295;for(var N=0;N<M;++N){var z=new Uint32Array(80);for(var C=0;C<16;++C)z[C]=K[N][C];for(var F=16;F<80;++F)z[F]=L8(z[F-3]^z[F-8]^z[F-14]^z[F-16],1);var j=Q[0],E=Q[1],p=Q[2],V0=Q[3],I0=Q[4];for(var V1=0;V1<80;++V1){var X2=Math.floor(V1/20),v4=L8(j,5)+o$(X2,E,p,V0)+I0+$[X2]+z[V1]>>>0;I0=V0,V0=p,p=L8(E,30)>>>0,E=j,j=v4}Q[0]=Q[0]+j>>>0,Q[1]=Q[1]+E>>>0,Q[2]=Q[2]+p>>>0,Q[3]=Q[3]+V0>>>0,Q[4]=Q[4]+I0>>>0}return[Q[0]>>24&255,Q[0]>>16&255,Q[0]>>8&255,Q[0]&255,Q[1]>>24&255,Q[1]>>16&255,Q[1]>>8&255,Q[1]&255,Q[2]>>24&255,Q[2]>>16&255,Q[2]>>8&255,Q[2]&255,Q[3]>>24&255,Q[3]>>16&255,Q[3]>>8&255,Q[3]&255,Q[4]>>24&255,Q[4]>>16&255,Q[4]>>8&255,Q[4]&255]}var g2;var h2=t(()=>{g2=a$});var s$,x2;var v2=t(()=>{I8();h2();s$=e0("v5",80,g2),x2=s$});var m2="00000000-0000-0000-0000-000000000000";function t$(X){if(!C0(X))throw TypeError("Invalid UUID");return parseInt(X.substr(14,1),16)}var b2;var y2=t(()=>{r0();b2=t$});var E8={};$2(E8,{version:()=>b2,validate:()=>C0,v5:()=>x2,v4:()=>B2,v3:()=>k2,v1:()=>U2,stringify:()=>O0,parse:()=>T1,NIL:()=>m2});var S8=t(()=>{I2();T2();_2();v2();y2();r0();t0();U8()});var f2=n0((yZ,d2)=>{var e$=(S8(),A1(E8)).v4,XQ=function(X,$,Q,Y){if(typeof X!=="string")throw new TypeError(X+" must be a string");Y=Y||{};let Z=typeof Y.version==="number"?Y.version:2;if(Z!==1&&Z!==2)throw new TypeError(Z+" must be 1 or 2");let J={method:X};if(Z===2)J.jsonrpc="2.0";if($){if(typeof $!=="object"&&!Array.isArray($))throw new TypeError($+" must be an object, array or omitted");J.params=$}if(typeof Q==="undefined"){let M=typeof Y.generator==="function"?Y.generator:function(){return e$()};J.id=M(J,Y)}else if(Z===2&&Q===null){if(Y.notificationIdNull)J.id=null}else J.id=Q;return J};d2.exports=XQ});var c2=n0((dZ,p2)=>{var $Q=(S8(),A1(E8)).v4,QQ=f2(),X1=function(X,$){if(!(this instanceof X1))return new X1(X,$);if(!$)$={};this.options={reviver:typeof $.reviver!=="undefined"?$.reviver:null,replacer:typeof $.replacer!=="undefined"?$.replacer:null,generator:typeof $.generator!=="undefined"?$.generator:function(){return $Q()},version:typeof $.version!=="undefined"?$.version:2,notificationIdNull:typeof $.notificationIdNull==="boolean"?$.notificationIdNull:!1},this.callServer=X};p2.exports=X1;X1.prototype.request=function(X,$,Q,Y){let Z=this,J=null,M=Array.isArray(X)&&typeof $==="function";if(this.options.version===1&&M)throw new TypeError("JSON-RPC 1.0 does not support batching");if(M||!M&&X&&typeof X==="object"&&typeof $==="function")Y=$,J=X;else{if(typeof Q==="function")Y=Q,Q=void 0;let P=typeof Y==="function";try{J=QQ(X,$,Q,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(q){if(P)return Y(q);throw q}if(!P)return J}let H;try{H=JSON.stringify(J,this.options.replacer)}catch(P){return Y(P)}return this.callServer(H,function(P,q){Z._parseResponse(P,q,Y)}),J};X1.prototype._parseResponse=function(X,$,Q){if(X){Q(X);return}if(!$)return Q();let Y;try{Y=JSON.parse($,this.options.reviver)}catch(Z){return Q(Z)}if(Q.length===3)if(Array.isArray(Y)){let Z=function(M){return typeof M.error!=="undefined"},J=function(M){return!Z(M)};return Q(null,Y.filter(Z),Y.filter(J))}else return Q(null,Y.error,Y.result);Q(null,Y)}});r1();var d8=g0(Z2(),1),c=g0(J2(),1);var l0=g0(V2(),1),G=g0(D8(),1),V4=g0(D8(),1),H1=g0(F2(),1);class D2 extends TypeError{constructor(X,$){let Q,{message:Y,explanation:Z,...J}=X,{path:M}=X,K=M.length===0?Y:`At path: ${M.join(".")} -- ${Y}`;super(Z??K);if(Z!=null)this.cause=K;Object.assign(this,J),this.name=this.constructor.name,this.failures=()=>{return Q??(Q=[X,...$()])}}}function S$(X){return o0(X)&&typeof X[Symbol.iterator]==="function"}function o0(X){return typeof X==="object"&&X!=null}function I1(X){return o0(X)&&!Array.isArray(X)}function K0(X){if(typeof X==="symbol")return X.toString();return typeof X==="string"?JSON.stringify(X):`${X}`}function k$(X){let{done:$,value:Q}=X.next();return $?void 0:Q}function T$(X,$,Q,Y){if(X===!0)return;else if(X===!1)X={};else if(typeof X==="string")X={message:X};let{path:Z,branch:J}=$,{type:M}=Q,{refinement:K,message:H=`Expected a value of type \`${M}\`${K?` with refinement \`${K}\``:""}, but received: \`${K0(Y)}\``}=X;return{value:Y,type:M,refinement:K,key:Z[Z.length-1],path:Z,branch:J,...X,message:H}}function*A2(X,$,Q,Y){if(!S$(X))X=[X];for(let Z of X){let J=T$(Z,$,Q,Y);if(J)yield J}}function*C8(X,$,Q={}){let{path:Y=[],branch:Z=[X],coerce:J=!1,mask:M=!1}=Q,K={path:Y,branch:Z,mask:M};if(J)X=$.coercer(X,K);let H="valid";for(let P of $.validator(X,K))P.explanation=Q.message,H="not_valid",yield[P,void 0];for(let[P,q,N]of $.entries(X,K)){let z=C8(q,N,{path:P===void 0?Y:[...Y,P],branch:P===void 0?Z:[...Z,q],coerce:J,mask:M,message:Q.message});for(let C of z)if(C[0])H=C[0].refinement!=null?"not_refined":"not_valid",yield[C[0],void 0];else if(J){if(q=C[1],P===void 0)X=q;else if(X instanceof Map)X.set(P,q);else if(X instanceof Set)X.add(q);else if(o0(X)){if(q!==void 0||P in X)X[P]=q}}}if(H!=="not_valid")for(let P of $.refiner(X,K))P.explanation=Q.message,H="not_refined",yield[P,void 0];if(H==="valid")yield[void 0,X]}class G0{constructor(X){let{type:$,schema:Q,validator:Y,refiner:Z,coercer:J=(K)=>K,entries:M=function*(){}}=X;if(this.type=$,this.schema=Q,this.entries=M,this.coercer=J,Y)this.validator=(K,H)=>{let P=Y(K,H);return A2(P,H,this,K)};else this.validator=()=>[];if(Z)this.refiner=(K,H)=>{let P=Z(K,H);return A2(P,H,this,K)};else this.refiner=()=>[]}assert(X,$){return C2(X,this,$)}create(X,$){return D(X,this,$)}is(X){return O2(X,this)}mask(X,$){return B$(X,this,$)}validate(X,$={}){return a0(X,this,$)}}function C2(X,$,Q){let Y=a0(X,$,{message:Q});if(Y[0])throw Y[0]}function D(X,$,Q){let Y=a0(X,$,{coerce:!0,message:Q});if(Y[0])throw Y[0];else return Y[1]}function B$(X,$,Q){let Y=a0(X,$,{coerce:!0,mask:!0,message:Q});if(Y[0])throw Y[0];else return Y[1]}function O2(X,$){return!a0(X,$)[0]}function a0(X,$,Q={}){let Y=C8(X,$,Q),Z=k$(Y);if(Z[0])return[new D2(Z[0],function*(){for(let M of Y)if(M[0])yield M[0]}),void 0];else return[void 0,Z[1]]}function k0(X,$){return new G0({type:X,schema:null,validator:$})}function R2(){return k0("any",()=>!0)}function O(X){return new G0({type:"array",schema:X,*entries($){if(X&&Array.isArray($))for(let[Q,Y]of $.entries())yield[Q,Y,X]},coercer($){return Array.isArray($)?$.slice():$},validator($){return Array.isArray($)||`Expected an array value, but received: ${K0($)}`}})}function H0(){return k0("boolean",(X)=>{return typeof X==="boolean"})}function L1(X){return k0("instance",($)=>{return $ instanceof X||`Expected a \`${X.name}\` instance, but received: ${K0($)}`})}function y(X){let $=K0(X),Q=typeof X;return new G0({type:"literal",schema:Q==="string"||Q==="number"||Q==="boolean"?X:null,validator(Y){return Y===X||`Expected the literal \`${$}\`, but received: ${K0(Y)}`}})}function _$(){return k0("never",()=>!1)}function R(X){return new G0({...X,validator:($,Q)=>$===null||X.validator($,Q),refiner:($,Q)=>$===null||X.refiner($,Q)})}function V(){return k0("number",(X)=>{return typeof X==="number"&&!isNaN(X)||`Expected a number, but received: ${K0(X)}`})}function U(X){return new G0({...X,validator:($,Q)=>$===void 0||X.validator($,Q),refiner:($,Q)=>$===void 0||X.refiner($,Q)})}function O8(X,$){return new G0({type:"record",schema:null,*entries(Q){if(o0(Q))for(let Y in Q){let Z=Q[Y];yield[Y,Y,X],yield[Y,Z,$]}},validator(Q){return I1(Q)||`Expected an object, but received: ${K0(Q)}`},coercer(Q){return I1(Q)?{...Q}:Q}})}function A(){return k0("string",(X)=>{return typeof X==="string"||`Expected a string, but received: ${K0(X)}`})}function E1(X){let $=_$();return new G0({type:"tuple",schema:null,*entries(Q){if(Array.isArray(Q)){let Y=Math.max(X.length,Q.length);for(let Z=0;Z<Y;Z++)yield[Z,Q[Z],X[Z]||$]}},validator(Q){return Array.isArray(Q)||`Expected an array, but received: ${K0(Q)}`},coercer(Q){return Array.isArray(Q)?Q.slice():Q}})}function W(X){let $=Object.keys(X);return new G0({type:"type",schema:X,*entries(Q){if(o0(Q))for(let Y of $)yield[Y,Q[Y],X[Y]]},validator(Q){return I1(Q)||`Expected an object, but received: ${K0(Q)}`},coercer(Q){return I1(Q)?{...Q}:Q}})}function n(X){let $=X.map((Q)=>Q.type).join(" | ");return new G0({type:"union",schema:null,coercer(Q,Y){for(let Z of X){let[J,M]=Z.validate(Q,{coerce:!0,mask:Y.mask});if(!J)return M}return Q},validator(Q,Y){let Z=[];for(let J of X){let[...M]=C8(Q,J,Y),[K]=M;if(!K[0])return[];else for(let[H]of M)if(H)Z.push(H)}return[`Expected the value to satisfy a union of \`${$}\`, but received: ${K0(Q)}`,...Z]}})}function T0(){return k0("unknown",()=>!0)}function d0(X,$,Q){return new G0({...X,coercer:(Y,Z)=>{return O2(Y,$)?X.coercer(Q(Y,Z),Z):X.coercer(Y,Z)}})}var P4=g0(c2(),1);r1();var YQ=class extends k8.default{socket;constructor(X,$,Q){super();this.socket=new window.WebSocket(X,Q),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=(Y)=>this.emit("message",Y.data),this.socket.onerror=(Y)=>this.emit("error",Y),this.socket.onclose=(Y)=>{this.emit("close",Y.code,Y.reason)}}send(X,$,Q){let Y=Q||$;try{this.socket.send(X),Y()}catch(Z){Y(Z)}}close(X,$){this.socket.close(X,$)}addEventListener(X,$,Q){this.socket.addEventListener(X,$,Q)}};function l2(X,$){return new YQ(X,$)}var ZQ=class{encode(X){return JSON.stringify(X)}decode(X){return JSON.parse(X)}},u2=class extends k8.default{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(X,$="ws://localhost:8080",{autoconnect:Q=!0,reconnect:Y=!0,reconnect_interval:Z=1000,max_reconnects:J=5,...M}={},K,H){super();if(this.webSocketFactory=X,this.queue={},this.rpc_id=0,this.address=$,this.autoconnect=Q,this.ready=!1,this.reconnect=Y,this.reconnect_timer_id=void 0,this.reconnect_interval=Z,this.max_reconnects=J,this.rest_options=M,this.current_reconnects=0,this.generate_request_id=K||(()=>++this.rpc_id),!H)this.dataPack=new ZQ;else this.dataPack=H;if(this.autoconnect)this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){if(this.socket)return;this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(X,$,Q,Y){if(!Y&&typeof Q==="object")Y=Q,Q=null;return new Promise((Z,J)=>{if(!this.ready)return J(new Error("socket not ready"));let M=this.generate_request_id(X,$),K={jsonrpc:"2.0",method:X,params:$||void 0,id:M};this.socket.send(this.dataPack.encode(K),Y,(H)=>{if(H)return J(H);if(this.queue[M]={promise:[Z,J]},Q)this.queue[M].timeout=setTimeout(()=>{delete this.queue[M],J(new Error("reply timeout"))},Q)})})}async login(X){let $=await this.call("rpc.login",X);if(!$)throw new Error("authentication failed");return $}async listMethods(){return await this.call("__listMethods")}notify(X,$){return new Promise((Q,Y)=>{if(!this.ready)return Y(new Error("socket not ready"));let Z={jsonrpc:"2.0",method:X,params:$};this.socket.send(this.dataPack.encode(Z),(J)=>{if(J)return Y(J);Q()})})}async subscribe(X){if(typeof X==="string")X=[X];let $=await this.call("rpc.on",X);if(typeof X==="string"&&$[X]!=="ok")throw new Error("Failed subscribing to an event '"+X+"' with: "+$[X]);return $}async unsubscribe(X){if(typeof X==="string")X=[X];let $=await this.call("rpc.off",X);if(typeof X==="string"&&$[X]!=="ok")throw new Error("Failed unsubscribing from an event with: "+$);return $}close(X,$){this.socket.close(X||1000,$)}setAutoReconnect(X){this.reconnect=X}setReconnectInterval(X){this.reconnect_interval=X}setMaxReconnects(X){this.max_reconnects=X}_connect(X,$){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(X,$),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:Q})=>{if(Q instanceof ArrayBuffer)Q=I.from(Q).toString();try{Q=this.dataPack.decode(Q)}catch(Y){return}if(Q.notification&&this.listeners(Q.notification).length){if(!Object.keys(Q.params).length)return this.emit(Q.notification);let Y=[Q.notification];if(Q.params.constructor===Object)Y.push(Q.params);else for(let Z=0;Z<Q.params.length;Z++)Y.push(Q.params[Z]);return Promise.resolve().then(()=>{this.emit.apply(this,Y)})}if(!this.queue[Q.id]){if(Q.method)return Promise.resolve().then(()=>{this.emit(Q.method,Q?.params)});return}if("error"in Q==="result"in Q)this.queue[Q.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));if(this.queue[Q.id].timeout)clearTimeout(this.queue[Q.id].timeout);if(Q.error)this.queue[Q.id].promise[1](Q.error);else this.queue[Q.id].promise[0](Q.result);delete this.queue[Q.id]}),this.socket.addEventListener("error",(Q)=>this.emit("error",Q)),this.socket.addEventListener("close",({code:Q,reason:Y})=>{if(this.ready)setTimeout(()=>this.emit("close",Q,Y),0);if(this.ready=!1,this.socket=void 0,Q===1000)return;if(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0))this.reconnect_timer_id=setTimeout(()=>this._connect(X,$),this.reconnect_interval)})}};var XJ=h0.utils.randomPrivateKey,n2=()=>{let X=h0.utils.randomPrivateKey(),$=f8(X),Q=new Uint8Array(64);return Q.set(X),Q.set($,32),{publicKey:$,secretKey:Q}},f8=h0.getPublicKey;function i2(X){try{return h0.ExtendedPoint.fromHex(X),!0}catch{return!1}}var W4=(X,$)=>h0.sign(X,$.slice(0,32)),JQ=h0.verify,T=(X)=>{if(I.isBuffer(X))return X;else if(X instanceof Uint8Array)return I.from(X.buffer,X.byteOffset,X.byteLength);else return I.from(X)};class q4{constructor(X){Object.assign(this,X)}encode(){return I.from(l0.serialize(h1,this))}static decode(X){return l0.deserialize(h1,this,X)}static decodeUnchecked(X){return l0.deserializeUnchecked(h1,this,X)}}var h1=new Map,z4,MQ=32,w0=32;function KQ(X){return X._bn!==void 0}var o2=1;class L extends q4{constructor(X){super({});if(this._bn=void 0,KQ(X))this._bn=X._bn;else{if(typeof X==="string"){let $=c.default.decode(X);if($.length!=w0)throw new Error("Invalid public key input");this._bn=new d8.default($)}else this._bn=new d8.default(X);if(this._bn.byteLength()>w0)throw new Error("Invalid public key input")}}static unique(){let X=new L(o2);return o2+=1,new L(X.toBuffer())}equals(X){return this._bn.eq(X._bn)}toBase58(){return c.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let X=this.toBuffer();return new Uint8Array(X.buffer,X.byteOffset,X.byteLength)}toBuffer(){let X=this._bn.toArrayLike(I);if(X.length===w0)return X;let $=I.alloc(32);return X.copy($,32-X.length),$}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(X,$,Q){let Y=I.concat([X.toBuffer(),I.from($),Q.toBuffer()]),Z=b8(Y);return new L(Z)}static createProgramAddressSync(X,$){let Q=I.alloc(0);X.forEach(function(Z){if(Z.length>MQ)throw new TypeError("Max seed length exceeded");Q=I.concat([Q,T(Z)])}),Q=I.concat([Q,$.toBuffer(),I.from("ProgramDerivedAddress")]);let Y=b8(Q);if(i2(Y))throw new Error("Invalid seeds, address must fall off the curve");return new L(Y)}static async createProgramAddress(X,$){return this.createProgramAddressSync(X,$)}static findProgramAddressSync(X,$){let Q=255,Y;while(Q!=0){try{let Z=X.concat(I.from([Q]));Y=this.createProgramAddressSync(Z,$)}catch(Z){if(Z instanceof TypeError)throw Z;Q--;continue}return[Y,Q]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(X,$){return this.findProgramAddressSync(X,$)}static isOnCurve(X){let $=new L(X);return i2($.toBytes())}}z4=L;L.default=new z4("11111111111111111111111111111111");h1.set(L,{kind:"struct",fields:[["_bn","u256"]]});var $J=new L("BPFLoader1111111111111111111111111111111111"),_0=1232,F4=127,A4=64;class n8 extends Error{constructor(X){super(`Signature ${X} has expired: block height exceeded.`);this.signature=void 0,this.signature=X}}Object.defineProperty(n8.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class i8 extends Error{constructor(X,$){super(`Transaction was not confirmed in ${$.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${X} using the Solana Explorer or CLI tools.`);this.signature=void 0,this.signature=X}}Object.defineProperty(i8.prototype,"name",{value:"TransactionExpiredTimeoutError"});class f0 extends Error{constructor(X){super(`Signature ${X} has expired: the nonce is no longer valid.`);this.signature=void 0,this.signature=X}}Object.defineProperty(f0.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class M1{constructor(X,$){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=X,this.accountKeysFromLookups=$}keySegments(){let X=[this.staticAccountKeys];if(this.accountKeysFromLookups)X.push(this.accountKeysFromLookups.writable),X.push(this.accountKeysFromLookups.readonly);return X}get(X){for(let $ of this.keySegments())if(X<$.length)return $[X];else X-=$.length;return}get length(){return this.keySegments().flat().length}compileInstructions(X){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let Q=new Map;this.keySegments().flat().forEach((Z,J)=>{Q.set(Z.toBase58(),J)});let Y=(Z)=>{let J=Q.get(Z.toBase58());if(J===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return J};return X.map((Z)=>{return{programIdIndex:Y(Z.programId),accountKeyIndexes:Z.keys.map((J)=>Y(J.pubkey)),data:Z.data}})}}var k=(X="publicKey")=>{return G.blob(32,X)};var p0=(X="string")=>{let $=G.struct([G.u32("length"),G.u32("lengthPadding"),G.blob(G.offset(G.u32(),-8),"chars")],X),Q=$.decode.bind($),Y=$.encode.bind($),Z=$;return Z.decode=(J,M)=>{return Q(J,M).chars.toString()},Z.encode=(J,M,K)=>{let H={chars:I.from(J,"utf8")};return Y(H,M,K)},Z.alloc=(J)=>{return G.u32().span+G.u32().span+I.from(J,"utf8").length},Z},GQ=(X="authorized")=>{return G.struct([k("staker"),k("withdrawer")],X)},HQ=(X="lockup")=>{return G.struct([G.ns64("unixTimestamp"),G.ns64("epoch"),k("custodian")],X)},VQ=(X="voteInit")=>{return G.struct([k("nodePubkey"),k("authorizedVoter"),k("authorizedWithdrawer"),G.u8("commission")],X)},PQ=(X="voteAuthorizeWithSeedArgs")=>{return G.struct([G.u32("voteAuthorizationType"),k("currentAuthorityDerivedKeyOwnerPubkey"),p0("currentAuthorityDerivedKeySeed"),k("newAuthorized")],X)};function D4(X,$){let Q=(Z)=>{if(Z.span>=0)return Z.span;else if(typeof Z.alloc==="function")return Z.alloc($[Z.property]);else if("count"in Z&&"elementLayout"in Z){let J=$[Z.property];if(Array.isArray(J))return J.length*Q(Z.elementLayout)}else if("fields"in Z)return D4({layout:Z},$[Z.property]);return 0},Y=0;return X.layout.fields.forEach((Z)=>{Y+=Q(Z)}),Y}function Z0(X){let $=0,Q=0;for(;;){let Y=X.shift();if($|=(Y&127)<<Q*7,Q+=1,(Y&128)===0)break}return $}function J0(X,$){let Q=$;for(;;){let Y=Q&127;if(Q>>=7,Q==0){X.push(Y);break}else Y|=128,X.push(Y)}}function m(X,$){if(!X)throw new Error($||"Assertion failed")}class d1{constructor(X,$){this.payer=void 0,this.keyMetaMap=void 0,this.payer=X,this.keyMetaMap=$}static compile(X,$){let Q=new Map,Y=(J)=>{let M=J.toBase58(),K=Q.get(M);if(K===void 0)K={isSigner:!1,isWritable:!1,isInvoked:!1},Q.set(M,K);return K},Z=Y($);Z.isSigner=!0,Z.isWritable=!0;for(let J of X){Y(J.programId).isInvoked=!0;for(let M of J.keys){let K=Y(M.pubkey);K.isSigner||=M.isSigner,K.isWritable||=M.isWritable}}return new d1($,Q)}getMessageComponents(){let X=[...this.keyMetaMap.entries()];m(X.length<=256,"Max static account keys length exceeded");let $=X.filter(([,K])=>K.isSigner&&K.isWritable),Q=X.filter(([,K])=>K.isSigner&&!K.isWritable),Y=X.filter(([,K])=>!K.isSigner&&K.isWritable),Z=X.filter(([,K])=>!K.isSigner&&!K.isWritable),J={numRequiredSignatures:$.length+Q.length,numReadonlySignedAccounts:Q.length,numReadonlyUnsignedAccounts:Z.length};{m($.length>0,"Expected at least one writable signer key");let[K]=$[0];m(K===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let M=[...$.map(([K])=>new L(K)),...Q.map(([K])=>new L(K)),...Y.map(([K])=>new L(K)),...Z.map(([K])=>new L(K))];return[J,M]}extractTableLookup(X){let[$,Q]=this.drainKeysFoundInLookupTable(X.state.addresses,(J)=>!J.isSigner&&!J.isInvoked&&J.isWritable),[Y,Z]=this.drainKeysFoundInLookupTable(X.state.addresses,(J)=>!J.isSigner&&!J.isInvoked&&!J.isWritable);if($.length===0&&Y.length===0)return;return[{accountKey:X.key,writableIndexes:$,readonlyIndexes:Y},{writable:Q,readonly:Z}]}drainKeysFoundInLookupTable(X,$){let Q=new Array,Y=new Array;for(let[Z,J]of this.keyMetaMap.entries())if($(J)){let M=new L(Z),K=X.findIndex((H)=>H.equals(M));if(K>=0)m(K<256,"Max lookup table index exceeded"),Q.push(K),Y.push(M),this.keyMetaMap.delete(Z)}return[Q,Y]}}var C4="Reached end of buffer unexpectedly";function F0(X){if(X.length===0)throw new Error(C4);return X.shift()}function M0(X,...$){let[Q]=$;if($.length===2?Q+($[1]??0)>X.length:Q>=X.length)throw new Error(C4);return X.splice(...$)}class U0{constructor(X){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=X.header,this.accountKeys=X.accountKeys.map(($)=>new L($)),this.recentBlockhash=X.recentBlockhash,this.instructions=X.instructions,this.instructions.forEach(($)=>this.indexToProgramIds.set($.programIdIndex,this.accountKeys[$.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((X)=>({programIdIndex:X.programIdIndex,accountKeyIndexes:X.accounts,data:c.default.decode(X.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new M1(this.staticAccountKeys)}static compile(X){let $=d1.compile(X.instructions,X.payerKey),[Q,Y]=$.getMessageComponents(),J=new M1(Y).compileInstructions(X.instructions).map((M)=>({programIdIndex:M.programIdIndex,accounts:M.accountKeyIndexes,data:c.default.encode(M.data)}));return new U0({header:Q,accountKeys:Y,recentBlockhash:X.recentBlockhash,instructions:J})}isAccountSigner(X){return X<this.header.numRequiredSignatures}isAccountWritable(X){let $=this.header.numRequiredSignatures;if(X>=this.header.numRequiredSignatures){let Q=X-$,Z=this.accountKeys.length-$-this.header.numReadonlyUnsignedAccounts;return Q<Z}else{let Q=$-this.header.numReadonlySignedAccounts;return X<Q}}isProgramId(X){return this.indexToProgramIds.has(X)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((X,$)=>!this.isProgramId($))}serialize(){let X=this.accountKeys.length,$=[];J0($,X);let Q=this.instructions.map((q)=>{let{accounts:N,programIdIndex:z}=q,C=Array.from(c.default.decode(q.data)),F=[];J0(F,N.length);let j=[];return J0(j,C.length),{programIdIndex:z,keyIndicesCount:I.from(F),keyIndices:N,dataLength:I.from(j),data:C}}),Y=[];J0(Y,Q.length);let Z=I.alloc(_0);I.from(Y).copy(Z);let J=Y.length;Q.forEach((q)=>{let z=G.struct([G.u8("programIdIndex"),G.blob(q.keyIndicesCount.length,"keyIndicesCount"),G.seq(G.u8("keyIndex"),q.keyIndices.length,"keyIndices"),G.blob(q.dataLength.length,"dataLength"),G.seq(G.u8("userdatum"),q.data.length,"data")]).encode(q,Z,J);J+=z}),Z=Z.slice(0,J);let M=G.struct([G.blob(1,"numRequiredSignatures"),G.blob(1,"numReadonlySignedAccounts"),G.blob(1,"numReadonlyUnsignedAccounts"),G.blob($.length,"keyCount"),G.seq(k("key"),X,"keys"),k("recentBlockhash")]),K={numRequiredSignatures:I.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:I.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:I.from([this.header.numReadonlyUnsignedAccounts]),keyCount:I.from($),keys:this.accountKeys.map((q)=>T(q.toBytes())),recentBlockhash:c.default.decode(this.recentBlockhash)},H=I.alloc(2048),P=M.encode(K,H);return Z.copy(H,P),H.slice(0,P+Z.length)}static from(X){let $=[...X],Q=F0($);if(Q!==(Q&F4))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let Y=F0($),Z=F0($),J=Z0($),M=[];for(let N=0;N<J;N++){let z=M0($,0,w0);M.push(new L(I.from(z)))}let K=M0($,0,w0),H=Z0($),P=[];for(let N=0;N<H;N++){let z=F0($),C=Z0($),F=M0($,0,C),j=Z0($),E=M0($,0,j),p=c.default.encode(I.from(E));P.push({programIdIndex:z,accounts:F,data:p})}let q={header:{numRequiredSignatures:Q,numReadonlySignedAccounts:Y,numReadonlyUnsignedAccounts:Z},recentBlockhash:c.default.encode(I.from(K)),accountKeys:M,instructions:P};return new U0(q)}}class x1{constructor(X){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=X.header,this.staticAccountKeys=X.staticAccountKeys,this.recentBlockhash=X.recentBlockhash,this.compiledInstructions=X.compiledInstructions,this.addressTableLookups=X.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let X=0;for(let $ of this.addressTableLookups)X+=$.readonlyIndexes.length+$.writableIndexes.length;return X}getAccountKeys(X){let $;if(X&&"accountKeysFromLookups"in X&&X.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=X.accountKeysFromLookups.writable.length+X.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");$=X.accountKeysFromLookups}else if(X&&"addressLookupTableAccounts"in X&&X.addressLookupTableAccounts)$=this.resolveAddressTableLookups(X.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new M1(this.staticAccountKeys,$)}isAccountSigner(X){return X<this.header.numRequiredSignatures}isAccountWritable(X){let $=this.header.numRequiredSignatures,Q=this.staticAccountKeys.length;if(X>=Q){let Y=X-Q,Z=this.addressTableLookups.reduce((J,M)=>J+M.writableIndexes.length,0);return Y<Z}else if(X>=this.header.numRequiredSignatures){let Y=X-$,J=Q-$-this.header.numReadonlyUnsignedAccounts;return Y<J}else{let Y=$-this.header.numReadonlySignedAccounts;return X<Y}}resolveAddressTableLookups(X){let $={writable:[],readonly:[]};for(let Q of this.addressTableLookups){let Y=X.find((Z)=>Z.key.equals(Q.accountKey));if(!Y)throw new Error(`Failed to find address lookup table account for table key ${Q.accountKey.toBase58()}`);for(let Z of Q.writableIndexes)if(Z<Y.state.addresses.length)$.writable.push(Y.state.addresses[Z]);else throw new Error(`Failed to find address for index ${Z} in address lookup table ${Q.accountKey.toBase58()}`);for(let Z of Q.readonlyIndexes)if(Z<Y.state.addresses.length)$.readonly.push(Y.state.addresses[Z]);else throw new Error(`Failed to find address for index ${Z} in address lookup table ${Q.accountKey.toBase58()}`)}return $}static compile(X){let $=d1.compile(X.instructions,X.payerKey),Q=new Array,Y={writable:new Array,readonly:new Array},Z=X.addressLookupTableAccounts||[];for(let P of Z){let q=$.extractTableLookup(P);if(q!==void 0){let[N,{writable:z,readonly:C}]=q;Q.push(N),Y.writable.push(...z),Y.readonly.push(...C)}}let[J,M]=$.getMessageComponents(),H=new M1(M,Y).compileInstructions(X.instructions);return new x1({header:J,staticAccountKeys:M,recentBlockhash:X.recentBlockhash,compiledInstructions:H,addressTableLookups:Q})}serialize(){let X=Array();J0(X,this.staticAccountKeys.length);let $=this.serializeInstructions(),Q=Array();J0(Q,this.compiledInstructions.length);let Y=this.serializeAddressTableLookups(),Z=Array();J0(Z,this.addressTableLookups.length);let J=G.struct([G.u8("prefix"),G.struct([G.u8("numRequiredSignatures"),G.u8("numReadonlySignedAccounts"),G.u8("numReadonlyUnsignedAccounts")],"header"),G.blob(X.length,"staticAccountKeysLength"),G.seq(k(),this.staticAccountKeys.length,"staticAccountKeys"),k("recentBlockhash"),G.blob(Q.length,"instructionsLength"),G.blob($.length,"serializedInstructions"),G.blob(Z.length,"addressTableLookupsLength"),G.blob(Y.length,"serializedAddressTableLookups")]),M=new Uint8Array(_0),K=128,H=J.encode({prefix:K,header:this.header,staticAccountKeysLength:new Uint8Array(X),staticAccountKeys:this.staticAccountKeys.map((P)=>P.toBytes()),recentBlockhash:c.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(Q),serializedInstructions:$,addressTableLookupsLength:new Uint8Array(Z),serializedAddressTableLookups:Y},M);return M.slice(0,H)}serializeInstructions(){let X=0,$=new Uint8Array(_0);for(let Q of this.compiledInstructions){let Y=Array();J0(Y,Q.accountKeyIndexes.length);let Z=Array();J0(Z,Q.data.length);let J=G.struct([G.u8("programIdIndex"),G.blob(Y.length,"encodedAccountKeyIndexesLength"),G.seq(G.u8(),Q.accountKeyIndexes.length,"accountKeyIndexes"),G.blob(Z.length,"encodedDataLength"),G.blob(Q.data.length,"data")]);X+=J.encode({programIdIndex:Q.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(Y),accountKeyIndexes:Q.accountKeyIndexes,encodedDataLength:new Uint8Array(Z),data:Q.data},$,X)}return $.slice(0,X)}serializeAddressTableLookups(){let X=0,$=new Uint8Array(_0);for(let Q of this.addressTableLookups){let Y=Array();J0(Y,Q.writableIndexes.length);let Z=Array();J0(Z,Q.readonlyIndexes.length);let J=G.struct([k("accountKey"),G.blob(Y.length,"encodedWritableIndexesLength"),G.seq(G.u8(),Q.writableIndexes.length,"writableIndexes"),G.blob(Z.length,"encodedReadonlyIndexesLength"),G.seq(G.u8(),Q.readonlyIndexes.length,"readonlyIndexes")]);X+=J.encode({accountKey:Q.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(Y),writableIndexes:Q.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(Z),readonlyIndexes:Q.readonlyIndexes},$,X)}return $.slice(0,X)}static deserialize(X){let $=[...X],Q=F0($),Y=Q&F4;m(Q!==Y,"Expected versioned message but received legacy message");let Z=Y;m(Z===0,`Expected versioned message with version 0 but found version ${Z}`);let J={numRequiredSignatures:F0($),numReadonlySignedAccounts:F0($),numReadonlyUnsignedAccounts:F0($)},M=[],K=Z0($);for(let C=0;C<K;C++)M.push(new L(M0($,0,w0)));let H=c.default.encode(M0($,0,w0)),P=Z0($),q=[];for(let C=0;C<P;C++){let F=F0($),j=Z0($),E=M0($,0,j),p=Z0($),V0=new Uint8Array(M0($,0,p));q.push({programIdIndex:F,accountKeyIndexes:E,data:V0})}let N=Z0($),z=[];for(let C=0;C<N;C++){let F=new L(M0($,0,w0)),j=Z0($),E=M0($,0,j),p=Z0($),V0=M0($,0,p);z.push({accountKey:F,writableIndexes:E,readonlyIndexes:V0})}return new x1({header:J,staticAccountKeys:M,recentBlockhash:H,compiledInstructions:q,addressTableLookups:z})}}var N0=function(X){return X[X.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",X[X.PROCESSED=1]="PROCESSED",X[X.TIMED_OUT=2]="TIMED_OUT",X[X.NONCE_INVALID=3]="NONCE_INVALID",X}({}),WQ=I.alloc(A4).fill(0);class b{constructor(X){if(this.keys=void 0,this.programId=void 0,this.data=I.alloc(0),this.programId=X.programId,this.keys=X.keys,X.data)this.data=X.data}toJSON(){return{keys:this.keys.map(({pubkey:X,isSigner:$,isWritable:Q})=>({pubkey:X.toJSON(),isSigner:$,isWritable:Q})),programId:this.programId.toJSON(),data:[...this.data]}}}class h{get signature(){if(this.signatures.length>0)return this.signatures[0].signature;return null}constructor(X){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!X)return;if(X.feePayer)this.feePayer=X.feePayer;if(X.signatures)this.signatures=X.signatures;if(Object.prototype.hasOwnProperty.call(X,"nonceInfo")){let{minContextSlot:$,nonceInfo:Q}=X;this.minNonceContextSlot=$,this.nonceInfo=Q}else if(Object.prototype.hasOwnProperty.call(X,"lastValidBlockHeight")){let{blockhash:$,lastValidBlockHeight:Q}=X;this.recentBlockhash=$,this.lastValidBlockHeight=Q}else{let{recentBlockhash:$,nonceInfo:Q}=X;if(Q)this.nonceInfo=Q;this.recentBlockhash=$}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((X)=>X.toJSON()),signers:this.signatures.map(({publicKey:X})=>{return X.toJSON()})}}add(...X){if(X.length===0)throw new Error("No instructions");return X.forEach(($)=>{if("instructions"in $)this.instructions=this.instructions.concat($.instructions);else if("data"in $&&"programId"in $&&"keys"in $)this.instructions.push($);else this.instructions.push(new b($))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let X,$;if(this.nonceInfo)if(X=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction)$=[this.nonceInfo.nonceInstruction,...this.instructions];else $=this.instructions;else X=this.recentBlockhash,$=this.instructions;if(!X)throw new Error("Transaction recentBlockhash required");if($.length<1)console.warn("No instructions provided");let Q;if(this.feePayer)Q=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)Q=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let F=0;F<$.length;F++)if($[F].programId===void 0)throw new Error(`Transaction instruction index ${F} has undefined program id`);let Y=[],Z=[];$.forEach((F)=>{F.keys.forEach((E)=>{Z.push({...E})});let j=F.programId.toString();if(!Y.includes(j))Y.push(j)}),Y.forEach((F)=>{Z.push({pubkey:new L(F),isSigner:!1,isWritable:!1})});let J=[];Z.forEach((F)=>{let j=F.pubkey.toString(),E=J.findIndex((p)=>{return p.pubkey.toString()===j});if(E>-1)J[E].isWritable=J[E].isWritable||F.isWritable,J[E].isSigner=J[E].isSigner||F.isSigner;else J.push(F)}),J.sort(function(F,j){if(F.isSigner!==j.isSigner)return F.isSigner?-1:1;if(F.isWritable!==j.isWritable)return F.isWritable?-1:1;let E={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return F.pubkey.toBase58().localeCompare(j.pubkey.toBase58(),"en",E)});let M=J.findIndex((F)=>{return F.pubkey.equals(Q)});if(M>-1){let[F]=J.splice(M,1);F.isSigner=!0,F.isWritable=!0,J.unshift(F)}else J.unshift({pubkey:Q,isSigner:!0,isWritable:!0});for(let F of this.signatures){let j=J.findIndex((E)=>{return E.pubkey.equals(F.publicKey)});if(j>-1){if(!J[j].isSigner)J[j].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.")}else throw new Error(`unknown signer: ${F.publicKey.toString()}`)}let K=0,H=0,P=0,q=[],N=[];J.forEach(({pubkey:F,isSigner:j,isWritable:E})=>{if(j){if(q.push(F.toString()),K+=1,!E)H+=1}else if(N.push(F.toString()),!E)P+=1});let z=q.concat(N),C=$.map((F)=>{let{data:j,programId:E}=F;return{programIdIndex:z.indexOf(E.toString()),accounts:F.keys.map((p)=>z.indexOf(p.pubkey.toString())),data:c.default.encode(j)}});return C.forEach((F)=>{m(F.programIdIndex>=0),F.accounts.forEach((j)=>m(j>=0))}),new U0({header:{numRequiredSignatures:K,numReadonlySignedAccounts:H,numReadonlyUnsignedAccounts:P},accountKeys:z,recentBlockhash:X,instructions:C})}_compile(){let X=this.compileMessage(),$=X.accountKeys.slice(0,X.header.numRequiredSignatures);if(this.signatures.length===$.length){if(this.signatures.every((Y,Z)=>{return $[Z].equals(Y.publicKey)}))return X}return this.signatures=$.map((Q)=>({signature:null,publicKey:Q})),X}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(X){return(await X.getFeeForMessage(this.compileMessage())).value}setSigners(...X){if(X.length===0)throw new Error("No signers");let $=new Set;this.signatures=X.filter((Q)=>{let Y=Q.toString();if($.has(Y))return!1;else return $.add(Y),!0}).map((Q)=>({signature:null,publicKey:Q}))}sign(...X){if(X.length===0)throw new Error("No signers");let $=new Set,Q=[];for(let Z of X){let J=Z.publicKey.toString();if($.has(J))continue;else $.add(J),Q.push(Z)}this.signatures=Q.map((Z)=>({signature:null,publicKey:Z.publicKey}));let Y=this._compile();this._partialSign(Y,...Q)}partialSign(...X){if(X.length===0)throw new Error("No signers");let $=new Set,Q=[];for(let Z of X){let J=Z.publicKey.toString();if($.has(J))continue;else $.add(J),Q.push(Z)}let Y=this._compile();this._partialSign(Y,...Q)}_partialSign(X,...$){let Q=X.serialize();$.forEach((Y)=>{let Z=W4(Q,Y.secretKey);this._addSignature(Y.publicKey,T(Z))})}addSignature(X,$){this._compile(),this._addSignature(X,$)}_addSignature(X,$){m($.length===64);let Q=this.signatures.findIndex((Y)=>X.equals(Y.publicKey));if(Q<0)throw new Error(`unknown signer: ${X.toString()}`);this.signatures[Q].signature=I.from($)}verifySignatures(X=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),X)}_getMessageSignednessErrors(X,$){let Q={};for(let{signature:Y,publicKey:Z}of this.signatures)if(Y===null){if($)(Q.missing||=[]).push(Z)}else if(!JQ(Y,X,Z.toBytes()))(Q.invalid||=[]).push(Z);return Q.invalid||Q.missing?Q:void 0}serialize(X){let{requireAllSignatures:$,verifySignatures:Q}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},X),Y=this.serializeMessage();if(Q){let Z=this._getMessageSignednessErrors(Y,$);if(Z){let J="Signature verification failed.";if(Z.invalid)J+=`
Invalid signature for public key${Z.invalid.length===1?"":"(s)"} [\`${Z.invalid.map((M)=>M.toBase58()).join("`, `")}\`].`;if(Z.missing)J+=`
Missing signature for public key${Z.missing.length===1?"":"(s)"} [\`${Z.missing.map((M)=>M.toBase58()).join("`, `")}\`].`;throw new Error(J)}}return this._serialize(Y)}_serialize(X){let{signatures:$}=this,Q=[];J0(Q,$.length);let Y=Q.length+$.length*64+X.length,Z=I.alloc(Y);return m($.length<256),I.from(Q).copy(Z,0),$.forEach(({signature:J},M)=>{if(J!==null)m(J.length===64,"signature has invalid length"),I.from(J).copy(Z,Q.length+M*64)}),X.copy(Z,Q.length+$.length*64),m(Z.length<=_0,`Transaction too large: ${Z.length} > ${_0}`),Z}get keys(){return m(this.instructions.length===1),this.instructions[0].keys.map((X)=>X.pubkey)}get programId(){return m(this.instructions.length===1),this.instructions[0].programId}get data(){return m(this.instructions.length===1),this.instructions[0].data}static from(X){let $=[...X],Q=Z0($),Y=[];for(let Z=0;Z<Q;Z++){let J=M0($,0,A4);Y.push(c.default.encode(I.from(J)))}return h.populate(U0.from($),Y)}static populate(X,$=[]){let Q=new h;if(Q.recentBlockhash=X.recentBlockhash,X.header.numRequiredSignatures>0)Q.feePayer=X.accountKeys[0];return $.forEach((Y,Z)=>{let J={signature:Y==c.default.encode(WQ)?null:c.default.decode(Y),publicKey:X.accountKeys[Z]};Q.signatures.push(J)}),X.instructions.forEach((Y)=>{let Z=Y.accounts.map((J)=>{let M=X.accountKeys[J];return{pubkey:M,isSigner:Q.signatures.some((K)=>K.publicKey.toString()===M.toString())||X.isAccountSigner(J),isWritable:X.isAccountWritable(J)}});Q.instructions.push(new b({keys:Z,programId:X.accountKeys[Y.programIdIndex],data:c.default.decode(Y.data)}))}),Q._message=X,Q._json=Q.toJSON(),Q}}var qQ=160,zQ=64,FQ=qQ/zQ,O4=1000/FQ,z0=new L("SysvarC1ock11111111111111111111111111111111"),QJ=new L("SysvarEpochSchedu1e111111111111111111111111"),YJ=new L("Sysvar1nstructions1111111111111111111111111"),T8=new L("SysvarRecentB1ockHashes11111111111111111111"),K1=new L("SysvarRent111111111111111111111111111111111"),ZJ=new L("SysvarRewards111111111111111111111111111111"),JJ=new L("SysvarS1otHashes111111111111111111111111111"),MJ=new L("SysvarS1otHistory11111111111111111111111111"),B8=new L("SysvarStakeHistory1111111111111111111111111");class v1 extends Error{constructor({action:X,signature:$,transactionMessage:Q,logs:Y}){let Z=Y?`Logs: 
${JSON.stringify(Y.slice(-10),null,2)}. `:"",J="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",M;switch(X){case"send":M=`Transaction ${$} resulted in an error. 
${Q}. `+Z+"\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";break;case"simulate":M=`Simulation failed. 
Message: ${Q}. 
`+Z+"\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";break;default:M=`Unknown action '${((K)=>K)(X)}'`}super(M);this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=$,this.transactionMessage=Q,this.transactionLogs=Y?Y:void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let X=this.transactionLogs;if(X!=null&&typeof X==="object"&&"then"in X)return;return X}async getLogs(X){if(!Array.isArray(this.transactionLogs))this.transactionLogs=new Promise(($,Q)=>{X.getTransaction(this.signature).then((Y)=>{if(Y&&Y.meta&&Y.meta.logMessages){let Z=Y.meta.logMessages;this.transactionLogs=Z,$(Z)}else Q(new Error("Log messages not found"))}).catch(Q)});return await this.transactionLogs}}class w extends Error{constructor({code:X,message:$,data:Q},Y){super(Y!=null?`${Y}: ${$}`:$);this.code=void 0,this.data=void 0,this.code=X,this.data=Q,this.name="SolanaJSONRPCError"}}async function a2(X,$,Q,Y){let Z=Y&&{skipPreflight:Y.skipPreflight,preflightCommitment:Y.preflightCommitment||Y.commitment,maxRetries:Y.maxRetries,minContextSlot:Y.minContextSlot},J=await X.sendTransaction($,Q,Z),M;if($.recentBlockhash!=null&&$.lastValidBlockHeight!=null)M=(await X.confirmTransaction({abortSignal:Y?.abortSignal,signature:J,blockhash:$.recentBlockhash,lastValidBlockHeight:$.lastValidBlockHeight},Y&&Y.commitment)).value;else if($.minNonceContextSlot!=null&&$.nonceInfo!=null){let{nonceInstruction:K}=$.nonceInfo,H=K.keys[0].pubkey;M=(await X.confirmTransaction({abortSignal:Y?.abortSignal,minContextSlot:$.minNonceContextSlot,nonceAccountPubkey:H,nonceValue:$.nonceInfo.nonce,signature:J},Y&&Y.commitment)).value}else{if(Y?.abortSignal!=null)console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");M=(await X.confirmTransaction(J,Y&&Y.commitment)).value}if(M.err){if(J!=null)throw new v1({action:"send",signature:J,transactionMessage:`Status: (${JSON.stringify(M)})`});throw new Error(`Transaction ${J} failed (${JSON.stringify(M)})`)}return J}function B0(X){return new Promise(($)=>setTimeout($,X))}function B(X,$){let Q=X.layout.span>=0?X.layout.span:D4(X,$),Y=I.alloc(Q),Z=Object.assign({instruction:X.index},$);return X.layout.encode(Z,Y),Y}var AQ=G.nu64("lamportsPerSignature"),R4=G.struct([G.u32("version"),G.u32("state"),k("authorizedPubkey"),k("nonce"),G.struct([AQ],"feeCalculator")]),s2=R4.span;class o8{constructor(X){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=X.authorizedPubkey,this.nonce=X.nonce,this.feeCalculator=X.feeCalculator}static fromAccountData(X){let $=R4.decode(T(X),0);return new o8({authorizedPubkey:new L($.authorizedPubkey),nonce:new L($.nonce).toString(),feeCalculator:$.feeCalculator})}}var DQ=(X)=>{let $=X.decode.bind(X),Q=X.encode.bind(X);return{decode:$,encode:Q}},CQ=(X)=>($)=>{let Q=V4.blob(X,$),{encode:Y,decode:Z}=DQ(Q),J=Q;return J.decode=(M,K)=>{let H=Z(M,K);return H1.toBigIntLE(I.from(H))},J.encode=(M,K,H)=>{let P=H1.toBufferLE(M,X);return Y(P,K,H)},J},c0=CQ(8);var Y0=Object.freeze({Create:{index:0,layout:G.struct([G.u32("instruction"),G.ns64("lamports"),G.ns64("space"),k("programId")])},Assign:{index:1,layout:G.struct([G.u32("instruction"),k("programId")])},Transfer:{index:2,layout:G.struct([G.u32("instruction"),c0("lamports")])},CreateWithSeed:{index:3,layout:G.struct([G.u32("instruction"),k("base"),p0("seed"),G.ns64("lamports"),G.ns64("space"),k("programId")])},AdvanceNonceAccount:{index:4,layout:G.struct([G.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:G.struct([G.u32("instruction"),G.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:G.struct([G.u32("instruction"),k("authorized")])},AuthorizeNonceAccount:{index:7,layout:G.struct([G.u32("instruction"),k("authorized")])},Allocate:{index:8,layout:G.struct([G.u32("instruction"),G.ns64("space")])},AllocateWithSeed:{index:9,layout:G.struct([G.u32("instruction"),k("base"),p0("seed"),G.ns64("space"),k("programId")])},AssignWithSeed:{index:10,layout:G.struct([G.u32("instruction"),k("base"),p0("seed"),k("programId")])},TransferWithSeed:{index:11,layout:G.struct([G.u32("instruction"),c0("lamports"),p0("seed"),k("programId")])},UpgradeNonceAccount:{index:12,layout:G.struct([G.u32("instruction")])}});class r{constructor(){}static createAccount(X){let $=Y0.Create,Q=B($,{lamports:X.lamports,space:X.space,programId:T(X.programId.toBuffer())});return new b({keys:[{pubkey:X.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:X.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:Q})}static transfer(X){let $,Q;if("basePubkey"in X){let Y=Y0.TransferWithSeed;$=B(Y,{lamports:BigInt(X.lamports),seed:X.seed,programId:T(X.programId.toBuffer())}),Q=[{pubkey:X.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:X.basePubkey,isSigner:!0,isWritable:!1},{pubkey:X.toPubkey,isSigner:!1,isWritable:!0}]}else{let Y=Y0.Transfer;$=B(Y,{lamports:BigInt(X.lamports)}),Q=[{pubkey:X.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:X.toPubkey,isSigner:!1,isWritable:!0}]}return new b({keys:Q,programId:this.programId,data:$})}static assign(X){let $,Q;if("basePubkey"in X){let Y=Y0.AssignWithSeed;$=B(Y,{base:T(X.basePubkey.toBuffer()),seed:X.seed,programId:T(X.programId.toBuffer())}),Q=[{pubkey:X.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:X.basePubkey,isSigner:!0,isWritable:!1}]}else{let Y=Y0.Assign;$=B(Y,{programId:T(X.programId.toBuffer())}),Q=[{pubkey:X.accountPubkey,isSigner:!0,isWritable:!0}]}return new b({keys:Q,programId:this.programId,data:$})}static createAccountWithSeed(X){let $=Y0.CreateWithSeed,Q=B($,{base:T(X.basePubkey.toBuffer()),seed:X.seed,lamports:X.lamports,space:X.space,programId:T(X.programId.toBuffer())}),Y=[{pubkey:X.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:X.newAccountPubkey,isSigner:!1,isWritable:!0}];if(!X.basePubkey.equals(X.fromPubkey))Y.push({pubkey:X.basePubkey,isSigner:!0,isWritable:!1});return new b({keys:Y,programId:this.programId,data:Q})}static createNonceAccount(X){let $=new h;if("basePubkey"in X&&"seed"in X)$.add(r.createAccountWithSeed({fromPubkey:X.fromPubkey,newAccountPubkey:X.noncePubkey,basePubkey:X.basePubkey,seed:X.seed,lamports:X.lamports,space:s2,programId:this.programId}));else $.add(r.createAccount({fromPubkey:X.fromPubkey,newAccountPubkey:X.noncePubkey,lamports:X.lamports,space:s2,programId:this.programId}));let Q={noncePubkey:X.noncePubkey,authorizedPubkey:X.authorizedPubkey};return $.add(this.nonceInitialize(Q)),$}static nonceInitialize(X){let $=Y0.InitializeNonceAccount,Q=B($,{authorized:T(X.authorizedPubkey.toBuffer())}),Y={keys:[{pubkey:X.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:T8,isSigner:!1,isWritable:!1},{pubkey:K1,isSigner:!1,isWritable:!1}],programId:this.programId,data:Q};return new b(Y)}static nonceAdvance(X){let $=Y0.AdvanceNonceAccount,Q=B($),Y={keys:[{pubkey:X.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:T8,isSigner:!1,isWritable:!1},{pubkey:X.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:Q};return new b(Y)}static nonceWithdraw(X){let $=Y0.WithdrawNonceAccount,Q=B($,{lamports:X.lamports});return new b({keys:[{pubkey:X.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:X.toPubkey,isSigner:!1,isWritable:!0},{pubkey:T8,isSigner:!1,isWritable:!1},{pubkey:K1,isSigner:!1,isWritable:!1},{pubkey:X.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:Q})}static nonceAuthorize(X){let $=Y0.AuthorizeNonceAccount,Q=B($,{authorized:T(X.newAuthorizedPubkey.toBuffer())});return new b({keys:[{pubkey:X.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:X.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:Q})}static allocate(X){let $,Q;if("basePubkey"in X){let Y=Y0.AllocateWithSeed;$=B(Y,{base:T(X.basePubkey.toBuffer()),seed:X.seed,space:X.space,programId:T(X.programId.toBuffer())}),Q=[{pubkey:X.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:X.basePubkey,isSigner:!0,isWritable:!1}]}else{let Y=Y0.Allocate;$=B(Y,{space:X.space}),Q=[{pubkey:X.accountPubkey,isSigner:!0,isWritable:!0}]}return new b({keys:Q,programId:this.programId,data:$})}}r.programId=new L("11111111111111111111111111111111");var OQ=_0-300;class m1{constructor(){}static getMinNumSignatures(X){return 2*(Math.ceil(X/m1.chunkSize)+1+1)}static async load(X,$,Q,Y,Z){{let q=await X.getMinimumBalanceForRentExemption(Z.length),N=await X.getAccountInfo(Q.publicKey,"confirmed"),z=null;if(N!==null){if(N.executable)return console.error("Program load failed, account is already executable"),!1;if(N.data.length!==Z.length)z=z||new h,z.add(r.allocate({accountPubkey:Q.publicKey,space:Z.length}));if(!N.owner.equals(Y))z=z||new h,z.add(r.assign({accountPubkey:Q.publicKey,programId:Y}));if(N.lamports<q)z=z||new h,z.add(r.transfer({fromPubkey:$.publicKey,toPubkey:Q.publicKey,lamports:q-N.lamports}))}else z=new h().add(r.createAccount({fromPubkey:$.publicKey,newAccountPubkey:Q.publicKey,lamports:q>0?q:1,space:Z.length,programId:Y}));if(z!==null)await a2(X,z,[$,Q],{commitment:"confirmed"})}let J=G.struct([G.u32("instruction"),G.u32("offset"),G.u32("bytesLength"),G.u32("bytesLengthPadding"),G.seq(G.u8("byte"),G.offset(G.u32(),-8),"bytes")]),M=m1.chunkSize,K=0,H=Z,P=[];while(H.length>0){let q=H.slice(0,M),N=I.alloc(M+16);J.encode({instruction:0,offset:K,bytes:q,bytesLength:0,bytesLengthPadding:0},N);let z=new h().add({keys:[{pubkey:Q.publicKey,isSigner:!0,isWritable:!0}],programId:Y,data:N});if(P.push(a2(X,z,[$,Q],{commitment:"confirmed"})),X._rpcEndpoint.includes("solana.com"))await B0(250);K+=M,H=H.slice(M)}await Promise.all(P);{let q=G.struct([G.u32("instruction")]),N=I.alloc(q.span);q.encode({instruction:1},N);let z=new h().add({keys:[{pubkey:Q.publicKey,isSigner:!0,isWritable:!0},{pubkey:K1,isSigner:!1,isWritable:!1}],programId:Y,data:N}),C="processed",F=await X.sendTransaction(z,[$,Q],{preflightCommitment:C}),{context:j,value:E}=await X.confirmTransaction({signature:F,lastValidBlockHeight:z.lastValidBlockHeight,blockhash:z.recentBlockhash},C);if(E.err)throw new Error(`Transaction ${F} failed (${JSON.stringify(E)})`);while(!0){try{if(await X.getSlot({commitment:C})>j.slot)break}catch{}await new Promise((p)=>setTimeout(p,Math.round(O4/2)))}}return!0}}m1.chunkSize=OQ;var KJ=new L("BPFLoader2111111111111111111111111111111111");function RQ(X){return X&&X.__esModule&&Object.prototype.hasOwnProperty.call(X,"default")?X.default:X}var _8,r2;function NQ(){if(r2)return _8;r2=1;var X=Object.prototype.toString,$=Object.keys||function(Y){var Z=[];for(var J in Y)Z.push(J);return Z};function Q(Y,Z){var J,M,K,H,P,q,N;if(Y===!0)return"true";if(Y===!1)return"false";switch(typeof Y){case"object":if(Y===null)return null;else if(Y.toJSON&&typeof Y.toJSON==="function")return Q(Y.toJSON(),Z);else if(N=X.call(Y),N==="[object Array]"){K="[",M=Y.length-1;for(J=0;J<M;J++)K+=Q(Y[J],!0)+",";if(M>-1)K+=Q(Y[J],!0);return K+"]"}else if(N==="[object Object]"){H=$(Y).sort(),M=H.length,K="",J=0;while(J<M){if(P=H[J],q=Q(Y[P],!1),q!==void 0){if(K)K+=",";K+=JSON.stringify(P)+":"+q}J++}return"{"+K+"}"}else return JSON.stringify(Y);case"function":case"undefined":return Z?null:void 0;case"string":return JSON.stringify(Y);default:return isFinite(Y)?Y:null}}return _8=function(Y){var Z=Q(Y,!1);if(Z!==void 0)return""+Z},_8}var jQ=NQ(),t2=RQ(jQ),$1=32;function g8(X){let $=0;while(X>1)X/=2,$++;return $}function wQ(X){if(X===0)return 1;return X--,X|=X>>1,X|=X>>2,X|=X>>4,X|=X>>8,X|=X>>16,X|=X>>32,X+1}class N4{constructor(X,$,Q,Y,Z){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=X,this.leaderScheduleSlotOffset=$,this.warmup=Q,this.firstNormalEpoch=Y,this.firstNormalSlot=Z}getEpoch(X){return this.getEpochAndSlotIndex(X)[0]}getEpochAndSlotIndex(X){if(X<this.firstNormalSlot){let $=g8(wQ(X+$1+1))-g8($1)-1,Q=this.getSlotsInEpoch($),Y=X-(Q-$1);return[$,Y]}else{let $=X-this.firstNormalSlot,Q=Math.floor($/this.slotsPerEpoch),Y=this.firstNormalEpoch+Q,Z=$%this.slotsPerEpoch;return[Y,Z]}}getFirstSlotInEpoch(X){if(X<=this.firstNormalEpoch)return(Math.pow(2,X)-1)*$1;else return(X-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(X){return this.getFirstSlotInEpoch(X)+this.getSlotsInEpoch(X)-1}getSlotsInEpoch(X){if(X<this.firstNormalEpoch)return Math.pow(2,X+g8($1));else return this.slotsPerEpoch}}var UQ=globalThis.fetch;class j4 extends u2{constructor(X,$,Q){let Y=(Z)=>{let J=l2(Z,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1000,...$});if("socket"in J)this.underlyingSocket=J.socket;else this.underlyingSocket=J;return J};super(Y,X,$,Q);this.underlyingSocket=void 0}call(...X){let $=this.underlyingSocket?.readyState;if($===1)return super.call(...X);return Promise.reject(new Error("Tried to call a JSON-RPC method `"+X[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+$+")"))}notify(...X){let $=this.underlyingSocket?.readyState;if($===1)return super.notify(...X);return Promise.reject(new Error("Tried to send a JSON-RPC notification `"+X[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+$+")"))}}function IQ(X,$){let Q;try{Q=X.layout.decode($)}catch(Y){throw new Error("invalid instruction; "+Y)}if(Q.typeIndex!==X.index)throw new Error(`invalid account data; account type mismatch ${Q.typeIndex} != ${X.index}`);return Q}var e2=56;class p8{constructor(X){this.key=void 0,this.state=void 0,this.key=X.key,this.state=X.state}isActive(){let X=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===X}static deserialize(X){let $=IQ(LQ,X),Q=X.length-e2;m(Q>=0,"lookup table is invalid"),m(Q%32===0,"lookup table is invalid");let Y=Q/32,{addresses:Z}=G.struct([G.seq(k(),Y,"addresses")]).decode(X.slice(e2));return{deactivationSlot:$.deactivationSlot,lastExtendedSlot:$.lastExtendedSlot,lastExtendedSlotStartIndex:$.lastExtendedStartIndex,authority:$.authority.length!==0?new L($.authority[0]):void 0,addresses:Z.map((J)=>new L(J))}}}var LQ={index:1,layout:G.struct([G.u32("typeIndex"),c0("deactivationSlot"),G.nu64("lastExtendedSlot"),G.u8("lastExtendedStartIndex"),G.u8(),G.seq(k(),G.offset(G.u8(),-1),"authority")])},EQ=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function SQ(X){let $=X.match(EQ);if($==null)throw TypeError(`Failed to validate endpoint URL \`${X}\``);let[Q,Y,Z,J]=$,M=X.startsWith("https:")?"wss:":"ws:",K=Z==null?null:parseInt(Z.slice(1),10),H=K==null?"":`:${K+1}`;return`${M}//${Y}${H}${J}`}var d=d0(L1(L),A(),(X)=>new L(X)),w4=E1([A(),y("base64")]),a8=d0(L1(I),w4,(X)=>I.from(X[0],"base64")),kQ=30000;function TQ(X){if(/^https?:/.test(X)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return X}function v(X){let $,Q;if(typeof X==="string")$=X;else if(X){let{commitment:Y,...Z}=X;$=Y,Q=Z}return{commitment:$,config:Q}}function X4(X){return X.map(($)=>("memcmp"in $)?{...$,memcmp:{...$.memcmp,encoding:$.memcmp.encoding??"base58"}}:$)}function U4(X){return n([W({jsonrpc:y("2.0"),id:A(),result:X}),W({jsonrpc:y("2.0"),id:A(),error:W({code:T0(),message:A(),data:U(R2())})})])}var BQ=U4(T0());function S(X){return d0(U4(X),BQ,($)=>{if("error"in $)return $;else return{...$,result:D($.result,X)}})}function f(X){return S(W({context:W({slot:V()}),value:X}))}function f1(X){return W({context:W({slot:V()}),value:X})}function h8(X,$){if(X===0)return new x1({header:$.header,staticAccountKeys:$.accountKeys.map((Q)=>new L(Q)),recentBlockhash:$.recentBlockhash,compiledInstructions:$.instructions.map((Q)=>({programIdIndex:Q.programIdIndex,accountKeyIndexes:Q.accounts,data:c.default.decode(Q.data)})),addressTableLookups:$.addressTableLookups});else return new U0($)}var _Q=W({foundation:V(),foundationTerm:V(),initial:V(),taper:V(),terminal:V()}),gQ=S(O(R(W({epoch:V(),effectiveSlot:V(),amount:V(),postBalance:V(),commission:U(R(V()))})))),hQ=O(W({slot:V(),prioritizationFee:V()})),xQ=W({total:V(),validator:V(),foundation:V(),epoch:V()}),vQ=W({epoch:V(),slotIndex:V(),slotsInEpoch:V(),absoluteSlot:V(),blockHeight:U(V()),transactionCount:U(V())}),mQ=W({slotsPerEpoch:V(),leaderScheduleSlotOffset:V(),warmup:H0(),firstNormalEpoch:V(),firstNormalSlot:V()}),bQ=O8(A(),O(V())),x0=R(n([W({}),A()])),yQ=W({err:x0}),dQ=y("receivedSignature"),fQ=W({"solana-core":A(),"feature-set":U(V())}),pQ=W({program:A(),programId:d,parsed:T0()}),cQ=W({programId:d,accounts:O(d),data:A()}),$4=f(W({err:R(n([W({}),A()])),logs:R(O(A())),accounts:U(R(O(R(W({executable:H0(),owner:A(),lamports:V(),data:O(A()),rentEpoch:U(V())}))))),unitsConsumed:U(V()),returnData:U(R(W({programId:A(),data:E1([A(),y("base64")])}))),innerInstructions:U(R(O(W({index:V(),instructions:O(n([pQ,cQ]))}))))})),lQ=f(W({byIdentity:O8(A(),O(V())),range:W({firstSlot:V(),lastSlot:V()})}));function uQ(X,$,Q,Y,Z,J){let M=Q?Q:UQ,K;if(J!=null)console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let H;if(Y)H=async(q,N)=>{let z=await new Promise((C,F)=>{try{Y(q,N,(j,E)=>C([j,E]))}catch(j){F(j)}});return await M(...z)};return new P4.default(async(q,N)=>{let z={method:"POST",body:q,agent:K,headers:Object.assign({"Content-Type":"application/json"},$||{},nY)};try{let C=5,F,j=500;for(;;){if(H)F=await H(X,z);else F=await M(X,z);if(F.status!==429)break;if(Z===!0)break;if(C-=1,C===0)break;console.error(`Server responded with ${F.status} ${F.statusText}.  Retrying after ${j}ms delay...`),await B0(j),j*=2}let E=await F.text();if(F.ok)N(null,E);else N(new Error(`${F.status} ${F.statusText}: ${E}`))}catch(C){if(C instanceof Error)N(C)}},{})}function nQ(X){return($,Q)=>{return new Promise((Y,Z)=>{X.request($,Q,(J,M)=>{if(J){Z(J);return}Y(M)})})}}function iQ(X){return($)=>{return new Promise((Q,Y)=>{if($.length===0)Q([]);let Z=$.map((J)=>{return X.request(J.methodName,J.args)});X.request(Z,(J,M)=>{if(J){Y(J);return}Q(M)})})}}var oQ=S(_Q),aQ=S(xQ),sQ=S(hQ),rQ=S(vQ),tQ=S(mQ),eQ=S(bQ),XY=S(V()),$Y=f(W({total:V(),circulating:V(),nonCirculating:V(),nonCirculatingAccounts:O(d)})),c8=W({amount:A(),uiAmount:R(V()),decimals:V(),uiAmountString:U(A())}),QY=f(O(W({address:d,amount:A(),uiAmount:R(V()),decimals:V(),uiAmountString:U(A())}))),YY=f(O(W({pubkey:d,account:W({executable:H0(),owner:d,lamports:V(),data:a8,rentEpoch:V()})}))),l8=W({program:A(),parsed:T0(),space:V()}),ZY=f(O(W({pubkey:d,account:W({executable:H0(),owner:d,lamports:V(),data:l8,rentEpoch:V()})}))),JY=f(O(W({lamports:V(),address:d}))),G1=W({executable:H0(),owner:d,lamports:V(),data:a8,rentEpoch:V()}),MY=W({pubkey:d,account:G1}),KY=d0(n([L1(I),l8]),n([w4,l8]),(X)=>{if(Array.isArray(X))return D(X,a8);else return X}),u8=W({executable:H0(),owner:d,lamports:V(),data:KY,rentEpoch:V()}),GY=W({pubkey:d,account:u8}),HY=W({state:n([y("active"),y("inactive"),y("activating"),y("deactivating")]),active:V(),inactive:V()}),VY=S(O(W({signature:A(),slot:V(),err:x0,memo:R(A()),blockTime:U(R(V()))}))),PY=S(O(W({signature:A(),slot:V(),err:x0,memo:R(A()),blockTime:U(R(V()))}))),WY=W({subscription:V(),result:f1(G1)}),qY=W({pubkey:d,account:G1}),zY=W({subscription:V(),result:f1(qY)}),FY=W({parent:V(),slot:V(),root:V()}),AY=W({subscription:V(),result:FY}),DY=n([W({type:n([y("firstShredReceived"),y("completed"),y("optimisticConfirmation"),y("root")]),slot:V(),timestamp:V()}),W({type:y("createdBank"),parent:V(),slot:V(),timestamp:V()}),W({type:y("frozen"),slot:V(),timestamp:V(),stats:W({numTransactionEntries:V(),numSuccessfulTransactions:V(),numFailedTransactions:V(),maxTransactionsPerEntry:V()})}),W({type:y("dead"),slot:V(),timestamp:V(),err:A()})]),CY=W({subscription:V(),result:DY}),OY=W({subscription:V(),result:f1(n([yQ,dQ]))}),RY=W({subscription:V(),result:V()}),NY=W({pubkey:A(),gossip:R(A()),tpu:R(A()),rpc:R(A()),version:R(A())}),Q4=W({votePubkey:A(),nodePubkey:A(),activatedStake:V(),epochVoteAccount:H0(),epochCredits:O(E1([V(),V(),V()])),commission:V(),lastVote:V(),rootSlot:R(V())}),jY=S(W({current:O(Q4),delinquent:O(Q4)})),wY=n([y("processed"),y("confirmed"),y("finalized")]),UY=W({slot:V(),confirmations:R(V()),err:x0,confirmationStatus:U(wY)}),IY=f(O(R(UY))),LY=S(V()),I4=W({accountKey:d,writableIndexes:O(V()),readonlyIndexes:O(V())}),s8=W({signatures:O(A()),message:W({accountKeys:O(A()),header:W({numRequiredSignatures:V(),numReadonlySignedAccounts:V(),numReadonlyUnsignedAccounts:V()}),instructions:O(W({accounts:O(V()),data:A(),programIdIndex:V()})),recentBlockhash:A(),addressTableLookups:U(O(I4))})}),L4=W({pubkey:d,signer:H0(),writable:H0(),source:U(n([y("transaction"),y("lookupTable")]))}),E4=W({accountKeys:O(L4),signatures:O(A())}),S4=W({parsed:T0(),program:A(),programId:d}),k4=W({accounts:O(d),data:A(),programId:d}),EY=n([k4,S4]),SY=n([W({parsed:T0(),program:A(),programId:A()}),W({accounts:O(A()),data:A(),programId:A()})]),T4=d0(EY,SY,(X)=>{if("accounts"in X)return D(X,k4);else return D(X,S4)}),B4=W({signatures:O(A()),message:W({accountKeys:O(L4),instructions:O(T4),recentBlockhash:A(),addressTableLookups:U(R(O(I4)))})}),b1=W({accountIndex:V(),mint:A(),owner:U(A()),programId:U(A()),uiTokenAmount:c8}),_4=W({writable:O(d),readonly:O(d)}),p1=W({err:x0,fee:V(),innerInstructions:U(R(O(W({index:V(),instructions:O(W({accounts:O(V()),data:A(),programIdIndex:V()}))})))),preBalances:O(V()),postBalances:O(V()),logMessages:U(R(O(A()))),preTokenBalances:U(R(O(b1))),postTokenBalances:U(R(O(b1))),loadedAddresses:U(_4),computeUnitsConsumed:U(V())}),r8=W({err:x0,fee:V(),innerInstructions:U(R(O(W({index:V(),instructions:O(T4)})))),preBalances:O(V()),postBalances:O(V()),logMessages:U(R(O(A()))),preTokenBalances:U(R(O(b1))),postTokenBalances:U(R(O(b1))),loadedAddresses:U(_4),computeUnitsConsumed:U(V())}),u0=n([y(0),y("legacy")]),v0=W({pubkey:A(),lamports:V(),postBalance:R(V()),rewardType:R(A()),commission:U(R(V()))}),kY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),transactions:O(W({transaction:s8,meta:R(p1),version:U(u0)})),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),TY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),BY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),transactions:O(W({transaction:E4,meta:R(p1),version:U(u0)})),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),_Y=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),transactions:O(W({transaction:B4,meta:R(r8),version:U(u0)})),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),gY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),transactions:O(W({transaction:E4,meta:R(r8),version:U(u0)})),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),hY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),rewards:U(O(v0)),blockTime:R(V()),blockHeight:R(V())}))),xY=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),transactions:O(W({transaction:s8,meta:R(p1)})),rewards:U(O(v0)),blockTime:R(V())}))),Y4=S(R(W({blockhash:A(),previousBlockhash:A(),parentSlot:V(),signatures:O(A()),blockTime:R(V())}))),x8=S(R(W({slot:V(),meta:R(p1),blockTime:U(R(V())),transaction:s8,version:U(u0)}))),_1=S(R(W({slot:V(),transaction:B4,meta:R(r8),blockTime:U(R(V())),version:U(u0)}))),vY=f(W({blockhash:A(),feeCalculator:W({lamportsPerSignature:V()})})),mY=f(W({blockhash:A(),lastValidBlockHeight:V()})),bY=f(H0()),yY=W({slot:V(),numTransactions:V(),numSlots:V(),samplePeriodSecs:V()}),dY=S(O(yY)),fY=f(R(W({feeCalculator:W({lamportsPerSignature:V()})}))),pY=S(A()),cY=S(A()),lY=W({err:x0,logs:O(A()),signature:A()}),uY=W({result:f1(lY),subscription:V()}),nY={"solana-client":"js/1.95.8"};class iY{constructor(X,$){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let H={};return async(P)=>{let{commitment:q,config:N}=v(P),z=this._buildArgs([],q,void 0,N),C=t2(z);return H[C]=H[C]??(async()=>{try{let F=await this._rpcRequest("getBlockHeight",z),j=D(F,S(V()));if("error"in j)throw new w(j.error,"failed to get block height information");return j.result}finally{delete H[C]}})(),await H[C]}})();let Q,Y,Z,J,M,K;if($&&typeof $==="string")this._commitment=$;else if($)this._commitment=$.commitment,this._confirmTransactionInitialTimeout=$.confirmTransactionInitialTimeout,Q=$.wsEndpoint,Y=$.httpHeaders,Z=$.fetch,J=$.fetchMiddleware,M=$.disableRetryOnRateLimit,K=$.httpAgent;this._rpcEndpoint=TQ(X),this._rpcWsEndpoint=Q||SQ(X),this._rpcClient=uQ(X,Y,Z,J,M,K),this._rpcRequest=nQ(this._rpcClient),this._rpcBatchRequest=iQ(this._rpcClient),this._rpcWebSocket=new j4(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgs([X.toBase58()],Q,void 0,Y),J=await this._rpcRequest("getBalance",Z),M=D(J,f(V()));if("error"in M)throw new w(M.error,`failed to get balance for ${X.toBase58()}`);return M.result}async getBalance(X,$){return await this.getBalanceAndContext(X,$).then((Q)=>Q.value).catch((Q)=>{throw new Error("failed to get balance of account "+X.toBase58()+": "+Q)})}async getBlockTime(X){let $=await this._rpcRequest("getBlockTime",[X]),Q=D($,S(R(V())));if("error"in Q)throw new w(Q.error,`failed to get block time for slot ${X}`);return Q.result}async getMinimumLedgerSlot(){let X=await this._rpcRequest("minimumLedgerSlot",[]),$=D(X,S(V()));if("error"in $)throw new w($.error,"failed to get minimum ledger slot");return $.result}async getFirstAvailableBlock(){let X=await this._rpcRequest("getFirstAvailableBlock",[]),$=D(X,XY);if("error"in $)throw new w($.error,"failed to get first available block");return $.result}async getSupply(X){let $={};if(typeof X==="string")$={commitment:X};else if(X)$={...X,commitment:X&&X.commitment||this.commitment};else $={commitment:this.commitment};let Q=await this._rpcRequest("getSupply",[$]),Y=D(Q,$Y);if("error"in Y)throw new w(Y.error,"failed to get supply");return Y.result}async getTokenSupply(X,$){let Q=this._buildArgs([X.toBase58()],$),Y=await this._rpcRequest("getTokenSupply",Q),Z=D(Y,f(c8));if("error"in Z)throw new w(Z.error,"failed to get token supply");return Z.result}async getTokenAccountBalance(X,$){let Q=this._buildArgs([X.toBase58()],$),Y=await this._rpcRequest("getTokenAccountBalance",Q),Z=D(Y,f(c8));if("error"in Z)throw new w(Z.error,"failed to get token account balance");return Z.result}async getTokenAccountsByOwner(X,$,Q){let{commitment:Y,config:Z}=v(Q),J=[X.toBase58()];if("mint"in $)J.push({mint:$.mint.toBase58()});else J.push({programId:$.programId.toBase58()});let M=this._buildArgs(J,Y,"base64",Z),K=await this._rpcRequest("getTokenAccountsByOwner",M),H=D(K,YY);if("error"in H)throw new w(H.error,`failed to get token accounts owned by account ${X.toBase58()}`);return H.result}async getParsedTokenAccountsByOwner(X,$,Q){let Y=[X.toBase58()];if("mint"in $)Y.push({mint:$.mint.toBase58()});else Y.push({programId:$.programId.toBase58()});let Z=this._buildArgs(Y,Q,"jsonParsed"),J=await this._rpcRequest("getTokenAccountsByOwner",Z),M=D(J,ZY);if("error"in M)throw new w(M.error,`failed to get token accounts owned by account ${X.toBase58()}`);return M.result}async getLargestAccounts(X){let $={...X,commitment:X&&X.commitment||this.commitment},Q=$.filter||$.commitment?[$]:[],Y=await this._rpcRequest("getLargestAccounts",Q),Z=D(Y,JY);if("error"in Z)throw new w(Z.error,"failed to get largest accounts");return Z.result}async getTokenLargestAccounts(X,$){let Q=this._buildArgs([X.toBase58()],$),Y=await this._rpcRequest("getTokenLargestAccounts",Q),Z=D(Y,QY);if("error"in Z)throw new w(Z.error,"failed to get token largest accounts");return Z.result}async getAccountInfoAndContext(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgs([X.toBase58()],Q,"base64",Y),J=await this._rpcRequest("getAccountInfo",Z),M=D(J,f(R(G1)));if("error"in M)throw new w(M.error,`failed to get info about account ${X.toBase58()}`);return M.result}async getParsedAccountInfo(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgs([X.toBase58()],Q,"jsonParsed",Y),J=await this._rpcRequest("getAccountInfo",Z),M=D(J,f(R(u8)));if("error"in M)throw new w(M.error,`failed to get info about account ${X.toBase58()}`);return M.result}async getAccountInfo(X,$){try{return(await this.getAccountInfoAndContext(X,$)).value}catch(Q){throw new Error("failed to get info about account "+X.toBase58()+": "+Q)}}async getMultipleParsedAccounts(X,$){let{commitment:Q,config:Y}=v($),Z=X.map((H)=>H.toBase58()),J=this._buildArgs([Z],Q,"jsonParsed",Y),M=await this._rpcRequest("getMultipleAccounts",J),K=D(M,f(O(R(u8))));if("error"in K)throw new w(K.error,`failed to get info for accounts ${Z}`);return K.result}async getMultipleAccountsInfoAndContext(X,$){let{commitment:Q,config:Y}=v($),Z=X.map((H)=>H.toBase58()),J=this._buildArgs([Z],Q,"base64",Y),M=await this._rpcRequest("getMultipleAccounts",J),K=D(M,f(O(R(G1))));if("error"in K)throw new w(K.error,`failed to get info for accounts ${Z}`);return K.result}async getMultipleAccountsInfo(X,$){return(await this.getMultipleAccountsInfoAndContext(X,$)).value}async getStakeActivation(X,$,Q){let{commitment:Y,config:Z}=v($),J=this._buildArgs([X.toBase58()],Y,void 0,{...Z,epoch:Q!=null?Q:Z?.epoch}),M=await this._rpcRequest("getStakeActivation",J),K=D(M,S(HY));if("error"in K)throw new w(K.error,`failed to get Stake Activation ${X.toBase58()}`);return K.result}async getProgramAccounts(X,$){let{commitment:Q,config:Y}=v($),{encoding:Z,...J}=Y||{},M=this._buildArgs([X.toBase58()],Q,Z||"base64",{...J,...J.filters?{filters:X4(J.filters)}:null}),K=await this._rpcRequest("getProgramAccounts",M),H=O(MY),P=J.withContext===!0?D(K,f(H)):D(K,S(H));if("error"in P)throw new w(P.error,`failed to get accounts owned by program ${X.toBase58()}`);return P.result}async getParsedProgramAccounts(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgs([X.toBase58()],Q,"jsonParsed",Y),J=await this._rpcRequest("getProgramAccounts",Z),M=D(J,S(O(GY)));if("error"in M)throw new w(M.error,`failed to get accounts owned by program ${X.toBase58()}`);return M.result}async confirmTransaction(X,$){let Q;if(typeof X=="string")Q=X;else{let Z=X;if(Z.abortSignal?.aborted)return Promise.reject(Z.abortSignal.reason);Q=Z.signature}let Y;try{Y=c.default.decode(Q)}catch(Z){throw new Error("signature must be base58 encoded: "+Q)}if(m(Y.length===64,"signature has invalid length"),typeof X==="string")return await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:$||this.commitment,signature:Q});else if("lastValidBlockHeight"in X)return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:$||this.commitment,strategy:X});else return await this.confirmTransactionUsingDurableNonceStrategy({commitment:$||this.commitment,strategy:X})}getCancellationPromise(X){return new Promise(($,Q)=>{if(X==null)return;if(X.aborted)Q(X.reason);else X.addEventListener("abort",()=>{Q(X.reason)})})}getTransactionConfirmationPromise({commitment:X,signature:$}){let Q,Y,Z=!1,J=new Promise((K,H)=>{try{Q=this.onSignature($,(q,N)=>{Q=void 0;let z={context:N,value:q};K({__type:N0.PROCESSED,response:z})},X);let P=new Promise((q)=>{if(Q==null)q();else Y=this._onSubscriptionStateChange(Q,(N)=>{if(N==="subscribed")q()})});(async()=>{if(await P,Z)return;let q=await this.getSignatureStatus($);if(Z)return;if(q==null)return;let{context:N,value:z}=q;if(z==null)return;if(z?.err)H(z.err);else{switch(X){case"confirmed":case"single":case"singleGossip":{if(z.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(z.confirmationStatus==="processed"||z.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}Z=!0,K({__type:N0.PROCESSED,response:{context:N,value:z}})}})()}catch(P){H(P)}});return{abortConfirmation:()=>{if(Y)Y(),Y=void 0;if(Q!=null)this.removeSignatureListener(Q),Q=void 0},confirmationPromise:J}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:X,strategy:{abortSignal:$,lastValidBlockHeight:Q,signature:Y}}){let Z=!1,J=new Promise((q)=>{let N=async()=>{try{return await this.getBlockHeight(X)}catch(z){return-1}};(async()=>{let z=await N();if(Z)return;while(z<=Q){if(await B0(1000),Z)return;if(z=await N(),Z)return}q({__type:N0.BLOCKHEIGHT_EXCEEDED})})()}),{abortConfirmation:M,confirmationPromise:K}=this.getTransactionConfirmationPromise({commitment:X,signature:Y}),H=this.getCancellationPromise($),P;try{let q=await Promise.race([H,K,J]);if(q.__type===N0.PROCESSED)P=q.response;else throw new n8(Y)}finally{Z=!0,M()}return P}async confirmTransactionUsingDurableNonceStrategy({commitment:X,strategy:{abortSignal:$,minContextSlot:Q,nonceAccountPubkey:Y,nonceValue:Z,signature:J}}){let M=!1,K=new Promise((z)=>{let C=Z,F=null,j=async()=>{try{let{context:E,value:p}=await this.getNonceAndContext(Y,{commitment:X,minContextSlot:Q});return F=E.slot,p?.nonce}catch(E){return C}};(async()=>{if(C=await j(),M)return;while(!0){if(Z!==C){z({__type:N0.NONCE_INVALID,slotInWhichNonceDidAdvance:F});return}if(await B0(2000),M)return;if(C=await j(),M)return}})()}),{abortConfirmation:H,confirmationPromise:P}=this.getTransactionConfirmationPromise({commitment:X,signature:J}),q=this.getCancellationPromise($),N;try{let z=await Promise.race([q,P,K]);if(z.__type===N0.PROCESSED)N=z.response;else{let C;while(!0){let F=await this.getSignatureStatus(J);if(F==null)break;if(F.context.slot<(z.slotInWhichNonceDidAdvance??Q)){await B0(400);continue}C=F;break}if(C?.value){let F=X||"finalized",{confirmationStatus:j}=C.value;switch(F){case"processed":case"recent":if(j!=="processed"&&j!=="confirmed"&&j!=="finalized")throw new f0(J);break;case"confirmed":case"single":case"singleGossip":if(j!=="confirmed"&&j!=="finalized")throw new f0(J);break;case"finalized":case"max":case"root":if(j!=="finalized")throw new f0(J);break;default:((E)=>{})(F)}N={context:C.context,value:{err:C.value.err}}}else throw new f0(J)}}finally{M=!0,H()}return N}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:X,signature:$}){let Q,Y=new Promise((K)=>{let H=this._confirmTransactionInitialTimeout||60000;switch(X){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{H=this._confirmTransactionInitialTimeout||30000;break}}Q=setTimeout(()=>K({__type:N0.TIMED_OUT,timeoutMs:H}),H)}),{abortConfirmation:Z,confirmationPromise:J}=this.getTransactionConfirmationPromise({commitment:X,signature:$}),M;try{let K=await Promise.race([J,Y]);if(K.__type===N0.PROCESSED)M=K.response;else throw new i8($,K.timeoutMs/1000)}finally{clearTimeout(Q),Z()}return M}async getClusterNodes(){let X=await this._rpcRequest("getClusterNodes",[]),$=D(X,S(O(NY)));if("error"in $)throw new w($.error,"failed to get cluster nodes");return $.result}async getVoteAccounts(X){let $=this._buildArgs([],X),Q=await this._rpcRequest("getVoteAccounts",$),Y=D(Q,jY);if("error"in Y)throw new w(Y.error,"failed to get vote accounts");return Y.result}async getSlot(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,void 0,Q),Z=await this._rpcRequest("getSlot",Y),J=D(Z,S(V()));if("error"in J)throw new w(J.error,"failed to get slot");return J.result}async getSlotLeader(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,void 0,Q),Z=await this._rpcRequest("getSlotLeader",Y),J=D(Z,S(A()));if("error"in J)throw new w(J.error,"failed to get slot leader");return J.result}async getSlotLeaders(X,$){let Q=[X,$],Y=await this._rpcRequest("getSlotLeaders",Q),Z=D(Y,S(O(d)));if("error"in Z)throw new w(Z.error,"failed to get slot leaders");return Z.result}async getSignatureStatus(X,$){let{context:Q,value:Y}=await this.getSignatureStatuses([X],$);m(Y.length===1);let Z=Y[0];return{context:Q,value:Z}}async getSignatureStatuses(X,$){let Q=[X];if($)Q.push($);let Y=await this._rpcRequest("getSignatureStatuses",Q),Z=D(Y,IY);if("error"in Z)throw new w(Z.error,"failed to get signature status");return Z.result}async getTransactionCount(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,void 0,Q),Z=await this._rpcRequest("getTransactionCount",Y),J=D(Z,S(V()));if("error"in J)throw new w(J.error,"failed to get transaction count");return J.result}async getTotalSupply(X){return(await this.getSupply({commitment:X,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(X){let $=this._buildArgs([],X),Q=await this._rpcRequest("getInflationGovernor",$),Y=D(Q,oQ);if("error"in Y)throw new w(Y.error,"failed to get inflation");return Y.result}async getInflationReward(X,$,Q){let{commitment:Y,config:Z}=v(Q),J=this._buildArgs([X.map((H)=>H.toBase58())],Y,void 0,{...Z,epoch:$!=null?$:Z?.epoch}),M=await this._rpcRequest("getInflationReward",J),K=D(M,gQ);if("error"in K)throw new w(K.error,"failed to get inflation reward");return K.result}async getInflationRate(){let X=await this._rpcRequest("getInflationRate",[]),$=D(X,aQ);if("error"in $)throw new w($.error,"failed to get inflation rate");return $.result}async getEpochInfo(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,void 0,Q),Z=await this._rpcRequest("getEpochInfo",Y),J=D(Z,rQ);if("error"in J)throw new w(J.error,"failed to get epoch info");return J.result}async getEpochSchedule(){let X=await this._rpcRequest("getEpochSchedule",[]),$=D(X,tQ);if("error"in $)throw new w($.error,"failed to get epoch schedule");let Q=$.result;return new N4(Q.slotsPerEpoch,Q.leaderScheduleSlotOffset,Q.warmup,Q.firstNormalEpoch,Q.firstNormalSlot)}async getLeaderSchedule(){let X=await this._rpcRequest("getLeaderSchedule",[]),$=D(X,eQ);if("error"in $)throw new w($.error,"failed to get leader schedule");return $.result}async getMinimumBalanceForRentExemption(X,$){let Q=this._buildArgs([X],$),Y=await this._rpcRequest("getMinimumBalanceForRentExemption",Q),Z=D(Y,LY);if("error"in Z)return console.warn("Unable to fetch minimum balance for rent exemption"),0;return Z.result}async getRecentBlockhashAndContext(X){let $=this._buildArgs([],X),Q=await this._rpcRequest("getRecentBlockhash",$),Y=D(Q,vY);if("error"in Y)throw new w(Y.error,"failed to get recent blockhash");return Y.result}async getRecentPerformanceSamples(X){let $=await this._rpcRequest("getRecentPerformanceSamples",X?[X]:[]),Q=D($,dY);if("error"in Q)throw new w(Q.error,"failed to get recent performance samples");return Q.result}async getFeeCalculatorForBlockhash(X,$){let Q=this._buildArgs([X],$),Y=await this._rpcRequest("getFeeCalculatorForBlockhash",Q),Z=D(Y,fY);if("error"in Z)throw new w(Z.error,"failed to get fee calculator");let{context:J,value:M}=Z.result;return{context:J,value:M!==null?M.feeCalculator:null}}async getFeeForMessage(X,$){let Q=T(X.serialize()).toString("base64"),Y=this._buildArgs([Q],$),Z=await this._rpcRequest("getFeeForMessage",Y),J=D(Z,f(R(V())));if("error"in J)throw new w(J.error,"failed to get fee for message");if(J.result===null)throw new Error("invalid blockhash");return J.result}async getRecentPrioritizationFees(X){let $=X?.lockedWritableAccounts?.map((J)=>J.toBase58()),Q=$?.length?[$]:[],Y=await this._rpcRequest("getRecentPrioritizationFees",Q),Z=D(Y,sQ);if("error"in Z)throw new w(Z.error,"failed to get recent prioritization fees");return Z.result}async getRecentBlockhash(X){try{return(await this.getRecentBlockhashAndContext(X)).value}catch($){throw new Error("failed to get recent blockhash: "+$)}}async getLatestBlockhash(X){try{return(await this.getLatestBlockhashAndContext(X)).value}catch($){throw new Error("failed to get recent blockhash: "+$)}}async getLatestBlockhashAndContext(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,void 0,Q),Z=await this._rpcRequest("getLatestBlockhash",Y),J=D(Z,mY);if("error"in J)throw new w(J.error,"failed to get latest blockhash");return J.result}async isBlockhashValid(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgs([X],Q,void 0,Y),J=await this._rpcRequest("isBlockhashValid",Z),M=D(J,bY);if("error"in M)throw new w(M.error,"failed to determine if the blockhash `"+X+"`is valid");return M.result}async getVersion(){let X=await this._rpcRequest("getVersion",[]),$=D(X,S(fQ));if("error"in $)throw new w($.error,"failed to get version");return $.result}async getGenesisHash(){let X=await this._rpcRequest("getGenesisHash",[]),$=D(X,S(A()));if("error"in $)throw new w($.error,"failed to get genesis hash");return $.result}async getBlock(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgsAtLeastConfirmed([X],Q,void 0,Y),J=await this._rpcRequest("getBlock",Z);try{switch(Y?.transactionDetails){case"accounts":{let M=D(J,BY);if("error"in M)throw M.error;return M.result}case"none":{let M=D(J,TY);if("error"in M)throw M.error;return M.result}default:{let M=D(J,kY);if("error"in M)throw M.error;let{result:K}=M;return K?{...K,transactions:K.transactions.map(({transaction:H,meta:P,version:q})=>({meta:P,transaction:{...H,message:h8(q,H.message)},version:q}))}:null}}}catch(M){throw new w(M,"failed to get confirmed block")}}async getParsedBlock(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgsAtLeastConfirmed([X],Q,"jsonParsed",Y),J=await this._rpcRequest("getBlock",Z);try{switch(Y?.transactionDetails){case"accounts":{let M=D(J,gY);if("error"in M)throw M.error;return M.result}case"none":{let M=D(J,hY);if("error"in M)throw M.error;return M.result}default:{let M=D(J,_Y);if("error"in M)throw M.error;return M.result}}}catch(M){throw new w(M,"failed to get block")}}async getBlockProduction(X){let $,Q;if(typeof X==="string")Q=X;else if(X){let{commitment:M,...K}=X;Q=M,$=K}let Y=this._buildArgs([],Q,"base64",$),Z=await this._rpcRequest("getBlockProduction",Y),J=D(Z,lQ);if("error"in J)throw new w(J.error,"failed to get block production information");return J.result}async getTransaction(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgsAtLeastConfirmed([X],Q,void 0,Y),J=await this._rpcRequest("getTransaction",Z),M=D(J,x8);if("error"in M)throw new w(M.error,"failed to get transaction");let K=M.result;if(!K)return K;return{...K,transaction:{...K.transaction,message:h8(K.version,K.transaction.message)}}}async getParsedTransaction(X,$){let{commitment:Q,config:Y}=v($),Z=this._buildArgsAtLeastConfirmed([X],Q,"jsonParsed",Y),J=await this._rpcRequest("getTransaction",Z),M=D(J,_1);if("error"in M)throw new w(M.error,"failed to get transaction");return M.result}async getParsedTransactions(X,$){let{commitment:Q,config:Y}=v($),Z=X.map((K)=>{return{methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([K],Q,"jsonParsed",Y)}});return(await this._rpcBatchRequest(Z)).map((K)=>{let H=D(K,_1);if("error"in H)throw new w(H.error,"failed to get transactions");return H.result})}async getTransactions(X,$){let{commitment:Q,config:Y}=v($),Z=X.map((K)=>{return{methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([K],Q,void 0,Y)}});return(await this._rpcBatchRequest(Z)).map((K)=>{let H=D(K,x8);if("error"in H)throw new w(H.error,"failed to get transactions");let P=H.result;if(!P)return P;return{...P,transaction:{...P.transaction,message:h8(P.version,P.transaction.message)}}})}async getConfirmedBlock(X,$){let Q=this._buildArgsAtLeastConfirmed([X],$),Y=await this._rpcRequest("getConfirmedBlock",Q),Z=D(Y,xY);if("error"in Z)throw new w(Z.error,"failed to get confirmed block");let J=Z.result;if(!J)throw new Error("Confirmed block "+X+" not found");let M={...J,transactions:J.transactions.map(({transaction:K,meta:H})=>{let P=new U0(K.message);return{meta:H,transaction:{...K,message:P}}})};return{...M,transactions:M.transactions.map(({transaction:K,meta:H})=>{return{meta:H,transaction:h.populate(K.message,K.signatures)}})}}async getBlocks(X,$,Q){let Y=this._buildArgsAtLeastConfirmed($!==void 0?[X,$]:[X],Q),Z=await this._rpcRequest("getBlocks",Y),J=D(Z,S(O(V())));if("error"in J)throw new w(J.error,"failed to get blocks");return J.result}async getBlockSignatures(X,$){let Q=this._buildArgsAtLeastConfirmed([X],$,void 0,{transactionDetails:"signatures",rewards:!1}),Y=await this._rpcRequest("getBlock",Q),Z=D(Y,Y4);if("error"in Z)throw new w(Z.error,"failed to get block");let J=Z.result;if(!J)throw new Error("Block "+X+" not found");return J}async getConfirmedBlockSignatures(X,$){let Q=this._buildArgsAtLeastConfirmed([X],$,void 0,{transactionDetails:"signatures",rewards:!1}),Y=await this._rpcRequest("getConfirmedBlock",Q),Z=D(Y,Y4);if("error"in Z)throw new w(Z.error,"failed to get confirmed block");let J=Z.result;if(!J)throw new Error("Confirmed block "+X+" not found");return J}async getConfirmedTransaction(X,$){let Q=this._buildArgsAtLeastConfirmed([X],$),Y=await this._rpcRequest("getConfirmedTransaction",Q),Z=D(Y,x8);if("error"in Z)throw new w(Z.error,"failed to get transaction");let J=Z.result;if(!J)return J;let M=new U0(J.transaction.message),K=J.transaction.signatures;return{...J,transaction:h.populate(M,K)}}async getParsedConfirmedTransaction(X,$){let Q=this._buildArgsAtLeastConfirmed([X],$,"jsonParsed"),Y=await this._rpcRequest("getConfirmedTransaction",Q),Z=D(Y,_1);if("error"in Z)throw new w(Z.error,"failed to get confirmed transaction");return Z.result}async getParsedConfirmedTransactions(X,$){let Q=X.map((J)=>{return{methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([J],$,"jsonParsed")}});return(await this._rpcBatchRequest(Q)).map((J)=>{let M=D(J,_1);if("error"in M)throw new w(M.error,"failed to get confirmed transactions");return M.result})}async getConfirmedSignaturesForAddress(X,$,Q){let Y={},Z=await this.getFirstAvailableBlock();while(!("until"in Y)){if($--,$<=0||$<Z)break;try{let K=await this.getConfirmedBlockSignatures($,"finalized");if(K.signatures.length>0)Y.until=K.signatures[K.signatures.length-1].toString()}catch(K){if(K instanceof Error&&K.message.includes("skipped"))continue;else throw K}}let J=await this.getSlot("finalized");while(!("before"in Y)){if(Q++,Q>J)break;try{let K=await this.getConfirmedBlockSignatures(Q);if(K.signatures.length>0)Y.before=K.signatures[K.signatures.length-1].toString()}catch(K){if(K instanceof Error&&K.message.includes("skipped"))continue;else throw K}}return(await this.getConfirmedSignaturesForAddress2(X,Y)).map((K)=>K.signature)}async getConfirmedSignaturesForAddress2(X,$,Q){let Y=this._buildArgsAtLeastConfirmed([X.toBase58()],Q,void 0,$),Z=await this._rpcRequest("getConfirmedSignaturesForAddress2",Y),J=D(Z,VY);if("error"in J)throw new w(J.error,"failed to get confirmed signatures for address");return J.result}async getSignaturesForAddress(X,$,Q){let Y=this._buildArgsAtLeastConfirmed([X.toBase58()],Q,void 0,$),Z=await this._rpcRequest("getSignaturesForAddress",Y),J=D(Z,PY);if("error"in J)throw new w(J.error,"failed to get signatures for address");return J.result}async getAddressLookupTable(X,$){let{context:Q,value:Y}=await this.getAccountInfoAndContext(X,$),Z=null;if(Y!==null)Z=new p8({key:X,state:p8.deserialize(Y.data)});return{context:Q,value:Z}}async getNonceAndContext(X,$){let{context:Q,value:Y}=await this.getAccountInfoAndContext(X,$),Z=null;if(Y!==null)Z=o8.fromAccountData(Y.data);return{context:Q,value:Z}}async getNonce(X,$){return await this.getNonceAndContext(X,$).then((Q)=>Q.value).catch((Q)=>{throw new Error("failed to get nonce for account "+X.toBase58()+": "+Q)})}async requestAirdrop(X,$){let Q=await this._rpcRequest("requestAirdrop",[X.toBase58(),$]),Y=D(Q,pY);if("error"in Y)throw new w(Y.error,`airdrop to ${X.toBase58()} failed`);return Y.result}async _blockhashWithExpiryBlockHeight(X){if(!X){while(this._pollingBlockhash)await B0(100);let Q=Date.now()-this._blockhashInfo.lastFetch>=kQ;if(this._blockhashInfo.latestBlockhash!==null&&!Q)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{let X=Date.now(),$=this._blockhashInfo.latestBlockhash,Q=$?$.blockhash:null;for(let Y=0;Y<50;Y++){let Z=await this.getLatestBlockhash("finalized");if(Q!==Z.blockhash)return this._blockhashInfo={latestBlockhash:Z,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},Z;await B0(O4/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-X}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(X){let{commitment:$,config:Q}=v(X),Y=this._buildArgs([],$,"base64",Q),Z=await this._rpcRequest("getStakeMinimumDelegation",Y),J=D(Z,f(V()));if("error"in J)throw new w(J.error,"failed to get stake minimum delegation");return J.result}async simulateTransaction(X,$,Q){if("message"in X){let F=X.serialize(),j=I.from(F).toString("base64");if(Array.isArray($)||Q!==void 0)throw new Error("Invalid arguments");let E=$||{};if(E.encoding="base64",!("commitment"in E))E.commitment=this.commitment;if($&&typeof $==="object"&&"innerInstructions"in $)E.innerInstructions=$.innerInstructions;let p=[j,E],V0=await this._rpcRequest("simulateTransaction",p),I0=D(V0,$4);if("error"in I0)throw new Error("failed to simulate transaction: "+I0.error.message);return I0.result}let Y;if(X instanceof h){let C=X;Y=new h,Y.feePayer=C.feePayer,Y.instructions=X.instructions,Y.nonceInfo=C.nonceInfo,Y.signatures=C.signatures}else Y=h.populate(X),Y._message=Y._json=void 0;if($!==void 0&&!Array.isArray($))throw new Error("Invalid arguments");let Z=$;if(Y.nonceInfo&&Z)Y.sign(...Z);else{let C=this._disableBlockhashCaching;for(;;){let F=await this._blockhashWithExpiryBlockHeight(C);if(Y.lastValidBlockHeight=F.lastValidBlockHeight,Y.recentBlockhash=F.blockhash,!Z)break;if(Y.sign(...Z),!Y.signature)throw new Error("!signature");let j=Y.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(j)&&!this._blockhashInfo.transactionSignatures.includes(j)){this._blockhashInfo.simulatedSignatures.push(j);break}else C=!0}}let J=Y._compile(),M=J.serialize(),H=Y._serialize(M).toString("base64"),P={encoding:"base64",commitment:this.commitment};if(Q){let C=(Array.isArray(Q)?Q:J.nonProgramIds()).map((F)=>F.toBase58());P.accounts={encoding:"base64",addresses:C}}if(Z)P.sigVerify=!0;if($&&typeof $==="object"&&"innerInstructions"in $)P.innerInstructions=$.innerInstructions;let q=[H,P],N=await this._rpcRequest("simulateTransaction",q),z=D(N,$4);if("error"in z){let C;if("data"in z.error){if(C=z.error.data.logs,C&&Array.isArray(C)){let j=`
    `+C.join(`
    `);console.error(z.error.message,j)}}throw new v1({action:"simulate",signature:"",transactionMessage:z.error.message,logs:C})}return z.result}async sendTransaction(X,$,Q){if("version"in X){if($&&Array.isArray($))throw new Error("Invalid arguments");let J=X.serialize();return await this.sendRawTransaction(J,$)}if($===void 0||!Array.isArray($))throw new Error("Invalid arguments");let Y=$;if(X.nonceInfo)X.sign(...Y);else{let J=this._disableBlockhashCaching;for(;;){let M=await this._blockhashWithExpiryBlockHeight(J);if(X.lastValidBlockHeight=M.lastValidBlockHeight,X.recentBlockhash=M.blockhash,X.sign(...Y),!X.signature)throw new Error("!signature");let K=X.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(K)){this._blockhashInfo.transactionSignatures.push(K);break}else J=!0}}let Z=X.serialize();return await this.sendRawTransaction(Z,Q)}async sendRawTransaction(X,$){let Q=T(X).toString("base64");return await this.sendEncodedTransaction(Q,$)}async sendEncodedTransaction(X,$){let Q={encoding:"base64"},Y=$&&$.skipPreflight,Z=Y===!0?"processed":$&&$.preflightCommitment||this.commitment;if($&&$.maxRetries!=null)Q.maxRetries=$.maxRetries;if($&&$.minContextSlot!=null)Q.minContextSlot=$.minContextSlot;if(Y)Q.skipPreflight=Y;if(Z)Q.preflightCommitment=Z;let J=[X,Q],M=await this._rpcRequest("sendTransaction",J),K=D(M,cY);if("error"in K){let H=void 0;if("data"in K.error)H=K.error.data.logs;throw new v1({action:Y?"send":"simulate",signature:"",transactionMessage:K.error.message,logs:H})}return K.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5000),this._updateSubscriptions()}_wsOnError(X){this._rpcWebSocketConnected=!1,console.error("ws error:",X.message)}_wsOnClose(X){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout)clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null;if(this._rpcWebSocketHeartbeat)clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null;if(X===1000){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([$,Q])=>{this._setSubscription($,{...Q,state:"pending"})})}_setSubscription(X,$){let Q=this._subscriptionsByHash[X]?.state;if(this._subscriptionsByHash[X]=$,Q!==$.state){let Y=this._subscriptionStateChangeCallbacksByHash[X];if(Y)Y.forEach((Z)=>{try{Z($.state)}catch{}})}}_onSubscriptionStateChange(X,$){let Q=this._subscriptionHashByClientSubscriptionId[X];if(Q==null)return()=>{};let Y=this._subscriptionStateChangeCallbacksByHash[Q]||=new Set;return Y.add($),()=>{if(Y.delete($),Y.size===0)delete this._subscriptionStateChangeCallbacksByHash[Q]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){if(this._rpcWebSocketConnected)this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(Q){if(Q instanceof Error)console.log(`Error when closing socket connection: ${Q.message}`)}},500);return}if(this._rpcWebSocketIdleTimeout!==null)clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0;if(!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}let X=this._rpcWebSocketGeneration,$=()=>{return X===this._rpcWebSocketGeneration};await Promise.all(Object.keys(this._subscriptionsByHash).map(async(Q)=>{let Y=this._subscriptionsByHash[Q];if(Y===void 0)return;switch(Y.state){case"pending":case"unsubscribed":if(Y.callbacks.size===0){if(delete this._subscriptionsByHash[Q],Y.state==="unsubscribed")delete this._subscriptionCallbacksByServerSubscriptionId[Y.serverSubscriptionId];await this._updateSubscriptions();return}await(async()=>{let{args:Z,method:J}=Y;try{this._setSubscription(Q,{...Y,state:"subscribing"});let M=await this._rpcWebSocket.call(J,Z);this._setSubscription(Q,{...Y,serverSubscriptionId:M,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[M]=Y.callbacks,await this._updateSubscriptions()}catch(M){if(console.error(`Received ${M instanceof Error?"":"JSON-RPC "}error calling \`${J}\``,{args:Z,error:M}),!$())return;this._setSubscription(Q,{...Y,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":if(Y.callbacks.size===0)await(async()=>{let{serverSubscriptionId:Z,unsubscribeMethod:J}=Y;if(this._subscriptionsAutoDisposedByRpc.has(Z))this._subscriptionsAutoDisposedByRpc.delete(Z);else{this._setSubscription(Q,{...Y,state:"unsubscribing"}),this._setSubscription(Q,{...Y,state:"unsubscribing"});try{await this._rpcWebSocket.call(J,[Z])}catch(M){if(M instanceof Error)console.error(`${J} error:`,M.message);if(!$())return;this._setSubscription(Q,{...Y,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(Q,{...Y,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(X,$){let Q=this._subscriptionCallbacksByServerSubscriptionId[X];if(Q===void 0)return;Q.forEach((Y)=>{try{Y(...$)}catch(Z){console.error(Z)}})}_wsOnAccountNotification(X){let{result:$,subscription:Q}=D(X,WY);this._handleServerNotification(Q,[$.value,$.context])}_makeSubscription(X,$){let Q=this._nextClientSubscriptionId++,Y=t2([X.method,$]),Z=this._subscriptionsByHash[Y];if(Z===void 0)this._subscriptionsByHash[Y]={...X,args:$,callbacks:new Set([X.callback]),state:"pending"};else Z.callbacks.add(X.callback);return this._subscriptionHashByClientSubscriptionId[Q]=Y,this._subscriptionDisposeFunctionsByClientSubscriptionId[Q]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[Q],delete this._subscriptionHashByClientSubscriptionId[Q];let J=this._subscriptionsByHash[Y];m(J!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${Q}`),J.callbacks.delete(X.callback),await this._updateSubscriptions()},this._updateSubscriptions(),Q}onAccountChange(X,$,Q){let{commitment:Y,config:Z}=v(Q),J=this._buildArgs([X.toBase58()],Y||this._commitment||"finalized","base64",Z);return this._makeSubscription({callback:$,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},J)}async removeAccountChangeListener(X){await this._unsubscribeClientSubscription(X,"account change")}_wsOnProgramAccountNotification(X){let{result:$,subscription:Q}=D(X,zY);this._handleServerNotification(Q,[{accountId:$.value.pubkey,accountInfo:$.value.account},$.context])}onProgramAccountChange(X,$,Q,Y){let{commitment:Z,config:J}=v(Q),M=this._buildArgs([X.toBase58()],Z||this._commitment||"finalized","base64",J?J:Y?{filters:X4(Y)}:void 0);return this._makeSubscription({callback:$,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},M)}async removeProgramAccountChangeListener(X){await this._unsubscribeClientSubscription(X,"program account change")}onLogs(X,$,Q){let Y=this._buildArgs([typeof X==="object"?{mentions:[X.toString()]}:X],Q||this._commitment||"finalized");return this._makeSubscription({callback:$,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},Y)}async removeOnLogsListener(X){await this._unsubscribeClientSubscription(X,"logs")}_wsOnLogsNotification(X){let{result:$,subscription:Q}=D(X,uY);this._handleServerNotification(Q,[$.value,$.context])}_wsOnSlotNotification(X){let{result:$,subscription:Q}=D(X,AY);this._handleServerNotification(Q,[$])}onSlotChange(X){return this._makeSubscription({callback:X,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(X){await this._unsubscribeClientSubscription(X,"slot change")}_wsOnSlotUpdatesNotification(X){let{result:$,subscription:Q}=D(X,CY);this._handleServerNotification(Q,[$])}onSlotUpdate(X){return this._makeSubscription({callback:X,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(X){await this._unsubscribeClientSubscription(X,"slot update")}async _unsubscribeClientSubscription(X,$){let Q=this._subscriptionDisposeFunctionsByClientSubscriptionId[X];if(Q)await Q();else console.warn(`Ignored unsubscribe request because an active subscription with id \`${X}\` for '${$}' events could not be found.`)}_buildArgs(X,$,Q,Y){let Z=$||this._commitment;if(Z||Q||Y){let J={};if(Q)J.encoding=Q;if(Z)J.commitment=Z;if(Y)J=Object.assign(J,Y);X.push(J)}return X}_buildArgsAtLeastConfirmed(X,$,Q,Y){let Z=$||this._commitment;if(Z&&!["confirmed","finalized"].includes(Z))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(X,$,Q,Y)}_wsOnSignatureNotification(X){let{result:$,subscription:Q}=D(X,OY);if($.value!=="receivedSignature")this._subscriptionsAutoDisposedByRpc.add(Q);this._handleServerNotification(Q,$.value==="receivedSignature"?[{type:"received"},$.context]:[{type:"status",result:$.value},$.context])}onSignature(X,$,Q){let Y=this._buildArgs([X],Q||this._commitment||"finalized"),Z=this._makeSubscription({callback:(J,M)=>{if(J.type==="status"){$(J.result,M);try{this.removeSignatureListener(Z)}catch(K){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},Y);return Z}onSignatureWithOptions(X,$,Q){let{commitment:Y,...Z}={...Q,commitment:Q&&Q.commitment||this._commitment||"finalized"},J=this._buildArgs([X],Y,void 0,Z),M=this._makeSubscription({callback:(K,H)=>{$(K,H);try{this.removeSignatureListener(M)}catch(P){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},J);return M}async removeSignatureListener(X){await this._unsubscribeClientSubscription(X,"signature result")}_wsOnRootNotification(X){let{result:$,subscription:Q}=D(X,RY);this._handleServerNotification(Q,[$])}onRootChange(X){return this._makeSubscription({callback:X,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(X){await this._unsubscribeClientSubscription(X,"root change")}}class Z1{constructor(X){this._keypair=void 0,this._keypair=X??n2()}static generate(){return new Z1(n2())}static fromSecretKey(X,$){if(X.byteLength!==64)throw new Error("bad secret key size");let Q=X.slice(32,64);if(!$||!$.skipValidation){let Y=X.slice(0,32),Z=f8(Y);for(let J=0;J<32;J++)if(Q[J]!==Z[J])throw new Error("provided secretKey is invalid")}return new Z1({publicKey:Q,secretKey:X})}static fromSeed(X){let $=f8(X),Q=new Uint8Array(64);return Q.set(X),Q.set($,32),new Z1({publicKey:$,secretKey:Q})}get publicKey(){return new L(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}var Q1=Object.freeze({CreateLookupTable:{index:0,layout:G.struct([G.u32("instruction"),c0("recentSlot"),G.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:G.struct([G.u32("instruction")])},ExtendLookupTable:{index:2,layout:G.struct([G.u32("instruction"),c0(),G.seq(k(),G.offset(G.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:G.struct([G.u32("instruction")])},CloseLookupTable:{index:4,layout:G.struct([G.u32("instruction")])}});class g4{constructor(){}static createLookupTable(X){let[$,Q]=L.findProgramAddressSync([X.authority.toBuffer(),H1.toBufferLE(BigInt(X.recentSlot),8)],this.programId),Y=Q1.CreateLookupTable,Z=B(Y,{recentSlot:BigInt(X.recentSlot),bumpSeed:Q}),J=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:X.authority,isSigner:!0,isWritable:!1},{pubkey:X.payer,isSigner:!0,isWritable:!0},{pubkey:r.programId,isSigner:!1,isWritable:!1}];return[new b({programId:this.programId,keys:J,data:Z}),$]}static freezeLookupTable(X){let $=Q1.FreezeLookupTable,Q=B($),Y=[{pubkey:X.lookupTable,isSigner:!1,isWritable:!0},{pubkey:X.authority,isSigner:!0,isWritable:!1}];return new b({programId:this.programId,keys:Y,data:Q})}static extendLookupTable(X){let $=Q1.ExtendLookupTable,Q=B($,{addresses:X.addresses.map((Z)=>Z.toBytes())}),Y=[{pubkey:X.lookupTable,isSigner:!1,isWritable:!0},{pubkey:X.authority,isSigner:!0,isWritable:!1}];if(X.payer)Y.push({pubkey:X.payer,isSigner:!0,isWritable:!0},{pubkey:r.programId,isSigner:!1,isWritable:!1});return new b({programId:this.programId,keys:Y,data:Q})}static deactivateLookupTable(X){let $=Q1.DeactivateLookupTable,Q=B($),Y=[{pubkey:X.lookupTable,isSigner:!1,isWritable:!0},{pubkey:X.authority,isSigner:!0,isWritable:!1}];return new b({programId:this.programId,keys:Y,data:Q})}static closeLookupTable(X){let $=Q1.CloseLookupTable,Q=B($),Y=[{pubkey:X.lookupTable,isSigner:!1,isWritable:!0},{pubkey:X.authority,isSigner:!0,isWritable:!1},{pubkey:X.recipient,isSigner:!1,isWritable:!0}];return new b({programId:this.programId,keys:Y,data:Q})}}g4.programId=new L("AddressLookupTab1e1111111111111111111111111");var g1=Object.freeze({RequestUnits:{index:0,layout:G.struct([G.u8("instruction"),G.u32("units"),G.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:G.struct([G.u8("instruction"),G.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:G.struct([G.u8("instruction"),G.u32("units")])},SetComputeUnitPrice:{index:3,layout:G.struct([G.u8("instruction"),c0("microLamports")])}});class h4{constructor(){}static requestUnits(X){let $=g1.RequestUnits,Q=B($,X);return new b({keys:[],programId:this.programId,data:Q})}static requestHeapFrame(X){let $=g1.RequestHeapFrame,Q=B($,X);return new b({keys:[],programId:this.programId,data:Q})}static setComputeUnitLimit(X){let $=g1.SetComputeUnitLimit,Q=B($,X);return new b({keys:[],programId:this.programId,data:Q})}static setComputeUnitPrice(X){let $=g1.SetComputeUnitPrice,Q=B($,{microLamports:BigInt(X.microLamports)});return new b({keys:[],programId:this.programId,data:Q})}}h4.programId=new L("ComputeBudget111111111111111111111111111111");var Z4=64,J4=32,M4=64,K4=G.struct([G.u8("numSignatures"),G.u8("padding"),G.u16("signatureOffset"),G.u16("signatureInstructionIndex"),G.u16("publicKeyOffset"),G.u16("publicKeyInstructionIndex"),G.u16("messageDataOffset"),G.u16("messageDataSize"),G.u16("messageInstructionIndex")]);class t8{constructor(){}static createInstructionWithPublicKey(X){let{publicKey:$,message:Q,signature:Y,instructionIndex:Z}=X;m($.length===J4,`Public Key must be ${J4} bytes but received ${$.length} bytes`),m(Y.length===M4,`Signature must be ${M4} bytes but received ${Y.length} bytes`);let J=K4.span,M=J+$.length,K=M+Y.length,H=1,P=I.alloc(K+Q.length),q=Z==null?65535:Z;return K4.encode({numSignatures:H,padding:0,signatureOffset:M,signatureInstructionIndex:q,publicKeyOffset:J,publicKeyInstructionIndex:q,messageDataOffset:K,messageDataSize:Q.length,messageInstructionIndex:q},P),P.fill($,J),P.fill(Y,M),P.fill(Q,K),new b({keys:[],programId:t8.programId,data:P})}static createInstructionWithPrivateKey(X){let{privateKey:$,message:Q,instructionIndex:Y}=X;m($.length===Z4,`Private key must be ${Z4} bytes but received ${$.length} bytes`);try{let Z=Z1.fromSecretKey($),J=Z.publicKey.toBytes(),M=W4(Q,Z.secretKey);return this.createInstructionWithPublicKey({publicKey:J,message:Q,signature:M,instructionIndex:Y})}catch(Z){throw new Error(`Error creating instruction; ${Z}`)}}}t8.programId=new L("Ed25519SigVerify111111111111111111111111111");var oY=(X,$)=>{let Q=y1.sign(X,$);return[Q.toCompactRawBytes(),Q.recovery]};y1.utils.isValidPrivateKey;var aY=y1.getPublicKey,G4=32,v8=20,H4=64,sY=11,m8=G.struct([G.u8("numSignatures"),G.u16("signatureOffset"),G.u8("signatureInstructionIndex"),G.u16("ethAddressOffset"),G.u8("ethAddressInstructionIndex"),G.u16("messageDataOffset"),G.u16("messageDataSize"),G.u8("messageInstructionIndex"),G.blob(20,"ethAddress"),G.blob(64,"signature"),G.u8("recoveryId")]);class J1{constructor(){}static publicKeyToEthAddress(X){m(X.length===H4,`Public key must be ${H4} bytes but received ${X.length} bytes`);try{return I.from(y8(T(X))).slice(-v8)}catch($){throw new Error(`Error constructing Ethereum address: ${$}`)}}static createInstructionWithPublicKey(X){let{publicKey:$,message:Q,signature:Y,recoveryId:Z,instructionIndex:J}=X;return J1.createInstructionWithEthAddress({ethAddress:J1.publicKeyToEthAddress($),message:Q,signature:Y,recoveryId:Z,instructionIndex:J})}static createInstructionWithEthAddress(X){let{ethAddress:$,message:Q,signature:Y,recoveryId:Z,instructionIndex:J=0}=X,M;if(typeof $==="string")if($.startsWith("0x"))M=I.from($.substr(2),"hex");else M=I.from($,"hex");else M=$;m(M.length===v8,`Address must be ${v8} bytes but received ${M.length} bytes`);let K=1+sY,H=K,P=K+M.length,q=P+Y.length+1,N=1,z=I.alloc(m8.span+Q.length);return m8.encode({numSignatures:N,signatureOffset:P,signatureInstructionIndex:J,ethAddressOffset:H,ethAddressInstructionIndex:J,messageDataOffset:q,messageDataSize:Q.length,messageInstructionIndex:J,signature:T(Y),ethAddress:T(M),recoveryId:Z},z),z.fill(T(Q),m8.span),new b({keys:[],programId:J1.programId,data:z})}static createInstructionWithPrivateKey(X){let{privateKey:$,message:Q,instructionIndex:Y}=X;m($.length===G4,`Private key must be ${G4} bytes but received ${$.length} bytes`);try{let Z=T($),J=aY(Z,!1).slice(1),M=I.from(y8(T(Q))),[K,H]=oY(M,Z);return this.createInstructionWithPublicKey({publicKey:J,message:Q,signature:K,recoveryId:H,instructionIndex:Y})}catch(Z){throw new Error(`Error creating instruction; ${Z}`)}}}J1.programId=new L("KeccakSecp256k11111111111111111111111111111");var x4,rY=new L("StakeConfig11111111111111111111111111111111");class c1{constructor(X,$,Q){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=X,this.epoch=$,this.custodian=Q}}x4=c1;c1.default=new x4(0,0,L.default);var j0=Object.freeze({Initialize:{index:0,layout:G.struct([G.u32("instruction"),GQ(),HQ()])},Authorize:{index:1,layout:G.struct([G.u32("instruction"),k("newAuthorized"),G.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:G.struct([G.u32("instruction")])},Split:{index:3,layout:G.struct([G.u32("instruction"),G.ns64("lamports")])},Withdraw:{index:4,layout:G.struct([G.u32("instruction"),G.ns64("lamports")])},Deactivate:{index:5,layout:G.struct([G.u32("instruction")])},Merge:{index:7,layout:G.struct([G.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:G.struct([G.u32("instruction"),k("newAuthorized"),G.u32("stakeAuthorizationType"),p0("authoritySeed"),k("authorityOwner")])}}),GJ=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class e8{constructor(){}static initialize(X){let{stakePubkey:$,authorized:Q,lockup:Y}=X,Z=Y||c1.default,J=j0.Initialize,M=B(J,{authorized:{staker:T(Q.staker.toBuffer()),withdrawer:T(Q.withdrawer.toBuffer())},lockup:{unixTimestamp:Z.unixTimestamp,epoch:Z.epoch,custodian:T(Z.custodian.toBuffer())}}),K={keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:K1,isSigner:!1,isWritable:!1}],programId:this.programId,data:M};return new b(K)}static createAccountWithSeed(X){let $=new h;$.add(r.createAccountWithSeed({fromPubkey:X.fromPubkey,newAccountPubkey:X.stakePubkey,basePubkey:X.basePubkey,seed:X.seed,lamports:X.lamports,space:this.space,programId:this.programId}));let{stakePubkey:Q,authorized:Y,lockup:Z}=X;return $.add(this.initialize({stakePubkey:Q,authorized:Y,lockup:Z}))}static createAccount(X){let $=new h;$.add(r.createAccount({fromPubkey:X.fromPubkey,newAccountPubkey:X.stakePubkey,lamports:X.lamports,space:this.space,programId:this.programId}));let{stakePubkey:Q,authorized:Y,lockup:Z}=X;return $.add(this.initialize({stakePubkey:Q,authorized:Y,lockup:Z}))}static delegate(X){let{stakePubkey:$,authorizedPubkey:Q,votePubkey:Y}=X,Z=j0.Delegate,J=B(Z);return new h().add({keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Y,isSigner:!1,isWritable:!1},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:B8,isSigner:!1,isWritable:!1},{pubkey:rY,isSigner:!1,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}],programId:this.programId,data:J})}static authorize(X){let{stakePubkey:$,authorizedPubkey:Q,newAuthorizedPubkey:Y,stakeAuthorizationType:Z,custodianPubkey:J}=X,M=j0.Authorize,K=B(M,{newAuthorized:T(Y.toBuffer()),stakeAuthorizationType:Z.index}),H=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!0},{pubkey:Q,isSigner:!0,isWritable:!1}];if(J)H.push({pubkey:J,isSigner:!0,isWritable:!1});return new h().add({keys:H,programId:this.programId,data:K})}static authorizeWithSeed(X){let{stakePubkey:$,authorityBase:Q,authoritySeed:Y,authorityOwner:Z,newAuthorizedPubkey:J,stakeAuthorizationType:M,custodianPubkey:K}=X,H=j0.AuthorizeWithSeed,P=B(H,{newAuthorized:T(J.toBuffer()),stakeAuthorizationType:M.index,authoritySeed:Y,authorityOwner:T(Z.toBuffer())}),q=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Q,isSigner:!0,isWritable:!1},{pubkey:z0,isSigner:!1,isWritable:!1}];if(K)q.push({pubkey:K,isSigner:!0,isWritable:!1});return new h().add({keys:q,programId:this.programId,data:P})}static splitInstruction(X){let{stakePubkey:$,authorizedPubkey:Q,splitStakePubkey:Y,lamports:Z}=X,J=j0.Split,M=B(J,{lamports:Z});return new b({keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Y,isSigner:!1,isWritable:!0},{pubkey:Q,isSigner:!0,isWritable:!1}],programId:this.programId,data:M})}static split(X,$){let Q=new h;return Q.add(r.createAccount({fromPubkey:X.authorizedPubkey,newAccountPubkey:X.splitStakePubkey,lamports:$,space:this.space,programId:this.programId})),Q.add(this.splitInstruction(X))}static splitWithSeed(X,$){let{stakePubkey:Q,authorizedPubkey:Y,splitStakePubkey:Z,basePubkey:J,seed:M,lamports:K}=X,H=new h;if(H.add(r.allocate({accountPubkey:Z,basePubkey:J,seed:M,space:this.space,programId:this.programId})),$&&$>0)H.add(r.transfer({fromPubkey:X.authorizedPubkey,toPubkey:Z,lamports:$}));return H.add(this.splitInstruction({stakePubkey:Q,authorizedPubkey:Y,splitStakePubkey:Z,lamports:K}))}static merge(X){let{stakePubkey:$,sourceStakePubKey:Q,authorizedPubkey:Y}=X,Z=j0.Merge,J=B(Z);return new h().add({keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Q,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:B8,isSigner:!1,isWritable:!1},{pubkey:Y,isSigner:!0,isWritable:!1}],programId:this.programId,data:J})}static withdraw(X){let{stakePubkey:$,authorizedPubkey:Q,toPubkey:Y,lamports:Z,custodianPubkey:J}=X,M=j0.Withdraw,K=B(M,{lamports:Z}),H=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Y,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:B8,isSigner:!1,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}];if(J)H.push({pubkey:J,isSigner:!0,isWritable:!1});return new h().add({keys:H,programId:this.programId,data:K})}static deactivate(X){let{stakePubkey:$,authorizedPubkey:Q}=X,Y=j0.Deactivate,Z=B(Y);return new h().add({keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}],programId:this.programId,data:Z})}}e8.programId=new L("Stake11111111111111111111111111111111111111");e8.space=200;var Y1=Object.freeze({InitializeAccount:{index:0,layout:G.struct([G.u32("instruction"),VQ()])},Authorize:{index:1,layout:G.struct([G.u32("instruction"),k("newAuthorized"),G.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:G.struct([G.u32("instruction"),G.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:G.struct([G.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:G.struct([G.u32("instruction"),PQ()])}}),HJ=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class l1{constructor(){}static initializeAccount(X){let{votePubkey:$,nodePubkey:Q,voteInit:Y}=X,Z=Y1.InitializeAccount,J=B(Z,{voteInit:{nodePubkey:T(Y.nodePubkey.toBuffer()),authorizedVoter:T(Y.authorizedVoter.toBuffer()),authorizedWithdrawer:T(Y.authorizedWithdrawer.toBuffer()),commission:Y.commission}}),M={keys:[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:K1,isSigner:!1,isWritable:!1},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}],programId:this.programId,data:J};return new b(M)}static createAccount(X){let $=new h;return $.add(r.createAccount({fromPubkey:X.fromPubkey,newAccountPubkey:X.votePubkey,lamports:X.lamports,space:this.space,programId:this.programId})),$.add(this.initializeAccount({votePubkey:X.votePubkey,nodePubkey:X.voteInit.nodePubkey,voteInit:X.voteInit}))}static authorize(X){let{votePubkey:$,authorizedPubkey:Q,newAuthorizedPubkey:Y,voteAuthorizationType:Z}=X,J=Y1.Authorize,M=B(J,{newAuthorized:T(Y.toBuffer()),voteAuthorizationType:Z.index}),K=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}];return new h().add({keys:K,programId:this.programId,data:M})}static authorizeWithSeed(X){let{currentAuthorityDerivedKeyBasePubkey:$,currentAuthorityDerivedKeyOwnerPubkey:Q,currentAuthorityDerivedKeySeed:Y,newAuthorizedPubkey:Z,voteAuthorizationType:J,votePubkey:M}=X,K=Y1.AuthorizeWithSeed,H=B(K,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:T(Q.toBuffer()),currentAuthorityDerivedKeySeed:Y,newAuthorized:T(Z.toBuffer()),voteAuthorizationType:J.index}}),P=[{pubkey:M,isSigner:!1,isWritable:!0},{pubkey:z0,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!0,isWritable:!1}];return new h().add({keys:P,programId:this.programId,data:H})}static withdraw(X){let{votePubkey:$,authorizedWithdrawerPubkey:Q,lamports:Y,toPubkey:Z}=X,J=Y1.Withdraw,M=B(J,{lamports:Y}),K=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Z,isSigner:!1,isWritable:!0},{pubkey:Q,isSigner:!0,isWritable:!1}];return new h().add({keys:K,programId:this.programId,data:M})}static safeWithdraw(X,$,Q){if(X.lamports>$-Q)throw new Error("Withdraw will leave vote account with insufficient funds.");return l1.withdraw(X)}static updateValidatorIdentity(X){let{votePubkey:$,authorizedWithdrawerPubkey:Q,nodePubkey:Y}=X,Z=Y1.UpdateValidatorIdentity,J=B(Z),M=[{pubkey:$,isSigner:!1,isWritable:!0},{pubkey:Y,isSigner:!0,isWritable:!1},{pubkey:Q,isSigner:!0,isWritable:!1}];return new h().add({keys:M,programId:this.programId,data:J})}}l1.programId=new L("Vote111111111111111111111111111111111111111");l1.space=3762;var VJ=new L("Va1idator1nfo111111111111111111111111111111"),PJ=W({name:A(),website:U(A()),details:U(A()),iconUrl:U(A()),keybaseUsername:U(A())});var WJ=new L("Vote111111111111111111111111111111111111111"),qJ=G.struct([k("nodePubkey"),k("authorizedWithdrawer"),G.u8("commission"),G.nu64(),G.seq(G.struct([G.nu64("slot"),G.u32("confirmationCount")]),G.offset(G.u32(),-8),"votes"),G.u8("rootSlotValid"),G.nu64("rootSlot"),G.nu64(),G.seq(G.struct([G.nu64("epoch"),k("authorizedVoter")]),G.offset(G.u32(),-8),"authorizedVoters"),G.struct([G.seq(G.struct([k("authorizedPubkey"),G.nu64("epochOfLastAuthorizedSwitch"),G.nu64("targetEpoch")]),32,"buf"),G.nu64("idx"),G.u8("isEmpty")],"priorVoters"),G.nu64(),G.seq(G.struct([G.nu64("epoch"),G.nu64("credits"),G.nu64("prevCredits")]),G.offset(G.u32(),-8),"epochCredits"),G.struct([G.nu64("slot"),G.nu64("timestamp")],"lastTimestamp")]);
export{r$ as ve,D8 as we,F2 as xe,L as ye,b as ze,h as Ae,a2 as Be,r as Ce,iY as De,Z1 as Ee};

//# debugId=8200D5AD1FBFF0C764756E2164756E21
