import{eg as E}from"./chunk-g7j062ka.js";var b=E((l)=>{Object.defineProperty(l,"__esModule",{value:!0});l.utf8Write=l.utf8Read=l.utf8Length=void 0;function FU(U){let q=0,G=0;for(let J=0;J<U.length;++J)if(G=U.charCodeAt(J),G<128)q+=1;else if(G<2048)q+=2;else if((G&64512)===55296&&(U.charCodeAt(J+1)&64512)===56320)++J,q+=4;else q+=3;return q}l.utf8Length=FU;function kU(U,q,G){if(G-q<1)return"";let H=[],K=[],Q=0,$;while(q<G){if($=U[q++],$<128)H[Q++]=$;else if($>191&&$<224)H[Q++]=($&31)<<6|U[q++]&63;else if($>239&&$<365)$=(($&7)<<18|(U[q++]&63)<<12|(U[q++]&63)<<6|U[q++]&63)-65536,H[Q++]=55296+($>>10),H[Q++]=56320+($&1023);else H[Q++]=($&15)<<12|(U[q++]&63)<<6|U[q++]&63;if(Q>8191)(K||(K=[])).push(String.fromCharCode(...H)),Q=0}if(K){if(Q)K.push(String.fromCharCode(...H.slice(0,Q)));return K.join("")}return String.fromCharCode(...H.slice(0,Q))}l.utf8Read=kU;function ZU(U,q,G){let J=G,H,K;for(let Q=0;Q<U.length;++Q)if(H=U.charCodeAt(Q),H<128)q[G++]=H;else if(H<2048)q[G++]=H>>6|192,q[G++]=H&63|128;else if((H&64512)===55296&&((K=U.charCodeAt(Q+1))&64512)===56320)H=65536+((H&1023)<<10)+(K&1023),++Q,q[G++]=H>>18|240,q[G++]=H>>12&63|128,q[G++]=H>>6&63|128,q[G++]=H&63|128;else q[G++]=H>>12|224,q[G++]=H>>6&63|128,q[G++]=H&63|128;return G-J}l.utf8Write=ZU});var s=E((a)=>{Object.defineProperty(a,"__esModule",{value:!0});a.writeByte=a.writeFixed32=a.int64Length=a.writeVarint64=a.writeVarint32=a.readInt32=a.readUInt32=a.zzDecode=a.zzEncode=a.varint32read=a.varint32write=a.uInt64ToString=a.int64ToString=a.int64FromString=a.varint64write=a.varint64read=void 0;function RU(){let U=0,q=0;for(let J=0;J<28;J+=7){let H=this.buf[this.pos++];if(U|=(H&127)<<J,(H&128)==0)return this.assertBounds(),[U,q]}let G=this.buf[this.pos++];if(U|=(G&15)<<28,q=(G&112)>>4,(G&128)==0)return this.assertBounds(),[U,q];for(let J=3;J<=31;J+=7){let H=this.buf[this.pos++];if(q|=(H&127)<<J,(H&128)==0)return this.assertBounds(),[U,q]}throw new Error("invalid varint")}a.varint64read=RU;function LU(U,q,G){for(let K=0;K<28;K=K+7){let Q=U>>>K,$=!(Q>>>7==0&&q==0),A=($?Q|128:Q)&255;if(G.push(A),!$)return}let J=U>>>28&15|(q&7)<<4,H=q>>3!=0;if(G.push((H?J|128:J)&255),!H)return;for(let K=3;K<31;K=K+7){let Q=q>>>K,$=Q>>>7!=0,A=($?Q|128:Q)&255;if(G.push(A),!$)return}G.push(q>>>31&1)}a.varint64write=LU;var W=4294967296;function OU(U){let q=U[0]==="-";if(q)U=U.slice(1);let G=1e6,J=0,H=0;function K(Q,$){let A=Number(U.slice(Q,$));if(H*=G,J=J*G+A,J>=W)H=H+(J/W|0),J=J%W}return K(-24,-18),K(-18,-12),K(-12,-6),K(-6),q?r(J,H):_(J,H)}a.int64FromString=OU;function DU(U,q){let G=_(U,q),J=G.hi&2147483648;if(J)G=r(G.lo,G.hi);let H=o(G.lo,G.hi);return J?"-"+H:H}a.int64ToString=DU;function o(U,q){if({lo:U,hi:q}=zU(U,q),q<=2097151)return String(W*q+U);let G=U&16777215,J=(U>>>24|q<<8)&16777215,H=q>>16&65535,K=G+J*6777216+H*6710656,Q=J+H*8147497,$=H*2,A=1e7;if(K>=A)Q+=Math.floor(K/A),K%=A;if(Q>=A)$+=Math.floor(Q/A),Q%=A;return $.toString()+n(Q)+n(K)}a.uInt64ToString=o;function zU(U,q){return{lo:U>>>0,hi:q>>>0}}function _(U,q){return{lo:U|0,hi:q|0}}function r(U,q){if(q=~q,U)U=~U+1;else q+=1;return _(U,q)}var n=(U)=>{let q=String(U);return"0000000".slice(q.length)+q};function MU(U,q){if(U>=0){while(U>127)q.push(U&127|128),U=U>>>7;q.push(U)}else{for(let G=0;G<9;G++)q.push(U&127|128),U=U>>7;q.push(1)}}a.varint32write=MU;function WU(){let U=this.buf[this.pos++],q=U&127;if((U&128)==0)return this.assertBounds(),q;if(U=this.buf[this.pos++],q|=(U&127)<<7,(U&128)==0)return this.assertBounds(),q;if(U=this.buf[this.pos++],q|=(U&127)<<14,(U&128)==0)return this.assertBounds(),q;if(U=this.buf[this.pos++],q|=(U&127)<<21,(U&128)==0)return this.assertBounds(),q;U=this.buf[this.pos++],q|=(U&15)<<28;for(let G=5;(U&128)!==0&&G<10;G++)U=this.buf[this.pos++];if((U&128)!=0)throw new Error("invalid varint");return this.assertBounds(),q>>>0}a.varint32read=WU;function xU(U,q){let G=q>>31;return q=((q<<1|U>>>31)^G)>>>0,U=(U<<1^G)>>>0,[U,q]}a.zzEncode=xU;function SU(U,q){let G=-(U&1);return U=((U>>>1|q<<31)^G)>>>0,q=(q>>>1^G)>>>0,[U,q]}a.zzDecode=SU;function TU(U,q){return(U[q]|U[q+1]<<8|U[q+2]<<16)+U[q+3]*16777216}a.readUInt32=TU;function _U(U,q){return(U[q]|U[q+1]<<8|U[q+2]<<16)+(U[q+3]<<24)}a.readInt32=_U;function yU(U,q,G){while(U>127)q[G++]=U&127|128,U>>>=7;q[G]=U}a.writeVarint32=yU;function wU(U,q,G){while(U.hi)q[G++]=U.lo&127|128,U.lo=(U.lo>>>7|U.hi<<25)>>>0,U.hi>>>=7;while(U.lo>127)q[G++]=U.lo&127|128,U.lo=U.lo>>>7;q[G++]=U.lo}a.writeVarint64=wU;function BU(U,q){let G=U,J=(U>>>28|q<<4)>>>0,H=q>>>24;return H===0?J===0?G<16384?G<128?1:2:G<2097152?3:4:J<16384?J<128?5:6:J<2097152?7:8:H<128?9:10}a.int64Length=BU;function vU(U,q,G){q[G]=U&255,q[G+1]=U>>>8&255,q[G+2]=U>>>16&255,q[G+3]=U>>>24}a.writeFixed32=vU;function jU(U,q,G){q[G]=U&255}a.writeByte=jU});var x=E((qU)=>{Object.defineProperty(qU,"__esModule",{value:!0});qU.BinaryWriter=qU.BinaryReader=qU.WireType=void 0;var y=b(),Y=s(),I;(function(U){U[U.Varint=0]="Varint",U[U.Fixed64=1]="Fixed64",U[U.Bytes=2]="Bytes",U[U.Fixed32=5]="Fixed32"})(I||(qU.WireType=I={}));class e{assertBounds(){if(this.pos>this.len)throw new RangeError("premature EOF")}constructor(U){this.buf=U?new Uint8Array(U):new Uint8Array(0),this.pos=0,this.type=0,this.len=this.buf.length}tag(){let U=this.uint32(),q=U>>>3,G=U&7;if(q<=0||G<0||G>5)throw new Error("illegal tag: field no "+q+" wire type "+G);return[q,G,U]}skip(U){if(typeof U==="number"){if(this.pos+U>this.len)throw t(this,U);this.pos+=U}else do if(this.pos>=this.len)throw t(this);while(this.buf[this.pos++]&128);return this}skipType(U){switch(U){case I.Varint:this.skip();break;case I.Fixed64:this.skip(8);break;case I.Bytes:this.skip(this.uint32());break;case 3:while((U=this.uint32()&7)!==4)this.skipType(U);break;case I.Fixed32:this.skip(4);break;default:throw Error("invalid wire type "+U+" at offset "+this.pos)}return this}uint32(){return Y.varint32read.bind(this)()}int32(){return this.uint32()|0}sint32(){let U=this.uint32();return U%2===1?(U+1)/-2:U/2}fixed32(){let U=Y.readUInt32(this.buf,this.pos);return this.pos+=4,U}sfixed32(){let U=Y.readInt32(this.buf,this.pos);return this.pos+=4,U}int64(){let[U,q]=Y.varint64read.bind(this)();return BigInt(Y.int64ToString(U,q))}uint64(){let[U,q]=Y.varint64read.bind(this)();return BigInt(Y.uInt64ToString(U,q))}sint64(){let[U,q]=Y.varint64read.bind(this)();return[U,q]=Y.zzDecode(U,q),BigInt(Y.int64ToString(U,q))}fixed64(){let U=this.sfixed32(),q=this.sfixed32();return BigInt(Y.uInt64ToString(U,q))}sfixed64(){let U=this.sfixed32(),q=this.sfixed32();return BigInt(Y.int64ToString(U,q))}float(){throw new Error("float not supported")}double(){throw new Error("double not supported")}bool(){let[U,q]=Y.varint64read.bind(this)();return U!==0||q!==0}bytes(){let U=this.uint32(),q=this.pos;return this.pos+=U,this.assertBounds(),this.buf.subarray(q,q+U)}string(){let U=this.bytes();return y.utf8Read(U,0,U.length)}}qU.BinaryReader=e;class Z{constructor(U,q,G){this.fn=U,this.len=q,this.val=G}proceed(U,q){if(this.fn)this.fn(this.val,U,q)}}class UU{constructor(U){this.head=U.head,this.tail=U.tail,this.len=U.len,this.next=U.states}}class F{constructor(){this.len=0,this.uint64=F.prototype.int64,this.sfixed64=F.prototype.fixed64,this.sfixed32=F.prototype.fixed32,this.head=new Z(null,0,0),this.tail=this.head,this.states=null}static create(){return new F}static alloc(U){if(typeof Uint8Array!=="undefined")return tU((q)=>new Uint8Array(q),Uint8Array.prototype.subarray)(U);else return new Array(U)}_push(U,q,G){return this.tail=this.tail.next=new Z(U,q,G),this.len+=q,this}finish(){let U=this.head.next,q=0,G=F.alloc(this.len);while(U)U.proceed(G,q),q+=U.len,U=U.next;return G}fork(){return this.states=new UU(this),this.head=this.tail=new Z(null,0,0),this.len=0,this}reset(){if(this.states)this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next;else this.head=this.tail=new Z(null,0,0),this.len=0;return this}ldelim(){let U=this.head,q=this.tail,G=this.len;if(this.reset().uint32(G),G)this.tail.next=U.next,this.tail=q,this.len+=G;return this}tag(U,q){return this.uint32((U<<3|q)>>>0)}uint32(U){return this.len+=(this.tail=this.tail.next=new Z(Y.writeVarint32,(U=U>>>0)<128?1:U<16384?2:U<2097152?3:U<268435456?4:5,U)).len,this}int32(U){return U<0?this._push(Y.writeVarint64,10,Y.int64FromString(U.toString())):this.uint32(U)}sint32(U){return this.uint32((U<<1^U>>31)>>>0)}int64(U){let{lo:q,hi:G}=Y.int64FromString(U.toString());return this._push(Y.writeVarint64,Y.int64Length(q,G),{lo:q,hi:G})}sint64(U){let{lo:q,hi:G}=Y.int64FromString(U.toString());return[q,G]=Y.zzEncode(q,G),this._push(Y.writeVarint64,Y.int64Length(q,G),{lo:q,hi:G})}fixed64(U){let{lo:q,hi:G}=Y.int64FromString(U.toString());return this._push(Y.writeFixed32,4,q)._push(Y.writeFixed32,4,G)}bool(U){return this._push(Y.writeByte,1,U?1:0)}fixed32(U){return this._push(Y.writeFixed32,4,U>>>0)}float(U){throw new Error("float not supported"+U)}double(U){throw new Error("double not supported"+U)}bytes(U){let q=U.length>>>0;if(!q)return this._push(Y.writeByte,1,0);return this.uint32(q)._push(sU,q,U)}string(U){let q=y.utf8Length(U);return q?this.uint32(q)._push(y.utf8Write,q,U):this._push(Y.writeByte,1,0)}}qU.BinaryWriter=F;function sU(U,q,G){if(typeof Uint8Array!=="undefined")q.set(U,G);else for(let J=0;J<U.length;++J)q[G+J]=U[J]}function tU(U,q,G){let J=G||8192,H=J>>>1,K=null,Q=J;return function $(A){if(A<1||A>H)return U(A);if(Q+A>J)K=U(J),Q=0;let EU=q.call(K,Q,Q+=A);if(Q&7)Q=(Q|7)+1;return EU}}function t(U,q){return RangeError("index out of range: "+U.pos+" + "+(q||1)+" > "+U.len)}});var S=E((HU)=>{Object.defineProperty(HU,"__esModule",{value:!0});HU.fromJsonTimestamp=HU.fromTimestamp=HU.toTimestamp=HU.setPaginationParams=HU.isObject=HU.isSet=HU.fromDuration=HU.toDuration=HU.omitDefault=HU.base64FromBytes=HU.bytesFromBase64=void 0;var N=(()=>{if(typeof N!=="undefined")return N;if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw"Unable to locate global object"})(),q1=N.atob||((U)=>N.Buffer.from(U,"base64").toString("binary"));function G1(U){let q=q1(U),G=new Uint8Array(q.length);for(let J=0;J<q.length;++J)G[J]=q.charCodeAt(J);return G}HU.bytesFromBase64=G1;var H1=N.btoa||((U)=>N.Buffer.from(U,"binary").toString("base64"));function J1(U){let q=[];return U.forEach((G)=>{q.push(String.fromCharCode(G))}),H1(q.join(""))}HU.base64FromBytes=J1;function K1(U){if(typeof U==="string")return U===""?void 0:U;if(typeof U==="number")return U===0?void 0:U;if(typeof U==="bigint")return U===BigInt(0)?void 0:U;throw new Error(`Got unsupported type ${typeof U}`)}HU.omitDefault=K1;function Q1(U){return{seconds:BigInt(Math.floor(parseInt(U)/1e9)),nanos:parseInt(U)%1e9}}HU.toDuration=Q1;function Y1(U){return(parseInt(U.seconds.toString())*1e9+U.nanos).toString()}HU.fromDuration=Y1;function w(U){return U!==null&&U!==void 0}HU.isSet=w;function $1(U){return typeof U==="object"&&U!==null}HU.isObject=$1;var A1=(U,q)=>{if(!q)return U;if(typeof q?.countTotal!=="undefined")U.params["pagination.count_total"]=q.countTotal;if(typeof q?.key!=="undefined")U.params["pagination.key"]=Buffer.from(q.key).toString("base64");if(typeof q?.limit!=="undefined")U.params["pagination.limit"]=q.limit.toString();if(typeof q?.offset!=="undefined")U.params["pagination.offset"]=q.offset.toString();if(typeof q?.reverse!=="undefined")U.params["pagination.reverse"]=q.reverse;return U};HU.setPaginationParams=A1;function B(U){let q=C1(U.getTime()/1000),G=U.getTime()%1000*1e6;return{seconds:q,nanos:G}}HU.toTimestamp=B;function X1(U){let q=Number(U.seconds)*1000;return q+=U.nanos/1e6,new Date(q)}HU.fromTimestamp=X1;var P1=(U)=>{return{seconds:w(U.seconds)?BigInt(U.seconds.toString()):BigInt(0),nanos:w(U.nanos)?Number(U.nanos):0}};function V1(U){if(U instanceof Date)return B(U);else if(typeof U==="string")return B(new Date(U));else return P1(U)}HU.fromJsonTimestamp=V1;function C1(U){return BigInt(Math.trunc(U))}});var YU=E((KU)=>{Object.defineProperty(KU,"__esModule",{value:!0});KU.CompactBitArray=KU.MultiSignature=KU.protobufPackage=void 0;var L=x(),R=S();KU.protobufPackage="cosmos.crypto.multisig.v1beta1";function v(){return{signatures:[]}}KU.MultiSignature={typeUrl:"/cosmos.crypto.multisig.v1beta1.MultiSignature",encode(U,q=L.BinaryWriter.create()){for(let G of U.signatures)q.uint32(10).bytes(G);return q},decode(U,q){let G=U instanceof L.BinaryReader?U:new L.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=v();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.signatures.push(G.bytes());break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=v();if(Array.isArray(U?.signatures))q.signatures=U.signatures.map((G)=>R.bytesFromBase64(G));return q},toJSON(U){let q={};if(U.signatures)q.signatures=U.signatures.map((G)=>R.base64FromBytes(G!==void 0?G:new Uint8Array));else q.signatures=[];return q},fromPartial(U){let q=v();return q.signatures=U.signatures?.map((G)=>G)||[],q}};function j(){return{extraBitsStored:0,elems:new Uint8Array}}KU.CompactBitArray={typeUrl:"/cosmos.crypto.multisig.v1beta1.CompactBitArray",encode(U,q=L.BinaryWriter.create()){if(U.extraBitsStored!==0)q.uint32(8).uint32(U.extraBitsStored);if(U.elems.length!==0)q.uint32(18).bytes(U.elems);return q},decode(U,q){let G=U instanceof L.BinaryReader?U:new L.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=j();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.extraBitsStored=G.uint32();break;case 2:H.elems=G.bytes();break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=j();if(R.isSet(U.extraBitsStored))q.extraBitsStored=Number(U.extraBitsStored);if(R.isSet(U.elems))q.elems=R.bytesFromBase64(U.elems);return q},toJSON(U){let q={};return U.extraBitsStored!==void 0&&(q.extraBitsStored=Math.round(U.extraBitsStored)),U.elems!==void 0&&(q.elems=R.base64FromBytes(U.elems!==void 0?U.elems:new Uint8Array)),q},fromPartial(U){let q=j();return q.extraBitsStored=U.extraBitsStored??0,q.elems=U.elems??new Uint8Array,q}}});var XU=E(($U)=>{Object.defineProperty($U,"__esModule",{value:!0});$U.Any=$U.protobufPackage=void 0;var d=x(),T=S();$U.protobufPackage="google.protobuf";function c(){return{typeUrl:"",value:new Uint8Array}}$U.Any={typeUrl:"/google.protobuf.Any",encode(U,q=d.BinaryWriter.create()){if(U.typeUrl!=="")q.uint32(10).string(U.typeUrl);if(U.value.length!==0)q.uint32(18).bytes(U.value);return q},decode(U,q){let G=U instanceof d.BinaryReader?U:new d.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=c();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.typeUrl=G.string();break;case 2:H.value=G.bytes();break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=c();if(T.isSet(U.typeUrl))q.typeUrl=String(U.typeUrl);if(T.isSet(U.value))q.value=T.bytesFromBase64(U.value);return q},toJSON(U){let q={};return U.typeUrl!==void 0&&(q.typeUrl=U.typeUrl),U.value!==void 0&&(q.value=T.base64FromBytes(U.value!==void 0?U.value:new Uint8Array)),q},fromPartial(U){let q=c();return q.typeUrl=U.typeUrl??"",q.value=U.value??new Uint8Array,q}}});var w1=E((CU)=>{Object.defineProperty(CU,"__esModule",{value:!0});CU.SignatureDescriptor_Data_Multi=CU.SignatureDescriptor_Data_Single=CU.SignatureDescriptor_Data=CU.SignatureDescriptor=CU.SignatureDescriptors=CU.signModeToJSON=CU.signModeFromJSON=CU.SignMode=CU.protobufPackage=void 0;var z=YU(),M=XU(),P=x(),C=S();CU.protobufPackage="cosmos.tx.signing.v1beta1";var X;(function(U){U[U.SIGN_MODE_UNSPECIFIED=0]="SIGN_MODE_UNSPECIFIED",U[U.SIGN_MODE_DIRECT=1]="SIGN_MODE_DIRECT",U[U.SIGN_MODE_TEXTUAL=2]="SIGN_MODE_TEXTUAL",U[U.SIGN_MODE_DIRECT_AUX=3]="SIGN_MODE_DIRECT_AUX",U[U.SIGN_MODE_LEGACY_AMINO_JSON=127]="SIGN_MODE_LEGACY_AMINO_JSON",U[U.SIGN_MODE_EIP_191=191]="SIGN_MODE_EIP_191",U[U.UNRECOGNIZED=-1]="UNRECOGNIZED"})(X||(CU.SignMode=X={}));function PU(U){switch(U){case 0:case"SIGN_MODE_UNSPECIFIED":return X.SIGN_MODE_UNSPECIFIED;case 1:case"SIGN_MODE_DIRECT":return X.SIGN_MODE_DIRECT;case 2:case"SIGN_MODE_TEXTUAL":return X.SIGN_MODE_TEXTUAL;case 3:case"SIGN_MODE_DIRECT_AUX":return X.SIGN_MODE_DIRECT_AUX;case 127:case"SIGN_MODE_LEGACY_AMINO_JSON":return X.SIGN_MODE_LEGACY_AMINO_JSON;case 191:case"SIGN_MODE_EIP_191":return X.SIGN_MODE_EIP_191;case-1:case"UNRECOGNIZED":default:return X.UNRECOGNIZED}}CU.signModeFromJSON=PU;function VU(U){switch(U){case X.SIGN_MODE_UNSPECIFIED:return"SIGN_MODE_UNSPECIFIED";case X.SIGN_MODE_DIRECT:return"SIGN_MODE_DIRECT";case X.SIGN_MODE_TEXTUAL:return"SIGN_MODE_TEXTUAL";case X.SIGN_MODE_DIRECT_AUX:return"SIGN_MODE_DIRECT_AUX";case X.SIGN_MODE_LEGACY_AMINO_JSON:return"SIGN_MODE_LEGACY_AMINO_JSON";case X.SIGN_MODE_EIP_191:return"SIGN_MODE_EIP_191";case X.UNRECOGNIZED:default:return"UNRECOGNIZED"}}CU.signModeToJSON=VU;function h(){return{signatures:[]}}CU.SignatureDescriptors={typeUrl:"/cosmos.tx.signing.v1beta1.SignatureDescriptors",encode(U,q=P.BinaryWriter.create()){for(let G of U.signatures)CU.SignatureDescriptor.encode(G,q.uint32(10).fork()).ldelim();return q},decode(U,q){let G=U instanceof P.BinaryReader?U:new P.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=h();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.signatures.push(CU.SignatureDescriptor.decode(G,G.uint32()));break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=h();if(Array.isArray(U?.signatures))q.signatures=U.signatures.map((G)=>CU.SignatureDescriptor.fromJSON(G));return q},toJSON(U){let q={};if(U.signatures)q.signatures=U.signatures.map((G)=>G?CU.SignatureDescriptor.toJSON(G):void 0);else q.signatures=[];return q},fromPartial(U){let q=h();return q.signatures=U.signatures?.map((G)=>CU.SignatureDescriptor.fromPartial(G))||[],q}};function f(){return{publicKey:void 0,data:void 0,sequence:BigInt(0)}}CU.SignatureDescriptor={typeUrl:"/cosmos.tx.signing.v1beta1.SignatureDescriptor",encode(U,q=P.BinaryWriter.create()){if(U.publicKey!==void 0)M.Any.encode(U.publicKey,q.uint32(10).fork()).ldelim();if(U.data!==void 0)CU.SignatureDescriptor_Data.encode(U.data,q.uint32(18).fork()).ldelim();if(U.sequence!==BigInt(0))q.uint32(24).uint64(U.sequence);return q},decode(U,q){let G=U instanceof P.BinaryReader?U:new P.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=f();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.publicKey=M.Any.decode(G,G.uint32());break;case 2:H.data=CU.SignatureDescriptor_Data.decode(G,G.uint32());break;case 3:H.sequence=G.uint64();break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=f();if(C.isSet(U.publicKey))q.publicKey=M.Any.fromJSON(U.publicKey);if(C.isSet(U.data))q.data=CU.SignatureDescriptor_Data.fromJSON(U.data);if(C.isSet(U.sequence))q.sequence=BigInt(U.sequence.toString());return q},toJSON(U){let q={};return U.publicKey!==void 0&&(q.publicKey=U.publicKey?M.Any.toJSON(U.publicKey):void 0),U.data!==void 0&&(q.data=U.data?CU.SignatureDescriptor_Data.toJSON(U.data):void 0),U.sequence!==void 0&&(q.sequence=(U.sequence||BigInt(0)).toString()),q},fromPartial(U){let q=f();if(U.publicKey!==void 0&&U.publicKey!==null)q.publicKey=M.Any.fromPartial(U.publicKey);if(U.data!==void 0&&U.data!==null)q.data=CU.SignatureDescriptor_Data.fromPartial(U.data);if(U.sequence!==void 0&&U.sequence!==null)q.sequence=BigInt(U.sequence.toString());return q}};function m(){return{single:void 0,multi:void 0}}CU.SignatureDescriptor_Data={typeUrl:"/cosmos.tx.signing.v1beta1.Data",encode(U,q=P.BinaryWriter.create()){if(U.single!==void 0)CU.SignatureDescriptor_Data_Single.encode(U.single,q.uint32(10).fork()).ldelim();if(U.multi!==void 0)CU.SignatureDescriptor_Data_Multi.encode(U.multi,q.uint32(18).fork()).ldelim();return q},decode(U,q){let G=U instanceof P.BinaryReader?U:new P.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=m();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.single=CU.SignatureDescriptor_Data_Single.decode(G,G.uint32());break;case 2:H.multi=CU.SignatureDescriptor_Data_Multi.decode(G,G.uint32());break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=m();if(C.isSet(U.single))q.single=CU.SignatureDescriptor_Data_Single.fromJSON(U.single);if(C.isSet(U.multi))q.multi=CU.SignatureDescriptor_Data_Multi.fromJSON(U.multi);return q},toJSON(U){let q={};return U.single!==void 0&&(q.single=U.single?CU.SignatureDescriptor_Data_Single.toJSON(U.single):void 0),U.multi!==void 0&&(q.multi=U.multi?CU.SignatureDescriptor_Data_Multi.toJSON(U.multi):void 0),q},fromPartial(U){let q=m();if(U.single!==void 0&&U.single!==null)q.single=CU.SignatureDescriptor_Data_Single.fromPartial(U.single);if(U.multi!==void 0&&U.multi!==null)q.multi=CU.SignatureDescriptor_Data_Multi.fromPartial(U.multi);return q}};function u(){return{mode:0,signature:new Uint8Array}}CU.SignatureDescriptor_Data_Single={typeUrl:"/cosmos.tx.signing.v1beta1.Single",encode(U,q=P.BinaryWriter.create()){if(U.mode!==0)q.uint32(8).int32(U.mode);if(U.signature.length!==0)q.uint32(18).bytes(U.signature);return q},decode(U,q){let G=U instanceof P.BinaryReader?U:new P.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=u();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.mode=G.int32();break;case 2:H.signature=G.bytes();break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=u();if(C.isSet(U.mode))q.mode=PU(U.mode);if(C.isSet(U.signature))q.signature=C.bytesFromBase64(U.signature);return q},toJSON(U){let q={};return U.mode!==void 0&&(q.mode=VU(U.mode)),U.signature!==void 0&&(q.signature=C.base64FromBytes(U.signature!==void 0?U.signature:new Uint8Array)),q},fromPartial(U){let q=u();return q.mode=U.mode??0,q.signature=U.signature??new Uint8Array,q}};function p(){return{bitarray:void 0,signatures:[]}}CU.SignatureDescriptor_Data_Multi={typeUrl:"/cosmos.tx.signing.v1beta1.Multi",encode(U,q=P.BinaryWriter.create()){if(U.bitarray!==void 0)z.CompactBitArray.encode(U.bitarray,q.uint32(10).fork()).ldelim();for(let G of U.signatures)CU.SignatureDescriptor_Data.encode(G,q.uint32(18).fork()).ldelim();return q},decode(U,q){let G=U instanceof P.BinaryReader?U:new P.BinaryReader(U),J=q===void 0?G.len:G.pos+q,H=p();while(G.pos<J){let K=G.uint32();switch(K>>>3){case 1:H.bitarray=z.CompactBitArray.decode(G,G.uint32());break;case 2:H.signatures.push(CU.SignatureDescriptor_Data.decode(G,G.uint32()));break;default:G.skipType(K&7);break}}return H},fromJSON(U){let q=p();if(C.isSet(U.bitarray))q.bitarray=z.CompactBitArray.fromJSON(U.bitarray);if(Array.isArray(U?.signatures))q.signatures=U.signatures.map((G)=>CU.SignatureDescriptor_Data.fromJSON(G));return q},toJSON(U){let q={};if(U.bitarray!==void 0&&(q.bitarray=U.bitarray?z.CompactBitArray.toJSON(U.bitarray):void 0),U.signatures)q.signatures=U.signatures.map((G)=>G?CU.SignatureDescriptor_Data.toJSON(G):void 0);else q.signatures=[];return q},fromPartial(U){let q=p();if(U.bitarray!==void 0&&U.bitarray!==null)q.bitarray=z.CompactBitArray.fromPartial(U.bitarray);return q.signatures=U.signatures?.map((G)=>CU.SignatureDescriptor_Data.fromPartial(G))||[],q}}});export default w1();
export{x as yd,S as zd,XU as Ad,YU as Bd,w1 as Cd};

//# debugId=EB6823D3FB7B4C1064756E2164756E21
