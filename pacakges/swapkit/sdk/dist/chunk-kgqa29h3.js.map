{
  "version": 3,
  "sources": ["../../../../node_modules/@ledgerhq/logs/lib-es/index.js"],
  "sourcesContent": [
    "let id = 0;\nconst subscribers = [];\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type, message, data) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    dispatch(obj);\n};\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({ type, message, data, context, }) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    if (context)\n        obj.context = context;\n    dispatch(obj);\n};\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n    constructor(type, context) {\n        this.type = type;\n        this.context = context;\n    }\n    trace(message, data) {\n        trace({\n            type: this.type,\n            message,\n            data,\n            context: this.context,\n        });\n    }\n    getContext() {\n        return this.context;\n    }\n    setContext(context) {\n        this.context = context;\n    }\n    updateContext(contextToAdd) {\n        this.context = Object.assign(Object.assign({}, this.context), contextToAdd);\n    }\n    getType() {\n        return this.type;\n    }\n    setType(type) {\n        this.type = type;\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `type`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withType(type) {\n        return new LocalTracer(type, this.context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with a new `context`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    withContext(context) {\n        return new LocalTracer(this.type, context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `context`,\n     * on which an additional context is merged with the existing one.\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withUpdatedContext(contextToAdd) {\n        return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));\n    }\n}\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb) => {\n    subscribers.push(cb);\n    return () => {\n        const i = subscribers.indexOf(cb);\n        if (i !== -1) {\n            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n            subscribers[i] = subscribers[subscribers.length - 1];\n            subscribers.pop();\n        }\n    };\n};\nfunction dispatch(log) {\n    for (let i = 0; i < subscribers.length; i++) {\n        try {\n            subscribers[i](log);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\nif (typeof window !== \"undefined\") {\n    window.__ledgerLogsListen = listen;\n}\n//# sourceMappingURL=index.js.map"
  ],
  "mappings": "AAAA,IAAI,EAAK,EACH,EAAc,CAAC,EAOR,EAAM,CAAC,EAAM,EAAS,IAAS,CACxC,IAAM,EAAM,CACR,OACA,GAAI,SAAS,CAAE,EACf,KAAM,IAAI,IACd,EACA,GAAI,EACA,EAAI,QAAU,EAClB,GAAI,EACA,EAAI,KAAO,EACf,EAAS,CAAG,GAUH,EAAQ,EAAG,OAAM,UAAS,OAAM,aAAe,CACxD,IAAM,EAAM,CACR,OACA,GAAI,SAAS,CAAE,EACf,KAAM,IAAI,IACd,EACA,GAAI,EACA,EAAI,QAAU,EAClB,GAAI,EACA,EAAI,KAAO,EACf,GAAI,EACA,EAAI,QAAU,EAClB,EAAS,CAAG,GAWT,MAAM,CAAY,CACrB,WAAW,CAAC,EAAM,EAAS,CACvB,KAAK,KAAO,EACZ,KAAK,QAAU,EAEnB,KAAK,CAAC,EAAS,EAAM,CACjB,EAAM,CACF,KAAM,KAAK,KACX,UACA,OACA,QAAS,KAAK,OAClB,CAAC,EAEL,UAAU,EAAG,CACT,OAAO,KAAK,QAEhB,UAAU,CAAC,EAAS,CAChB,KAAK,QAAU,EAEnB,aAAa,CAAC,EAAc,CACxB,KAAK,QAAU,OAAO,OAAO,OAAO,OAAO,CAAC,EAAG,KAAK,OAAO,EAAG,CAAY,EAE9E,OAAO,EAAG,CACN,OAAO,KAAK,KAEhB,OAAO,CAAC,EAAM,CACV,KAAK,KAAO,EAQhB,QAAQ,CAAC,EAAM,CACX,OAAO,IAAI,EAAY,EAAM,KAAK,OAAO,EAU7C,WAAW,CAAC,EAAS,CACjB,OAAO,IAAI,EAAY,KAAK,KAAM,CAAO,EAS7C,kBAAkB,CAAC,EAAc,CAC7B,OAAO,IAAI,EAAY,KAAK,KAAM,OAAO,OAAO,OAAO,OAAO,CAAC,EAAG,KAAK,OAAO,EAAG,CAAY,CAAC,EAEtG,CAOO,IAAM,EAAS,CAAC,IAAO,CAE1B,OADA,EAAY,KAAK,CAAE,EACZ,IAAM,CACT,IAAM,EAAI,EAAY,QAAQ,CAAE,EAChC,GAAI,IAAM,GAEN,EAAY,GAAK,EAAY,EAAY,OAAS,GAClD,EAAY,IAAI,IAI5B,SAAS,CAAQ,CAAC,EAAK,CACnB,QAAS,EAAI,EAAG,EAAI,EAAY,OAAQ,IACpC,GAAI,CACA,EAAY,GAAG,CAAG,QAEf,EAAP,CACI,QAAQ,MAAM,CAAC,GAI3B,UAAW,SAAW,YAClB,OAAO,mBAAqB",
  "debugId": "16F58F2F97051E3E64756E2164756E21",
  "names": []
}