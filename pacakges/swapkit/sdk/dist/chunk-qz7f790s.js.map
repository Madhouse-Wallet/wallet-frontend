{
  "version": 3,
  "sources": ["../../../../node_modules/@ledgerhq/hw-transport/lib-es/Transport.js", "../../../../node_modules/@ledgerhq/devices/lib-es/hid-framing.js", "../../../../node_modules/@ledgerhq/devices/lib-es/index.js", "../../../../node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js", "../../../../node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js"],
  "sourcesContent": [
    "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError, } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nclass Transport {\n    constructor({ context, logType } = {}) {\n        this.exchangeTimeout = 30000;\n        this.unresponsiveTimeout = 15000;\n        this.deviceModel = null;\n        this._events = new EventEmitter();\n        /**\n         * Send data to the device using the higher level API.\n         *\n         * @param {number} cla - The instruction class for the command.\n         * @param {number} ins - The instruction code for the command.\n         * @param {number} p1 - The first parameter for the instruction.\n         * @param {number} p2 - The second parameter for the instruction.\n         * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n         * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n         * @param {Object} options - Contains optional options for the exchange function\n         *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n         *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n         * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n         */\n        this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1) => __awaiter(this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function* (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], { abortTimeoutMs } = {}) {\n            const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n            if (data.length >= 256) {\n                tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n                throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n            }\n            tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n            const response = yield this.exchange(\n            // The size of the data is added in 1 byte just before `data`\n            Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), { abortTimeoutMs });\n            tracer.trace(\"Received response from exchange\");\n            const sw = response.readUInt16BE(response.length - 2);\n            if (!statusList.some(s => s === sw)) {\n                throw new TransportStatusError(sw);\n            }\n            return response;\n        });\n        this._appAPIlock = null;\n        this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);\n    }\n    /**\n     * Send data to the device using a low level API.\n     * It's recommended to use the \"send\" method for a higher level API.\n     * @param {Buffer} apdu - The data to send.\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {\n        throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * Send apdus in batch to the device using a low level API.\n     * The default implementation is to call exchange for each apdu.\n     * @param {Array<Buffer>} apdus - array of apdus to send.\n     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n     * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n     */\n    exchangeBulk(apdus, observer) {\n        let unsubscribed = false;\n        const unsubscribe = () => {\n            unsubscribed = true;\n        };\n        const main = () => __awaiter(this, void 0, void 0, function* () {\n            if (unsubscribed)\n                return;\n            for (const apdu of apdus) {\n                const r = yield this.exchange(apdu);\n                if (unsubscribed)\n                    return;\n                const status = r.readUInt16BE(r.length - 2);\n                if (status !== StatusCodes.OK) {\n                    throw new TransportStatusError(status);\n                }\n                observer.next(r);\n            }\n        });\n        main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n        return { unsubscribe };\n    }\n    /**\n     * Set the \"scramble key\" for the next data exchanges with the device.\n     * Each app can have a different scramble key and it is set internally during instantiation.\n     * @param {string} key - The scramble key to set.\n     * deprecated This method is no longer needed for modern transports and should be migrated away from.\n     * no @ before deprecated as it breaks documentationjs on version 14.0.2\n     * https://github.com/documentationjs/documentation/issues/1596\n     */\n    setScrambleKey(_key) { }\n    /**\n     * Close the connection with the device.\n     *\n     * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n     * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n     * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n     *\n     * @returns {Promise<void>} A promise that resolves when the transport is closed.\n     */\n    close() {\n        return Promise.resolve();\n    }\n    /**\n     * Listen for an event on the transport instance.\n     * Transport implementations may have specific events. Common events include:\n     * \"disconnect\" : triggered when the transport is disconnected.\n     * @param {string} eventName - The name of the event to listen for.\n     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n     */\n    on(eventName, cb) {\n        this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n    off(eventName, cb) {\n        this._events.removeListener(eventName, cb);\n    }\n    emit(event, ...args) {\n        this._events.emit(event, ...args);\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n    setDebugMode() {\n        console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n    setExchangeTimeout(exchangeTimeout) {\n        this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n    setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n        this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n    static create(openTimeout = 3000, listenTimeout) {\n        return new Promise((resolve, reject) => {\n            let found = false;\n            const sub = this.listen({\n                next: e => {\n                    found = true;\n                    if (sub)\n                        sub.unsubscribe();\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    this.open(e.descriptor, openTimeout).then(resolve, reject);\n                },\n                error: e => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    reject(e);\n                },\n                complete: () => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    if (!found) {\n                        reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n                    }\n                },\n            });\n            const listenTimeoutId = listenTimeout\n                ? setTimeout(() => {\n                    sub.unsubscribe();\n                    reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n                }, listenTimeout)\n                : null;\n        });\n    }\n    /**\n     * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n     *\n     * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n     *\n     * @param f The exchange job, using the transport to run\n     * @returns a Promise resolving with the output of the given job\n     */\n    exchangeAtomicImpl(f) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tracer = this.tracer.withUpdatedContext({\n                function: \"exchangeAtomicImpl\",\n                unresponsiveTimeout: this.unresponsiveTimeout,\n            });\n            if (this.exchangeBusyPromise) {\n                tracer.trace(\"Atomic exchange is already busy\");\n                throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n            }\n            // Sets the atomic guard\n            let resolveBusy;\n            const busyPromise = new Promise(r => {\n                resolveBusy = r;\n            });\n            this.exchangeBusyPromise = busyPromise;\n            // The device unresponsiveness handler\n            let unresponsiveReached = false;\n            const timeout = setTimeout(() => {\n                tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n                    unresponsiveTimeout: this.unresponsiveTimeout,\n                });\n                unresponsiveReached = true;\n                this.emit(\"unresponsive\");\n            }, this.unresponsiveTimeout);\n            try {\n                const res = yield f();\n                if (unresponsiveReached) {\n                    tracer.trace(\"Device was unresponsive, emitting responsive\");\n                    this.emit(\"responsive\");\n                }\n                return res;\n            }\n            finally {\n                tracer.trace(\"Finalize, clearing busy guard\");\n                clearTimeout(timeout);\n                if (resolveBusy)\n                    resolveBusy();\n                this.exchangeBusyPromise = null;\n            }\n        });\n    }\n    decorateAppAPIMethods(self, methods, scrambleKey) {\n        for (const methodName of methods) {\n            self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n    }\n    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n        return (...args) => __awaiter(this, void 0, void 0, function* () {\n            const { _appAPIlock } = this;\n            if (_appAPIlock) {\n                return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n            }\n            try {\n                this._appAPIlock = methodName;\n                this.setScrambleKey(scrambleKey);\n                return yield f.apply(ctx, args);\n            }\n            finally {\n                this._appAPIlock = null;\n            }\n        });\n    }\n    /**\n     * Sets the context used by the logging/tracing mechanism\n     *\n     * Useful when re-using (cached) the same Transport instance,\n     * but with a new tracing context.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    setTraceContext(context) {\n        this.tracer = this.tracer.withContext(context);\n    }\n    /**\n     * Updates the context used by the logging/tracing mechanism\n     *\n     * The update only overrides the key-value that are already defined in the current context.\n     *\n     * @param contextToAdd A TraceContext that will be added to the current context\n     */\n    updateTraceContext(contextToAdd) {\n        this.tracer.updateContext(contextToAdd);\n    }\n    /**\n     * Gets the tracing context of the transport instance\n     */\n    getTraceContext() {\n        return this.tracer.getContext();\n    }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\nexport default Transport;\n//# sourceMappingURL=Transport.js.map",
    "import { TransportError } from \"@ledgerhq/errors\";\nconst Tag = 0x05;\nfunction asUInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value, 0);\n    return b;\n}\nconst initialAcc = {\n    data: Buffer.alloc(0),\n    dataLength: 0,\n    sequence: 0,\n};\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel, packetSize) => {\n    return {\n        /**\n         * Frames/encodes an APDU message into HID USB packets/frames\n         *\n         * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n         * @returns an array of HID USB frames ready to be sent\n         */\n        makeBlocks(apdu) {\n            // Encodes the APDU length in 2 bytes before the APDU itself.\n            // The length is measured as the number of bytes.\n            // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n            // the minimum size of an APDU is 5 bytes.\n            let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n            const blockSize = packetSize - 5;\n            const nbBlocks = Math.ceil(data.length / blockSize);\n            // Fills data with 0-padding\n            data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n            const blocks = [];\n            for (let i = 0; i < nbBlocks; i++) {\n                const head = Buffer.alloc(5);\n                head.writeUInt16BE(channel, 0);\n                head.writeUInt8(Tag, 2);\n                head.writeUInt16BE(i, 3);\n                // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n                blocks.push(Buffer.concat([head, chunk]));\n            }\n            return blocks;\n        },\n        /**\n         * Reduces HID USB packets/frames to one response.\n         *\n         * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n         *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n         * @param chunk Current chunk to reduce into accumulator\n         * @returns An accumulator value updated with the current chunk\n         */\n        reduceResponse(acc, chunk) {\n            let { data, dataLength, sequence } = acc || initialAcc;\n            if (chunk.readUInt16BE(0) !== channel) {\n                throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n            }\n            if (chunk.readUInt8(2) !== Tag) {\n                throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n            }\n            if (chunk.readUInt16BE(3) !== sequence) {\n                throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n            }\n            // Gets the total length of the response from the 1st frame\n            if (!acc) {\n                dataLength = chunk.readUInt16BE(5);\n            }\n            sequence++;\n            // The total length on the 1st frame takes 2 more bytes\n            const chunkData = chunk.slice(acc ? 5 : 7);\n            data = Buffer.concat([data, chunkData]);\n            // Removes any 0 padding\n            if (data.length > dataLength) {\n                data = data.slice(0, dataLength);\n            }\n            return {\n                data,\n                dataLength,\n                sequence,\n            };\n        },\n        /**\n         * Returns the response message that has been reduced from the HID USB frames\n         *\n         * @param acc The accumulator\n         * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n         *   accumulator is incorrect (message length is not valid)\n         */\n        getReducedResult(acc) {\n            if (acc && acc.dataLength === acc.data.length) {\n                return acc.data;\n            }\n        },\n    };\n};\nexport default createHIDframing;\n//# sourceMappingURL=hid-framing.js.map",
    "import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n    /** Ledger Blue */\n    DeviceModelId[\"blue\"] = \"blue\";\n    /** Ledger Nano S */\n    DeviceModelId[\"nanoS\"] = \"nanoS\";\n    /** Ledger Nano S Plus */\n    DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n    /** Ledger Nano X */\n    DeviceModelId[\"nanoX\"] = \"nanoX\";\n    /** Ledger Stax */\n    DeviceModelId[\"stax\"] = \"stax\";\n    /** Ledger Flex (\"europa\" is the internal name) */\n    DeviceModelId[\"europa\"] = \"europa\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n    [DeviceModelId.blue]: {\n        id: DeviceModelId.blue,\n        productName: \"Ledger Blue\",\n        productIdMM: 0x00,\n        legacyUsbProductId: 0x0000,\n        usbOnly: true,\n        memorySize: 480 * 1024,\n        masks: [0x31000000, 0x31010000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n    },\n    [DeviceModelId.nanoS]: {\n        id: DeviceModelId.nanoS,\n        productName: \"Ledger Nano S\",\n        productIdMM: 0x10,\n        legacyUsbProductId: 0x0001,\n        usbOnly: true,\n        memorySize: 320 * 1024,\n        masks: [0x31100000],\n        getBlockSize: (firmwareVersion) => { var _a; return semver.lt((_a = semver.coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024; },\n    },\n    [DeviceModelId.nanoX]: {\n        id: DeviceModelId.nanoX,\n        productName: \"Ledger Nano X\",\n        productIdMM: 0x40,\n        legacyUsbProductId: 0x0004,\n        usbOnly: false,\n        memorySize: 2 * 1024 * 1024,\n        masks: [0x33000000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.nanoSP]: {\n        id: DeviceModelId.nanoSP,\n        productName: \"Ledger Nano S Plus\",\n        productIdMM: 0x50,\n        legacyUsbProductId: 0x0005,\n        usbOnly: true,\n        memorySize: 1533 * 1024,\n        masks: [0x33100000],\n        getBlockSize: (_firmwareVersion) => 32,\n    },\n    [DeviceModelId.stax]: {\n        id: DeviceModelId.stax,\n        productName: \"Ledger Stax\",\n        productIdMM: 0x60,\n        legacyUsbProductId: 0x0006,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33200000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.europa]: {\n        id: DeviceModelId.europa,\n        productName: \"Ledger Flex\",\n        productIdMM: 0x70,\n        legacyUsbProductId: 0x0007,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33300000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\",\n            },\n        ],\n    },\n};\nconst productMap = {\n    Blue: DeviceModelId.blue,\n    \"Nano S\": DeviceModelId.nanoS,\n    \"Nano S Plus\": DeviceModelId.nanoSP,\n    \"Nano X\": DeviceModelId.nanoX,\n    Stax: DeviceModelId.stax,\n    Europa: DeviceModelId.europa,\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = (id) => {\n    const info = devices[id];\n    if (!info)\n        throw new Error(\"device '\" + id + \"' does not exist\");\n    return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId) => {\n    const deviceModel = devicesList.find(({ masks }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n    return deviceModel;\n};\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = (usbProductId) => {\n    const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n    if (legacy)\n        return legacy;\n    const mm = usbProductId >> 8;\n    const deviceModel = devicesList.find(d => d.productIdMM === mm);\n    return deviceModel;\n};\nexport const identifyProductName = (productName) => {\n    const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n    return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n    const deviceModel = devices[id];\n    const { bluetoothSpec } = deviceModel;\n    if (bluetoothSpec) {\n        for (let i = 0; i < bluetoothSpec.length; i++) {\n            const spec = bluetoothSpec[i];\n            bluetoothServices.push(spec.serviceUuid);\n            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = Object.assign({ deviceModel }, spec);\n        }\n    }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];\n//# sourceMappingURL=index.js.map",
    "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\nconst ledgerDevices = [\n    {\n        vendorId: ledgerUSBVendorId,\n    },\n];\nexport function requestLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const device = yield navigator.usb.requestDevice({\n            filters: ledgerDevices,\n        });\n        return device;\n    });\n}\nexport function getLedgerDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const devices = yield navigator.usb.getDevices();\n        return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n    });\n}\nexport function getFirstLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const existingDevices = yield getLedgerDevices();\n        if (existingDevices.length > 0)\n            return existingDevices[0];\n        return requestLedgerDevice();\n    });\n}\nexport const isSupported = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === \"function\");\n//# sourceMappingURL=webusb.js.map",
    "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice, } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nclass TransportWebUSB extends Transport {\n    constructor(device, interfaceNumber) {\n        super();\n        this.channel = Math.floor(Math.random() * 0xffff);\n        this.packetSize = 64;\n        this._disconnectEmitted = false;\n        this._emitDisconnect = (e) => {\n            if (this._disconnectEmitted)\n                return;\n            this._disconnectEmitted = true;\n            this.emit(\"disconnect\", e);\n        };\n        this.device = device;\n        this.interfaceNumber = interfaceNumber;\n        this.deviceModel = identifyUSBProductId(device.productId);\n    }\n    /**\n     * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n     */\n    static request() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const device = yield requestLedgerDevice();\n            return TransportWebUSB.open(device);\n        });\n    }\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n    static openConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const devices = yield getLedgerDevices();\n            if (devices.length === 0)\n                return null;\n            return TransportWebUSB.open(devices[0]);\n        });\n    }\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n    static open(device) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield device.open();\n            if (device.configuration === null) {\n                yield device.selectConfiguration(configurationValue);\n            }\n            yield gracefullyResetDevice(device);\n            const iface = device.configurations[0].interfaces.find(({ alternates }) => alternates.some(a => a.interfaceClass === 255));\n            if (!iface) {\n                throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n            }\n            const interfaceNumber = iface.interfaceNumber;\n            try {\n                yield device.claimInterface(interfaceNumber);\n            }\n            catch (e) {\n                yield device.close();\n                throw new TransportInterfaceNotAvailable(e.message);\n            }\n            const transport = new TransportWebUSB(device, interfaceNumber);\n            const onDisconnect = e => {\n                if (device === e.device) {\n                    // $FlowFixMe\n                    navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n                    transport._emitDisconnect(new DisconnectedDevice());\n                }\n            };\n            // $FlowFixMe\n            navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n            return transport;\n        });\n    }\n    /**\n     * Release the transport device\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.exchangeBusyPromise;\n            yield this.device.releaseInterface(this.interfaceNumber);\n            yield gracefullyResetDevice(this.device);\n            yield this.device.close();\n        });\n    }\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    exchange(apdu) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const b = yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {\n                const { channel, packetSize } = this;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                const framing = hidFraming(channel, packetSize);\n                // Write...\n                const blocks = framing.makeBlocks(apdu);\n                for (let i = 0; i < blocks.length; i++) {\n                    yield this.device.transferOut(endpointNumber, blocks[i]);\n                }\n                // Read...\n                let result;\n                let acc;\n                while (!(result = framing.getReducedResult(acc))) {\n                    const r = yield this.device.transferIn(endpointNumber, packetSize);\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const buffer = Buffer.from(r.data.buffer);\n                    acc = framing.reduceResponse(acc, buffer);\n                }\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return result;\n            })).catch(e => {\n                if (e && e.message && e.message.includes(\"disconnected\")) {\n                    this._emitDisconnect(e);\n                    throw new DisconnectedDeviceDuringOperation(e.message);\n                }\n                throw e;\n            });\n            return b;\n        });\n    }\n    setScrambleKey() { }\n}\n/**\n * Check if WebUSB transport is supported.\n */\nTransportWebUSB.isSupported = isSupported;\n/**\n * List the WebUSB devices that was previously authorized by the user.\n */\nTransportWebUSB.list = getLedgerDevices;\n/**\n * Actively listen to WebUSB devices and emit ONE device\n * that was either accepted before, if not it will trigger the native permission UI.\n *\n * Important: it must be called in the context of a UI click!\n */\nTransportWebUSB.listen = (observer) => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(device => {\n        if (!unsubscribed) {\n            const deviceModel = identifyUSBProductId(device.productId);\n            observer.next({\n                type: \"add\",\n                descriptor: device,\n                deviceModel,\n            });\n            observer.complete();\n        }\n    }, error => {\n        if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n            observer.error(new TransportWebUSBGestureRequired(error.message));\n        }\n        else {\n            observer.error(new TransportOpenUserCancelled(error.message));\n        }\n    });\n    function unsubscribe() {\n        unsubscribed = true;\n    }\n    return {\n        unsubscribe,\n    };\n};\nexport default TransportWebUSB;\nfunction gracefullyResetDevice(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield device.reset();\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    });\n}\n//# sourceMappingURL=TransportWebUSB.js.map"
  ],
  "mappings": "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",
  "debugId": "68CE1D5C1CDA650E64756E2164756E21",
  "names": []
}