import{kc as E,lc as j,mc as ZG,oc as M}from"./chunk-0z8hab52.js";import"./chunk-xchcefhj.js";import"./chunk-wzbhx1st.js";import"./chunk-w38asa2a.js";import"./chunk-6phd1cjf.js";import"./chunk-tp8k8x3d.js";import"./chunk-bxvsg55z.js";import{Ve as I}from"./chunk-trjbmn7w.js";var z=I((e)=>{Object.defineProperty(e,"__esModule",{value:!0});e.isMultisigThresholdPubkey=e.isSinglePubkey=e.pubkeyType=e.isSecp256k1Pubkey=e.isEd25519Pubkey=void 0;function oG(G){return G.type==="tendermint/PubKeyEd25519"}e.isEd25519Pubkey=oG;function tG(G){return G.type==="tendermint/PubKeySecp256k1"}e.isSecp256k1Pubkey=tG;e.pubkeyType={secp256k1:"tendermint/PubKeySecp256k1",ed25519:"tendermint/PubKeyEd25519",sr25519:"tendermint/PubKeySr25519",multisigThreshold:"tendermint/PubKeyMultisigThreshold"};function eG(G){return[e.pubkeyType.ed25519,e.pubkeyType.secp256k1,e.pubkeyType.sr25519].includes(G.type)}e.isSinglePubkey=eG;function GQ(G){return G.type==="tendermint/PubKeyMultisigThreshold"}e.isMultisigThresholdPubkey=GQ});var f=I(($G)=>{Object.defineProperty($G,"__esModule",{value:!0});$G.encodeBech32Pubkey=$G.encodeAminoPubkey=$G.decodeBech32Pubkey=$G.decodeAminoPubkey=$G.encodeEd25519Pubkey=$G.encodeSecp256k1Pubkey=void 0;var N=E(),ZQ=j(),L=ZG(),V=z();function $Q(G){if(G.length!==33||G[0]!==2&&G[0]!==3)throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");return{type:V.pubkeyType.secp256k1,value:N.toBase64(G)}}$G.encodeSecp256k1Pubkey=$Q;function FQ(G){if(G.length!==32)throw new Error("Ed25519 public key must be 32 bytes long");return{type:V.pubkeyType.ed25519,value:N.toBase64(G)}}$G.encodeEd25519Pubkey=FQ;var k=N.fromHex("eb5ae98721"),y=N.fromHex("1624de6420"),QG=N.fromHex("0dfb100520"),P=N.fromHex("22c1f7e2");function d(G){if(L.arrayContentStartsWith(G,k)){let Q=G.slice(k.length);if(Q.length!==33)throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");return{type:V.pubkeyType.secp256k1,value:N.toBase64(Q)}}else if(L.arrayContentStartsWith(G,y)){let Q=G.slice(y.length);if(Q.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");return{type:V.pubkeyType.ed25519,value:N.toBase64(Q)}}else if(L.arrayContentStartsWith(G,QG)){let Q=G.slice(QG.length);if(Q.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");return{type:V.pubkeyType.sr25519,value:N.toBase64(Q)}}else if(L.arrayContentStartsWith(G,P))return IQ(G);else throw new Error("Unsupported public key type. Amino data starts with: "+N.toHex(G.slice(0,5)))}$G.decodeAminoPubkey=d;function qQ(G){let{data:Q}=N.fromBech32(G);return d(Q)}$G.decodeBech32Pubkey=qQ;function XG(G){if(G.length<1)throw new Error("Can't decode varint. EOF");if(G[0]>127)throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");return[G[0],1]}function IQ(G){let Q=Array.from(G),X=Q.splice(0,P.length);if(!L.arrayContentStartsWith(X,P))throw new Error("Invalid multisig prefix.");if(Q.shift()!=8)throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");let[Y,$]=XG(Q);Q.splice(0,$);let J=[];while(Q.length>0){if(Q.shift()!=18)throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");let[F,q]=XG(Q);if(Q.splice(0,q),Q.length<F)throw new Error("Invalid multisig data length.");let B=Q.splice(0,F),H=d(Uint8Array.from(B));J.push(H)}return{type:V.pubkeyType.multisigThreshold,value:{threshold:Y.toString(),pubkeys:J}}}function YG(G){let Q=ZQ.Uint53.fromString(G.toString()).toNumber();if(Q>127)throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");return[Q]}function c(G){if(V.isMultisigThresholdPubkey(G)){let Q=Array.from(P);Q.push(8),Q.push(...YG(G.value.threshold));for(let X of G.value.pubkeys.map((Y)=>c(Y)))Q.push(18),Q.push(...YG(X.length)),Q.push(...X);return new Uint8Array(Q)}else if(V.isEd25519Pubkey(G))return new Uint8Array([...y,...N.fromBase64(G.value)]);else if(V.isSecp256k1Pubkey(G))return new Uint8Array([...k,...N.fromBase64(G.value)]);else throw new Error("Unsupported pubkey type")}$G.encodeAminoPubkey=c;function NQ(G,Q){return N.toBech32(Q,c(G))}$G.encodeBech32Pubkey=NQ});var T=I((JG)=>{Object.defineProperty(JG,"__esModule",{value:!0});JG.pubkeyToAddress=JG.pubkeyToRawAddress=JG.rawSecp256k1PubkeyToRawAddress=JG.rawEd25519PubkeyToRawAddress=void 0;var m=M(),a=E(),KQ=f(),u=z();function qG(G){if(G.length!==32)throw new Error(`Invalid Ed25519 pubkey length: ${G.length}`);return m.sha256(G).slice(0,20)}JG.rawEd25519PubkeyToRawAddress=qG;function IG(G){if(G.length!==33)throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${G.length}`);return m.ripemd160(m.sha256(G))}JG.rawSecp256k1PubkeyToRawAddress=IG;function NG(G){if(u.isSecp256k1Pubkey(G)){let Q=a.fromBase64(G.value);return IG(Q)}else if(u.isEd25519Pubkey(G)){let Q=a.fromBase64(G.value);return qG(Q)}else if(u.isMultisigThresholdPubkey(G)){let Q=KQ.encodeAminoPubkey(G);return m.sha256(Q).slice(0,20)}else throw new Error("Unsupported public key type")}JG.pubkeyToRawAddress=NG;function CQ(G,Q){return a.toBech32(Q,NG(G))}JG.pubkeyToAddress=CQ});var KG=I((VG)=>{Object.defineProperty(VG,"__esModule",{value:!0});VG.addCoins=VG.parseCoins=VG.coins=VG.coin=void 0;var i=j();function BG(G,Q){let X;if(typeof G==="number")try{X=new i.Uint53(G).toString()}catch(Y){throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")}else{if(!G.match(/^[0-9]+$/))throw new Error("Invalid unsigned integer string format");X=G.replace(/^0*/,"")||"0"}return{amount:X,denom:Q}}VG.coin=BG;function UQ(G,Q){return[BG(G,Q)]}VG.coins=UQ;function zQ(G){return G.replace(/\s/g,"").split(",").filter(Boolean).map((Q)=>{let X=Q.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);if(!X)throw new Error("Got an invalid coin string");return{amount:X[1].replace(/^0+/,"")||"0",denom:X[2]}})}VG.parseCoins=zQ;function LQ(G,Q){if(G.denom!==Q.denom)throw new Error("Trying to add two coins with different denoms");return{amount:i.Decimal.fromAtomics(G.amount,0).plus(i.Decimal.fromAtomics(Q.amount,0)).atomics,denom:G.denom}}VG.addCoins=LQ});var zG=I((HG)=>{Object.defineProperty(HG,"__esModule",{value:!0});HG.createMultisigThresholdPubkey=HG.compareArrays=void 0;var CG=E(),AQ=j(),WG=T();function vG(G,Q){let X=CG.toHex(G),Y=CG.toHex(Q);return X===Y?0:X<Y?-1:1}HG.compareArrays=vG;function DQ(G,Q,X=!1){let Y=new AQ.Uint53(Q);if(Y.toNumber()>G.length)throw new Error(`Threshold k = ${Y.toNumber()} exceeds number of keys n = ${G.length}`);let $=X?G:Array.from(G).sort((J,F)=>{let q=WG.pubkeyToRawAddress(J),B=WG.pubkeyToRawAddress(F);return vG(q,B)});return{type:"tendermint/PubKeyMultisigThreshold",value:{threshold:Y.toString(),pubkeys:$}}}HG.createMultisigThresholdPubkey=DQ});var TG=I((LG)=>{Object.defineProperty(LG,"__esModule",{value:!0});LG.omitDefault=void 0;function SQ(G){switch(typeof G){case"string":return G===""?void 0:G;case"number":return G===0?void 0:G;case"bigint":return G===BigInt(0)?void 0:G;case"boolean":return!G?void 0:G;default:throw new Error(`Got unsupported type '${typeof G}'`)}}LG.omitDefault=SQ});var n=I((RG)=>{Object.defineProperty(RG,"__esModule",{value:!0});RG.makeCosmoshubPath=void 0;var R=M();function PQ(G){return[R.Slip10RawIndex.hardened(44),R.Slip10RawIndex.hardened(118),R.Slip10RawIndex.hardened(0),R.Slip10RawIndex.normal(0),R.Slip10RawIndex.normal(G)]}RG.makeCosmoshubPath=PQ});var h=I((DG)=>{Object.defineProperty(DG,"__esModule",{value:!0});DG.decodeSignature=DG.encodeSecp256k1Signature=void 0;var r=E(),jQ=f(),fQ=z();function mQ(G,Q){if(Q.length!==64)throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");return{pub_key:jQ.encodeSecp256k1Pubkey(G),signature:r.toBase64(Q)}}DG.encodeSecp256k1Signature=mQ;function hQ(G){switch(G.pub_key.type){case fQ.pubkeyType.secp256k1:return{pubkey:r.fromBase64(G.pub_key.value),signature:r.fromBase64(G.signature)};default:throw new Error("Unsupported pubkey type")}}DG.decodeSignature=hQ});var l=I((fG)=>{Object.defineProperty(fG,"__esModule",{value:!0});fG.serializeSignDoc=fG.escapeCharacters=fG.makeSignDoc=fG.sortedJsonStringify=void 0;var _Q=E(),SG=j();function p(G){if(typeof G!=="object"||G===null)return G;if(Array.isArray(G))return G.map(p);let Q=Object.keys(G).sort(),X={};return Q.forEach((Y)=>{X[Y]=p(G[Y])}),X}function PG(G){return JSON.stringify(p(G))}fG.sortedJsonStringify=PG;function xQ(G,Q,X,Y,$,J,F){return{chain_id:X,account_number:SG.Uint53.fromString($.toString()).toString(),sequence:SG.Uint53.fromString(J.toString()).toString(),fee:Q,msgs:G,memo:Y||"",...F&&{timeout_height:F.toString()}}}fG.makeSignDoc=xQ;function jG(G){let Q=/&/g,X=/</g,Y=/>/g;return G.replace(Q,"\\u0026").replace(X,"\\u003c").replace(Y,"\\u003e")}fG.escapeCharacters=jG;function bQ(G){let Q=jG(PG(G));return _Q.toUtf8(Q)}fG.serializeSignDoc=bQ});var o=I((hG)=>{Object.defineProperty(hG,"__esModule",{value:!0});hG.decrypt=hG.encrypt=hG.supportedAlgorithms=hG.executeKdf=hG.cosmjsSalt=void 0;var K=M(),dQ=E();hG.cosmjsSalt=dQ.toAscii("The CosmJS salt.");async function cQ(G,Q){switch(Q.algorithm){case"argon2id":{let X=Q.params;if(!K.isArgon2idOptions(X))throw new Error("Invalid format of argon2id params");return K.Argon2id.execute(G,hG.cosmjsSalt,X)}default:throw new Error("Unsupported KDF algorithm")}}hG.executeKdf=cQ;hG.supportedAlgorithms={xchacha20poly1305Ietf:"xchacha20poly1305-ietf"};async function uQ(G,Q,X){switch(X.algorithm){case hG.supportedAlgorithms.xchacha20poly1305Ietf:{let Y=K.Random.getBytes(K.xchacha20NonceLength);return new Uint8Array([...Y,...await K.Xchacha20poly1305Ietf.encrypt(G,Q,Y)])}default:throw new Error(`Unsupported encryption algorithm: '${X.algorithm}'`)}}hG.encrypt=uQ;async function aQ(G,Q,X){switch(X.algorithm){case hG.supportedAlgorithms.xchacha20poly1305Ietf:{let Y=G.slice(0,K.xchacha20NonceLength);return K.Xchacha20poly1305Ietf.decrypt(G.slice(K.xchacha20NonceLength),Q,Y)}default:throw new Error(`Unsupported encryption algorithm: '${X.algorithm}'`)}}hG.decrypt=aQ});var kG=I((bG)=>{Object.defineProperty(bG,"__esModule",{value:!0});bG.Secp256k1HdWallet=bG.extractKdfConfiguration=void 0;var O=M(),A=E(),W=ZG(),rQ=T(),pQ=n(),sQ=h(),oQ=l(),D=o(),_="secp256k1wallet-v1",tQ={algorithm:"argon2id",params:{outputLength:32,opsLimit:24,memLimitKib:12288}};function eQ(G){if(!W.isNonNullObject(G))return!1;if(typeof G.hdPath!=="string")return!1;if(typeof G.prefix!=="string")return!1;return!0}function GX(G){return G.kdf}function QX(G){let Q=JSON.parse(G);if(!W.isNonNullObject(Q))throw new Error("Root document is not an object.");switch(Q.type){case _:return GX(Q);default:throw new Error("Unsupported serialization type")}}bG.extractKdfConfiguration=QX;var xG={bip39Password:"",hdPaths:[pQ.makeCosmoshubPath(0)],prefix:"cosmos"};class C{static async fromMnemonic(G,Q={}){let X=new O.EnglishMnemonic(G),Y=await O.Bip39.mnemonicToSeed(X,Q.bip39Password);return new C(X,{...Q,seed:Y})}static async generate(G=12,Q={}){let X=4*Math.floor(11*G/33),Y=O.Random.getBytes(X),$=O.Bip39.encode(Y);return C.fromMnemonic($.toString(),Q)}static async deserialize(G,Q){let X=JSON.parse(G);if(!W.isNonNullObject(X))throw new Error("Root document is not an object.");switch(X.type){case _:return C.deserializeTypeV1(G,Q);default:throw new Error("Unsupported serialization type")}}static async deserializeWithEncryptionKey(G,Q){let X=JSON.parse(G);if(!W.isNonNullObject(X))throw new Error("Root document is not an object.");let Y=X;switch(Y.type){case _:{let $=await D.decrypt(A.fromBase64(Y.data),Q,Y.encryption),J=JSON.parse(A.fromUtf8($)),{mnemonic:F,accounts:q}=J;if(W.assert(typeof F==="string"),!Array.isArray(q))throw new Error("Property 'accounts' is not an array");if(!q.every((U)=>eQ(U)))throw new Error("Account is not in the correct format.");let B=q[0].prefix;if(!q.every(({prefix:U})=>U===B))throw new Error("Accounts do not all have the same prefix");let H=q.map(({hdPath:U})=>O.stringToPath(U));return C.fromMnemonic(F,{hdPaths:H,prefix:B})}default:throw new Error("Unsupported serialization type")}}static async deserializeTypeV1(G,Q){let X=JSON.parse(G);if(!W.isNonNullObject(X))throw new Error("Root document is not an object.");let Y=await D.executeKdf(Q,X.kdf);return C.deserializeWithEncryptionKey(G,Y)}constructor(G,Q){let X=Q.hdPaths??xG.hdPaths,Y=Q.prefix??xG.prefix;this.secret=G,this.seed=Q.seed,this.accounts=X.map(($)=>({hdPath:$,prefix:Y}))}get mnemonic(){return this.secret.toString()}async getAccounts(){return(await this.getAccountsWithPrivkeys()).map(({algo:Q,pubkey:X,address:Y})=>({algo:Q,pubkey:X,address:Y}))}async signAmino(G,Q){let Y=(await this.getAccountsWithPrivkeys()).find(({address:H})=>H===G);if(Y===void 0)throw new Error(`Address ${G} not found in wallet`);let{privkey:$,pubkey:J}=Y,F=O.sha256(oQ.serializeSignDoc(Q)),q=await O.Secp256k1.createSignature(F,$),B=new Uint8Array([...q.r(32),...q.s(32)]);return{signed:Q,signature:sQ.encodeSecp256k1Signature(J,B)}}async serialize(G){let Q=tQ,X=await D.executeKdf(G,Q);return this.serializeWithEncryptionKey(X,Q)}async serializeWithEncryptionKey(G,Q){let X={mnemonic:this.mnemonic,accounts:this.accounts.map(({hdPath:q,prefix:B})=>({hdPath:O.pathToString(q),prefix:B}))},Y=A.toUtf8(JSON.stringify(X)),$={algorithm:D.supportedAlgorithms.xchacha20poly1305Ietf},J=await D.encrypt(Y,G,$),F={type:_,kdf:Q,encryption:$,data:A.toBase64(J)};return JSON.stringify(F)}async getKeyPair(G){let{privkey:Q}=O.Slip10.derivePath(O.Slip10Curve.Secp256k1,this.seed,G),{pubkey:X}=await O.Secp256k1.makeKeypair(Q);return{privkey:Q,pubkey:O.Secp256k1.compressPubkey(X)}}async getAccountsWithPrivkeys(){return Promise.all(this.accounts.map(async({hdPath:G,prefix:Q})=>{let{privkey:X,pubkey:Y}=await this.getKeyPair(G),$=A.toBech32(Q,rQ.rawSecp256k1PubkeyToRawAddress(Y));return{algo:"secp256k1",privkey:X,pubkey:Y,address:$}}))}}bG.Secp256k1HdWallet=C});var cG=I((yG)=>{Object.defineProperty(yG,"__esModule",{value:!0});yG.Secp256k1Wallet=void 0;var x=M(),YX=E(),ZX=T(),$X=h(),FX=l();class t{static async fromKey(G,Q="cosmos"){let X=(await x.Secp256k1.makeKeypair(G)).pubkey;return new t(G,x.Secp256k1.compressPubkey(X),Q)}constructor(G,Q,X){this.privkey=G,this.pubkey=Q,this.prefix=X}get address(){return YX.toBech32(this.prefix,ZX.rawSecp256k1PubkeyToRawAddress(this.pubkey))}async getAccounts(){return[{algo:"secp256k1",address:this.address,pubkey:this.pubkey}]}async signAmino(G,Q){if(G!==this.address)throw new Error(`Address ${G} not found in wallet`);let X=new x.Sha256(FX.serializeSignDoc(Q)).digest(),Y=await x.Secp256k1.createSignature(X,this.privkey),$=new Uint8Array([...Y.r(32),...Y.s(32)]);return{signed:Q,signature:$X.encodeSecp256k1Signature(this.pubkey,$)}}}yG.Secp256k1Wallet=t});var iG=I((uG)=>{Object.defineProperty(uG,"__esModule",{value:!0});uG.makeStdTx=uG.isStdTx=void 0;function qX(G){let{memo:Q,msg:X,fee:Y,signatures:$}=G;return typeof Q==="string"&&Array.isArray(X)&&typeof Y==="object"&&Array.isArray($)}uG.isStdTx=qX;function IX(G,Q){return{msg:G.msgs,fee:G.fee,memo:G.memo,signatures:Array.isArray(Q)?Q:[Q]}}uG.makeStdTx=IX});var CX=I((Z)=>{Object.defineProperty(Z,"__esModule",{value:!0});Z.executeKdf=Z.makeStdTx=Z.isStdTx=Z.serializeSignDoc=Z.makeSignDoc=Z.encodeSecp256k1Signature=Z.decodeSignature=Z.Secp256k1Wallet=Z.Secp256k1HdWallet=Z.extractKdfConfiguration=Z.pubkeyType=Z.isSinglePubkey=Z.isSecp256k1Pubkey=Z.isMultisigThresholdPubkey=Z.isEd25519Pubkey=Z.makeCosmoshubPath=Z.omitDefault=Z.createMultisigThresholdPubkey=Z.encodeSecp256k1Pubkey=Z.encodeEd25519Pubkey=Z.encodeBech32Pubkey=Z.encodeAminoPubkey=Z.decodeBech32Pubkey=Z.decodeAminoPubkey=Z.parseCoins=Z.coins=Z.coin=Z.addCoins=Z.rawSecp256k1PubkeyToRawAddress=Z.rawEd25519PubkeyToRawAddress=Z.pubkeyToRawAddress=Z.pubkeyToAddress=void 0;var b=T();Object.defineProperty(Z,"pubkeyToAddress",{enumerable:!0,get:function(){return b.pubkeyToAddress}});Object.defineProperty(Z,"pubkeyToRawAddress",{enumerable:!0,get:function(){return b.pubkeyToRawAddress}});Object.defineProperty(Z,"rawEd25519PubkeyToRawAddress",{enumerable:!0,get:function(){return b.rawEd25519PubkeyToRawAddress}});Object.defineProperty(Z,"rawSecp256k1PubkeyToRawAddress",{enumerable:!0,get:function(){return b.rawSecp256k1PubkeyToRawAddress}});var g=KG();Object.defineProperty(Z,"addCoins",{enumerable:!0,get:function(){return g.addCoins}});Object.defineProperty(Z,"coin",{enumerable:!0,get:function(){return g.coin}});Object.defineProperty(Z,"coins",{enumerable:!0,get:function(){return g.coins}});Object.defineProperty(Z,"parseCoins",{enumerable:!0,get:function(){return g.parseCoins}});var v=f();Object.defineProperty(Z,"decodeAminoPubkey",{enumerable:!0,get:function(){return v.decodeAminoPubkey}});Object.defineProperty(Z,"decodeBech32Pubkey",{enumerable:!0,get:function(){return v.decodeBech32Pubkey}});Object.defineProperty(Z,"encodeAminoPubkey",{enumerable:!0,get:function(){return v.encodeAminoPubkey}});Object.defineProperty(Z,"encodeBech32Pubkey",{enumerable:!0,get:function(){return v.encodeBech32Pubkey}});Object.defineProperty(Z,"encodeEd25519Pubkey",{enumerable:!0,get:function(){return v.encodeEd25519Pubkey}});Object.defineProperty(Z,"encodeSecp256k1Pubkey",{enumerable:!0,get:function(){return v.encodeSecp256k1Pubkey}});var JX=zG();Object.defineProperty(Z,"createMultisigThresholdPubkey",{enumerable:!0,get:function(){return JX.createMultisigThresholdPubkey}});var OX=TG();Object.defineProperty(Z,"omitDefault",{enumerable:!0,get:function(){return OX.omitDefault}});var BX=n();Object.defineProperty(Z,"makeCosmoshubPath",{enumerable:!0,get:function(){return BX.makeCosmoshubPath}});var w=z();Object.defineProperty(Z,"isEd25519Pubkey",{enumerable:!0,get:function(){return w.isEd25519Pubkey}});Object.defineProperty(Z,"isMultisigThresholdPubkey",{enumerable:!0,get:function(){return w.isMultisigThresholdPubkey}});Object.defineProperty(Z,"isSecp256k1Pubkey",{enumerable:!0,get:function(){return w.isSecp256k1Pubkey}});Object.defineProperty(Z,"isSinglePubkey",{enumerable:!0,get:function(){return w.isSinglePubkey}});Object.defineProperty(Z,"pubkeyType",{enumerable:!0,get:function(){return w.pubkeyType}});var nG=kG();Object.defineProperty(Z,"extractKdfConfiguration",{enumerable:!0,get:function(){return nG.extractKdfConfiguration}});Object.defineProperty(Z,"Secp256k1HdWallet",{enumerable:!0,get:function(){return nG.Secp256k1HdWallet}});var VX=cG();Object.defineProperty(Z,"Secp256k1Wallet",{enumerable:!0,get:function(){return VX.Secp256k1Wallet}});var rG=h();Object.defineProperty(Z,"decodeSignature",{enumerable:!0,get:function(){return rG.decodeSignature}});Object.defineProperty(Z,"encodeSecp256k1Signature",{enumerable:!0,get:function(){return rG.encodeSecp256k1Signature}});var pG=l();Object.defineProperty(Z,"makeSignDoc",{enumerable:!0,get:function(){return pG.makeSignDoc}});Object.defineProperty(Z,"serializeSignDoc",{enumerable:!0,get:function(){return pG.serializeSignDoc}});var sG=iG();Object.defineProperty(Z,"isStdTx",{enumerable:!0,get:function(){return sG.isStdTx}});Object.defineProperty(Z,"makeStdTx",{enumerable:!0,get:function(){return sG.makeStdTx}});var EX=o();Object.defineProperty(Z,"executeKdf",{enumerable:!0,get:function(){return EX.executeKdf}})});export default CX();
export{CX as ic};

//# debugId=89DA30A3F20148C964756E2164756E21
