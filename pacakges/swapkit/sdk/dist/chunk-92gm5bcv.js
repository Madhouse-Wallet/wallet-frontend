import"./chunk-08p6j9h5.js";import{Bf as m,If as v,Of as Q,Vf as K,_f as A}from"./chunk-0bt0m5cf.js";import{cg as f,hg as g}from"./chunk-g7j062ka.js";async function s({chain:C,derivationPath:H,provider:N}){let{AbstractSigner:O,Signature:W}=await import("./chunk-vns5xsm8.js");class L extends O{address;chain;derivationPath;provider;constructor({chain:M,derivationPath:P,provider:S}){super(S);this.address="",this.chain=M,this.derivationPath=P,this.provider=S}getAddress=async()=>{if(!this.address){let{default:M}=await import("./chunk-01k98v18.js"),P=await M.ethereumGetAddress({path:K(this.derivationPath),showOnTrezor:!0});if(!P.success)throw new Q({errorKey:"wallet_trezor_failed_to_get_address",info:{...P,chain:this.chain,derivationPath:this.derivationPath}});this.address=P.payload.address}return this.address};signMessage=async(M)=>{let{default:P}=await import("./chunk-01k98v18.js"),S=await P.ethereumSignMessage({path:K(this.derivationPath),message:M});if(!S.success)throw new Q({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...S,message:M,chain:this.chain,derivationPath:this.derivationPath}});return S.payload.signature};signTypedData(){throw new Error("Not implemented")}signTransaction=async({to:M,gasLimit:P,value:S,data:d,nonce:l,maxFeePerGas:y,maxPriorityFeePerGas:F,gasPrice:G})=>{if(!M)throw new Q({errorKey:"wallet_missing_params",info:{to:M}});if(!P)throw new Q({errorKey:"wallet_missing_params",info:{gasLimit:P}});let x=y&&F;if(x&&!y)throw new Q({errorKey:"wallet_missing_params",info:{maxFeePerGas:y}});if(x&&!F)throw new Q({errorKey:"wallet_missing_params",info:{maxPriorityFeePerGas:F}});if(!(x||G))throw new Q({errorKey:"wallet_missing_params",info:{gasPrice:G}});let{default:p}=await import("./chunk-01k98v18.js"),{toHexString:T}=await import("./chunk-j77m4nfh.js"),{Transaction:I}=await import("./chunk-vns5xsm8.js"),Z=x?{maxFeePerGas:T(BigInt(y?.toString()||0)),maxPriorityFeePerGas:T(BigInt(F?.toString()||0))}:G&&{gasPrice:T(BigInt(G?.toString()||0))}||{gasPrice:"0x0"},$=T(BigInt(l||await this.provider.getTransactionCount(await this.getAddress(),"pending"))),_={chainId:Number.parseInt(m[this.chain]),to:M.toString(),value:T(BigInt(S?.toString()||0)),gasLimit:T(BigInt(P?.toString()||0)),nonce:$,data:d?.toString()||"0x",...Z},{success:z,payload:a}=await p.ethereumSignTransaction({path:K(this.derivationPath),transaction:_});if(!z)throw new Q({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...a,chain:this.chain,derivationPath:this.derivationPath}});let{r:E,s:Y,v:h}=a,u=W.from({r:E,s:Y,v:new A(BigInt(h)).getBaseValue("number")}),i=I.from({..._,nonce:Number.parseInt(_.nonce,16),type:x?2:0,signature:u}).serialized;if(!i)throw new Q({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:this.chain,derivationPath:this.derivationPath}});return i};connect=(M)=>{if(!M)throw new Q({errorKey:"wallet_provider_not_found",info:{wallet:v.TREZOR,chain:this.chain,derivationPath:this.derivationPath}});return new L({chain:this.chain,derivationPath:this.derivationPath,provider:M})}}return new L({chain:C,derivationPath:H,provider:N})}export{s as getEVMSigner};

//# debugId=42FCAA472BE9DCE664756E2164756E21
