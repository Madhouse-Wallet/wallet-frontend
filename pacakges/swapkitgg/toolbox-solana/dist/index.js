import{mnemonicToSeedSync as $}from"@scure/bip39";import{createMemoInstruction as y}from"@solana/spl-memo";import{TOKEN_PROGRAM_ID as F,createAssociatedTokenAccountInstruction as H,createTransferCheckedInstruction as U,getAccount as p,getAssociatedTokenAddress as J}from"@solana/spl-token";import{TokenListProvider as D}from"@solana/spl-token-registry";import{Connection as L,Keypair as P,PublicKey as j,SystemProgram as B,Transaction as N,sendAndConfirmTransaction as I}from"@solana/web3.js";import{AssetValue as Q,Chain as v,DerivationPath as V,SwapKitError as M,SwapKitNumber as l,getRPCUrl as K}from"@swapkit/helpers";import{HDKey as f}from"micro-key-producer/slip10.js";function z(g){try{let T=new j(g);return j.isOnCurve(T.toBytes())}catch(T){return!1}}function k({phrase:g,derivationPath:T=V.SOL}){let x=$(g),O=f.fromMasterSeed(x);return P.fromSeed(O.derive(T,!0).privateKey)}function A(g){return g.publicKey.toString()}async function u({connection:g,address:T}){let x=await g.getParsedTokenAccountsByOwner(new j(T),{programId:F}),w=(await new D().resolve()).filterByChainId(101).getList(),h=new Map;for await(let E of x.value){let S=E.account.data.parsed.info,C=S.mint,W=S.tokenAmount.decimals,b=BigInt(S.tokenAmount.amount);if(b<=BigInt(0))continue;let Z=w.find((_)=>_.address===C)?.symbol??"UNKNOWN",G=h.get(C);h.set(C,{amount:G?G.amount+b:b,decimal:W,symbol:Z})}return Array.from(h.entries()).map(([E,{amount:S,decimal:C,symbol:W}])=>new Q({value:l.fromBigInt(S,C),decimal:C,identifier:`${v.Solana}.${W}${E?`-${E.toString()}`:""}`}))}function o(g){return async(T)=>{let x=await g.getBalance(new j(T)),O=await u({connection:g,address:T});return[Q.from({chain:v.Solana,value:BigInt(x)}),...O]}}async function X({tokenAddress:g,recipient:T,from:x,connection:O,amount:q,decimals:w}){let h=new N,R=new j(g),E=await J(R,x),S=new j(T),C=await J(R,S),W=!1;try{await p(O,C),W=!0}catch(b){}if(!W)h.add(H(x,C,S,R));return h.add(U(E,R,C,x,q,w)),h}function Y(g){return async({recipient:T,assetValue:x,fromPublicKey:O,memo:q,isProgramDerivedAddress:w})=>{if(!(w||z(T)))throw new M("core_transaction_invalid_recipient_address");let h=x.isGasAsset?new N().add(B.transfer({fromPubkey:O,lamports:x.getBaseValue("number"),toPubkey:new j(T)})):x.address?await X({amount:x.getBaseValue("number"),connection:g,decimals:x.decimal,from:O,recipient:T,tokenAddress:x.address}):void 0;if(!h)throw new M("core_transaction_invalid_sender_address");if(q)h.add(y(q));let R=await g.getLatestBlockhash();return h.recentBlockhash=R.blockhash,h.feePayer=O,h}}function d(g){return async({recipient:T,assetValue:x,fromKeypair:O,memo:q,isProgramDerivedAddress:w})=>{let h=await Y(g)({recipient:T,assetValue:x,memo:q,fromPublicKey:O.publicKey,isProgramDerivedAddress:w});return I(g,h,[O])}}function m(g){return(T)=>{return g.sendRawTransaction(T.serialize())}}var n=({rpcUrl:g=K(v.Solana)}={})=>{let T=new L(g,"confirmed");return{connection:T,createKeysForPath:k,getAddressFromKeys:A,createSolanaTransaction:Y(T),getBalance:o(T),transfer:d(T),broadcastTransaction:m(T),validateAddress:z}};export{z as validateAddress,X as createSolanaTokenTransaction,n as SOLToolbox};

//# debugId=87A596EA74018FE264756E2164756E21
