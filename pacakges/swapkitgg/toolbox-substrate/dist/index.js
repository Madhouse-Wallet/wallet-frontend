import{Keyring as F}from"@polkadot/api";import{hexToU8a as n,isHex as B,u8aToHex as b}from"@polkadot/util";import{cryptoWaitReady as c,decodeAddress as T,encodeAddress as C}from"@polkadot/util-crypto";import{Chain as N,SwapKitError as P,SwapKitNumber as H}from"@swapkit/helpers";var _={prefix:0,network:"polkadot",displayName:"Polkadot Relay Chain",symbols:["DOT"],decimals:[10],standardAccount:"*25519",website:"https://polkadot.network"},$={prefix:2112,network:"chainflip",displayName:"Chainflip",symbols:["FLIP"],decimals:[18],standardAccount:"*25519",website:"https://chainflip.io/"},x={prefix:42,network:"substrate",displayName:"Substrate",symbols:[],decimals:[],standardAccount:"*25519",website:"https://substrate.io/"},M={DOT:_,FLIP:$,GENERIC:x};var v=(t)=>{return"address"in t},V=async(t,o)=>{return await c(),new F({type:"sr25519",ss58Format:o}).addFromUri(t)},p=(t,o)=>t.rpc.system.accountNextIndex(o),h=async(t,o,I)=>{let f=await t.query.system?.account?.(I);if(!f?.data?.free||f?.data?.isEmpty)return[o.set(0)];return[o.set(H.fromBigInt(BigInt(f.data.free.toString()),o.decimal).getValue("string"))]},E=(t,o)=>{try{let I=O(t,o);return q(I,"ss58",o),!0}catch(I){return!1}},G=(t,{recipient:o,amount:I})=>t.tx.balances?.transferAllowDeath?.(o,I),U=async(t,o,{recipient:I,assetValue:f,from:j})=>{let m=G(t,{recipient:I,amount:f.getBaseValue("number")}),y=v(o);if(!m)return;let u=j||(y?o.address:void 0);if(!u)throw new P("core_transaction_invalid_sender_address");let R=await p(t,u);return(await m.signAndSend(y?o:u,{signer:y?void 0:o,nonce:R}))?.toString()},w=async(t,o,I,{recipient:f,assetValue:j,from:m})=>{let y=G(t,{recipient:f,amount:j.getBaseValue("number")}),u=m||v(o)&&o.address;if(!u)return;let R=await y?.paymentInfo(u,{nonce:await p(t,u)})||{partialFee:0};return I.set(H.fromBigInt(BigInt(R.partialFee.toString()),I.decimal).getValue("string"))},K=async(t,o)=>{if(o)return t.send(o);return(await t.send()).toString()},e=async(t,o)=>{return await o.signAsync(t)},A=(t,o,I)=>{if(I)return o.signAndSend(t,I);return o.signAndSend(t).toString()},k=async({signer:t,address:o,tx:I,callback:f,api:j})=>{let m=await p(j,o);if(f)I.signAndSend(o,{nonce:m,signer:t},f);return I.signAndSend(o,{nonce:m,signer:t}).toString()};function O(t,o){return B(t)?n(t):T(t,void 0,o)}function q(t,o="ss58",I){if(o==="hex")return b(t);return C(t,I)}var z=({api:t,network:o,gasAsset:I,signer:f})=>({api:t,network:o,decodeAddress:O,encodeAddress:q,createKeyring:(j)=>V(j,o.prefix),getAddress:(j=f)=>v(j)?j.address:void 0,createTransfer:({recipient:j,assetValue:m})=>G(t,{recipient:j,amount:m.getBaseValue("number")}),getBalance:(j)=>h(t,I,j),validateAddress:(j)=>E(j,o.prefix),transfer:(j)=>U(t,f,j),estimateTransactionFee:(j)=>w(t,f,I,j),sign:(j)=>{if(v(f))return e(f,j);throw new P("core_wallet_not_keypair_wallet","Signer does not have keyring pair capabilities required for signing.")},broadcast:(j,m)=>K(j,m),signAndBroadcast:({tx:j,callback:m,address:y})=>{if(v(f))return A(f,j,m);if(y)return k({signer:f,address:y,tx:j,callback:m,api:t});throw new P("core_wallet_not_keypair_wallet","Signer does not have keyring pair capabilities required for signing.")}}),It=({address:t,chain:o})=>{switch(o){case N.Polkadot:return E(t,M.DOT.prefix)||E(t,M.GENERIC.prefix);case N.Chainflip:return E(t,M.FLIP.prefix)||E(t,M.GENERIC.prefix)}return!1};import{ApiPromise as J,WsProvider as Q}from"@polkadot/api";import{AssetValue as S,Chain as D,SwapKitNumber as l,getRPCUrl as W}from"@swapkit/helpers";var X=async({providerUrl:t,generic:o,chain:I,signer:f})=>{let j=new Q(t),m=await J.create({provider:j}),y=S.from({chain:I});return z({api:m,signer:f,gasAsset:y,network:o?M.GENERIC:M[I]})},g=({providerUrl:t,signer:o,generic:I=!1})=>{return X({providerUrl:t||W(D.Polkadot),chain:D.Polkadot,generic:I,signer:o})},i=async({providerUrl:t,signer:o,generic:I=!1})=>{let f=t||W(D.Chainflip),j=new Q(f),m=await J.create({provider:j}),y=S.from({chain:D.Chainflip});async function u(L,Y){let{balance:Z}=await L.query.flip?.account?.(Y);return[y.set(l.fromBigInt(BigInt(Z.toString()),y.decimal).getValue("string"))]}return{...await X({chain:D.Chainflip,signer:o,providerUrl:f,generic:I}),getBalance:async(L)=>u(m,L)}},Mt=(t,o)=>{switch(t){case D.Chainflip:return i(o);case D.Polkadot:return g(o);default:throw new Error(`Chain ${t} is not supported`)}};export{x as subtrateNetwork,It as substrateValidateAddress,_ as polkadotNetwork,v as isKeyringPair,Mt as getToolboxByChain,V as createKeyring,$ as chainflipNetwork,X as ToolboxFactory,g as PolkadotToolbox,M as Network,i as ChainflipToolbox,z as BaseSubstrateToolbox};

//# debugId=B19B35685AE7334364756E2164756E21
