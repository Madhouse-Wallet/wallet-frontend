import{a as M,c as Q}from"./chunk-nm00d52v.js";import{ChainToChainId as G,SwapKitError as B,SwapKitNumber as h,WalletOption as F,derivationPathToString as $}from"@swapkit/helpers";async function l({chain:W,derivationPath:k,provider:N}){let{AbstractSigner:f,Signature:_}=await import("./chunk-7r0bsnk5.js");class Y extends f{address;chain;derivationPath;provider;constructor({chain:j,derivationPath:q,provider:D}){super(D);this.address="",this.chain=j,this.derivationPath=q,this.provider=D}getAddress=async()=>{if(!this.address){let{default:j}=await import("@trezor/connect-web"),q=await j.ethereumGetAddress({path:$(this.derivationPath),showOnTrezor:!0});if(!q.success)throw new B({errorKey:"wallet_trezor_failed_to_get_address",info:{...q,chain:this.chain,derivationPath:this.derivationPath}});this.address=q.payload.address}return this.address};signMessage=async(j)=>{let{default:q}=await import("@trezor/connect-web"),D=await q.ethereumSignMessage({path:$(this.derivationPath),message:j});if(!D.success)throw new B({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...D,message:j,chain:this.chain,derivationPath:this.derivationPath}});return D.payload.signature};signTypedData(){throw new Error("Not implemented")}signTransaction=async({to:j,gasLimit:q,value:D,data:H,nonce:I,maxFeePerGas:U,maxPriorityFeePerGas:V,gasPrice:X})=>{if(!j)throw new B({errorKey:"wallet_missing_params",info:{to:j}});if(!q)throw new B({errorKey:"wallet_missing_params",info:{gasLimit:q}});let R=U&&V;if(R&&!U)throw new B({errorKey:"wallet_missing_params",info:{maxFeePerGas:U}});if(R&&!V)throw new B({errorKey:"wallet_missing_params",info:{maxPriorityFeePerGas:V}});if(!(R||X))throw new B({errorKey:"wallet_missing_params",info:{gasPrice:X}});let{default:L}=await import("@trezor/connect-web"),{toHexString:J}=await import("@swapkit/toolbox-evm"),{Transaction:b}=await import("./chunk-7r0bsnk5.js"),C=R?{maxFeePerGas:J(BigInt(U?.toString()||0)),maxPriorityFeePerGas:J(BigInt(V?.toString()||0))}:X&&{gasPrice:J(BigInt(X?.toString()||0))}||{gasPrice:"0x0"},K=J(BigInt(I||await this.provider.getTransactionCount(await this.getAddress(),"pending"))),Z={chainId:Number.parseInt(G[this.chain]),to:j.toString(),value:J(BigInt(D?.toString()||0)),gasLimit:J(BigInt(q?.toString()||0)),nonce:K,data:H?.toString()||"0x",...C},{success:u,payload:A}=await L.ethereumSignTransaction({path:$(this.derivationPath),transaction:Z});if(!u)throw new B({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...A,chain:this.chain,derivationPath:this.derivationPath}});let{r:z,s:y,v:w}=A,E=_.from({r:z,s:y,v:new h(BigInt(w)).getBaseValue("number")}),O=b.from({...Z,nonce:Number.parseInt(Z.nonce,16),type:R?2:0,signature:E}).serialized;if(!O)throw new B({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:this.chain,derivationPath:this.derivationPath}});return O};connect=(j)=>{if(!j)throw new B({errorKey:"wallet_provider_not_found",info:{wallet:F.TREZOR,chain:this.chain,derivationPath:this.derivationPath}});return new Y({chain:this.chain,derivationPath:this.derivationPath,provider:j})}}return new Y({chain:W,derivationPath:k,provider:N})}export{l as getEVMSigner};

//# debugId=D0E141C3555726B364756E2164756E21
