import{a as H,c as M}from"./chunk-nm00d52v.js";import{Chain as j,FeeOption as T,SwapKitError as V,WalletOption as k,derivationPathToString as b,filterSupportedChains as v,pickEvmApiKey as A,setRequestClientConfig as K}from"@swapkit/helpers";var y=[j.Arbitrum,j.Avalanche,j.Base,j.BinanceSmartChain,j.Bitcoin,j.BitcoinCash,j.Dash,j.Dogecoin,j.Ethereum,j.Litecoin,j.Optimism,j.Polygon];function m(X){switch(X[0]){case 84:return{input:"SPENDWITNESS",output:"PAYTOWITNESS"};case 49:return{input:"SPENDP2SHWITNESS",output:"PAYTOP2SHWITNESS"};case 44:return{input:"SPENDADDRESS",output:"PAYTOADDRESS"};default:return null}}async function C({apis:X,rpcUrl:z,chain:G,derivationPath:$,blockchairApiKey:O,ethplorerApiKey:f,covalentApiKey:w}){switch(G){case j.BinanceSmartChain:case j.Avalanche:case j.Arbitrum:case j.Optimism:case j.Polygon:case j.Base:case j.Ethereum:{let{getProvider:W,getToolboxByChain:S}=await import("@swapkit/toolbox-evm"),{getEVMSigner:E}=await import("./chunk-d73yxs6y.js"),Z=X?.[G],N=A({chain:G,ethApiKey:f,nonEthApiKey:w}),Q=W(G,z),B=S(G),L=await E({chain:G,derivationPath:$,provider:Q});return{address:await L.getAddress(),walletMethods:B({api:Z,apiKey:N,provider:Q,signer:L})}}case j.Bitcoin:case j.BitcoinCash:case j.Dash:case j.Dogecoin:case j.Litecoin:{let{toCashAddress:W,getToolboxByChain:S,BCHToolbox:E}=await import("@swapkit/toolbox-utxo"),Z=X?.[G];if(!(O||Z))throw new V({errorKey:"wallet_missing_api_key",info:{missingKey:"blockchairApiKey"}});let N=m($);if(!N)throw new V({errorKey:"wallet_trezor_derivation_path_not_supported",info:{derivationPath:$}});let Q=G.toLowerCase(),B={apiClient:Z,apiKey:O,rpcUrl:z},L=S(G)(B),_=await(async(q=$)=>{let{default:D}=await import("@trezor/connect-web"),{success:R,payload:F}=await D.getAddress({path:b(q),coin:Q});if(!R)throw new V({errorKey:"wallet_trezor_failed_to_get_address",info:{chain:G,error:F.error||"Unknown error"}});return G===j.BitcoinCash?L.stripPrefix(F.address):F.address})(),P=async(q,D,R="")=>{let{default:F}=await import("@trezor/connect-web"),I=$.map((J,Y)=>Y<3?(J|2147483648)>>>0:J),U=await F.signTransaction({coin:Q,inputs:D.map((J)=>({address_n:I,prev_hash:J.hash,prev_index:J.index,amount:J.value,script_type:N.input})),outputs:q.txOutputs.map((J)=>{let Y=G===j.BitcoinCash&&J.address?W(J.address):J.address,x=G===j.BitcoinCash&&Y?L.stripPrefix(Y)===_:Y===_;if(!J.address)return{amount:"0",op_return_data:Buffer.from(R).toString("hex"),script_type:"PAYTOOPRETURN"};if(x)return{address_n:I,amount:J.value,script_type:N.output};return{address:Y,amount:J.value,script_type:"PAYTOADDRESS"}})});if(U.success)return U.payload.serializedTx;throw new V({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:G,error:U.payload.error}})};return{address:_,walletMethods:{...L,transfer:async({from:q,recipient:D,feeOptionKey:R,feeRate:F,memo:I,...U})=>{if(!q)throw new V({errorKey:"wallet_missing_params",info:{wallet:k.TREZOR,memo:I,from:q}});if(!D)throw new V({errorKey:"wallet_missing_params",info:{wallet:k.TREZOR,memo:I,recipient:D}});let{psbt:J,inputs:Y}=await L.buildTx({...U,memo:I,recipient:D,feeRate:F||(await L.getFeeRates())[R||T.Fast],sender:q,fetchTxHex:G===j.Dogecoin}),x=await P(J,Y,I);return L.broadcastTx(x)},signTransaction:P}}}default:throw new V({errorKey:"wallet_chain_not_supported",info:{chain:G,wallet:k.TREZOR}})}}function u({apis:X,rpcUrls:z,addChain:G,config:{covalentApiKey:$,ethplorerApiKey:O,blockchairApiKey:f,trezorManifest:w={appUrl:"",email:""},thorswapApiKey:W}}){return async function S(E,Z){let Q=v(E,y,k.TREZOR)[0];if(!Q)return!1;K({apiKey:W});let{default:B}=await import("@trezor/connect-web"),{success:L}=await B.getDeviceState();if(!L)B.init({lazyLoad:!0,manifest:w});let{address:g,walletMethods:_}=await C({apis:X,rpcUrl:z[Q],chain:Q,covalentApiKey:$,ethplorerApiKey:O,blockchairApiKey:f,derivationPath:Z});return G({chain:Q,..._,address:g,balance:[],walletType:k.TREZOR}),!0}}var s={connectTrezor:u};export{s as trezorWallet,y as TREZOR_SUPPORTED_CHAINS};

//# debugId=8A72A9B754F5F01164756E2164756E21
