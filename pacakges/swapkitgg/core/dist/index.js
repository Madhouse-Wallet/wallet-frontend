var B$=Object.create;var{getPrototypeOf:L$,defineProperty:y,getOwnPropertyNames:_$}=Object;var j$=Object.prototype.hasOwnProperty;var D=(_,j,J)=>{J=_!=null?B$(L$(_)):{};let T=j||!_||!_.__esModule?y(J,"default",{value:_,enumerable:!0}):J;for(let P of _$(_))if(!j$.call(T,P))y(T,P,{get:()=>_[P],enumerable:!0});return T};var H=((_)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(_,{get:(j,J)=>(typeof require!=="undefined"?require:j)[J]}):_)(function(_){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+_+'" is not supported')});export*from"@swapkit/api";export*from"@swapkit/helpers";import{SwapKitApi as M}from"@swapkit/api";import{ApproveMode as N,AssetValue as S,Chain as x,EVMChains as x$,ProviderName as d,SwapKitError as U}from"@swapkit/helpers";import{Chain as q,ChainToExplorerUrl as V,SwapKitError as q$}from"@swapkit/helpers";function W({chain:_,txHash:j}){let J=V[_];switch(_){case q.Maya:case q.Kujira:case q.Cosmos:case q.THORChain:case q.Solana:return`${J}/tx/${j.startsWith("0x")?j.slice(2):j}`;case q.Arbitrum:case q.Avalanche:case q.BinanceSmartChain:case q.Base:case q.Ethereum:case q.Optimism:case q.Polkadot:case q.Polygon:return`${J}/tx/${j.startsWith("0x")?j:`0x${j}`}`;case q.Litecoin:case q.Bitcoin:case q.BitcoinCash:case q.Dogecoin:case q.Radix:return`${J}/transaction/${j.toLowerCase()}`;default:throw new q$({errorKey:"core_explorer_unsupported_chain",info:{chain:_}})}}function K({chain:_,address:j}){let J=V[_];switch(_){case q.Solana:case q.Radix:return`${J}/account/${j}`;default:return`${J}/address/${j}`}}function Y$({apis:_={},config:j={},plugins:J,rpcUrls:T={},wallets:P={}}={}){let C=j.stagenet,O=j.swapkitConfig?.isDev,Y={},Z=Object.entries(J||{}).reduce(($,[R,{plugin:B,config:L}])=>{let G=B({getWallet:Q,stagenet:C,config:L??j});return $[R]=G,$},{}),o=Object.entries(P).reduce(($,[R,B])=>{let L=B({addChain:h,config:j,apis:_,rpcUrls:T});return $[R]=L,$},{});function u($){let R=Z[$]||Object.values(Z)[0];if(!R)throw new U("core_plugin_not_found");return R}function w($){let R=Object.values(Z).find((B)=>B.supportedSwapkitProviders?.includes($));if(!R)throw new U("core_plugin_not_found");return R}function h($){let R=Q($.chain);Y[$.chain]={...R,...$}}function f({assetValue:$,type:R="checkOnly",contractAddress:B}){let L=Z[B];if(L){if(R===N.CheckOnly&&"isAssetValueApproved"in L)return L.isAssetValueApproved({assetValue:$});if(R===N.Approve&&"approveAssetValue"in L)return L.approveAssetValue({assetValue:$});throw new U({errorKey:"core_approve_asset_target_invalid",info:{message:`Target ${String(B)} cannot be used for approve operation`}})}let G=$.chain,E=x$.includes(G);if(E&&$.isGasAsset||!E||$.isSynthetic)return Promise.resolve(R==="checkOnly"?!0:"approved");let X=Q(G),b=R==="checkOnly"?X.isApproved:X.approve;if(!b)throw new U("core_wallet_connection_not_found");if(!($.address&&X.address&&typeof B==="string"))throw new U("core_approve_asset_address_or_from_not_found");return b({amount:$.getBaseValue("bigint"),assetAddress:$.address,from:X.address,spenderAddress:B})}function Q($){return Y[$]}function c(){return{...Y}}function r($){return Q($)?.address||""}function g($,R){return f({assetValue:$,contractAddress:R,type:N.Approve})}function s($,R){return f({assetValue:$,contractAddress:R,type:N.CheckOnly})}function m($){Q($)?.disconnect?.(),delete Y[$]}function n(){for(let $ of Object.keys(Y))m($)}function p($,R){return R?A($).then(({balance:B})=>B):Q($)?.balance||[]}function i($){throw new U("not_implemented",{message:"validateAddress is deprecated - use toolbox directly or import { getAddressValidator } from '@swapkit/core'"})}async function A($,R=!0){if($===x.Fiat||!Q($))throw new U("core_wallet_connection_not_found");let B=Q($),L=[S.from({chain:$})];if("getBalance"in B){let G=await B.getBalance(B.address,R);B.balance=G?.length?G:L}return B}function t({route:$,pluginName:R,...B}){let L=R&&u(R)||w($.providers[0]);if(!L)throw new U("core_swap_route_not_complete");if("swap"in L)return L.swap({...B,route:$});throw new U("core_plugin_swap_not_found")}function l({assetValue:$,...R}){let B=$.chain;if([x.Fiat,x.Radix].includes(B)||!Q(B))throw new U("core_wallet_connection_not_found");return Q(B).transfer({...R,assetValue:$})}function a({chain:$,message:R}){let B=Q($);if(!B)throw new U("core_wallet_connection_not_found");if("signMessage"in B)return B.signMessage?.(R);throw new U({errorKey:"core_wallet_sign_message_not_supported",info:{chain:$,wallet:B.walletType}})}async function e({address:$,chain:R,message:B,signature:L}){switch(R){case x.THORChain:{let{getToolboxByChain:G}=await import("@swapkit/toolbox-cosmos");return G(R)().verifySignature({signature:L,message:B,address:$})}default:throw new U({errorKey:"core_verify_message_not_supported",info:{chain:R}})}}async function $$({type:$,feeOptionKey:R,params:B}){let{assetValue:L}=B,{chain:G}=L;if(!Q(G))throw new U("core_wallet_connection_not_found");let E=S.from({chain:G});switch(G){case x.Arbitrum:case x.Avalanche:case x.Ethereum:case x.BinanceSmartChain:case x.Polygon:{let I=Q(G);if($==="transfer"){let X=await I.createTransferTx(B);return I.estimateTransactionFee(X,R)}if($==="approve"&&!L.isGasAsset)return I.estimateTransactionFee(await I.createApprovalTx({assetAddress:L.address,spenderAddress:B.contractAddress,amount:L.getBaseValue("bigint"),from:I.address}),R);if($==="swap"){let X=B.route.providers[0];if([d.CHAINFLIP,d.CHAINFLIP_STREAMING].includes(X)){let R$=await I.createTransferTx({from:I.address,recipient:I.address,assetValue:L});return I.estimateTransactionFee(R$,R)}let{tx:b}=B.route;if(!b)return;return I.estimateTransactionFee({...b,value:BigInt(b.value)},R)}return S.from({chain:G})}case x.Bitcoin:case x.BitcoinCash:case x.Dogecoin:case x.Dash:case x.Litecoin:{let{estimateTransactionFee:I,address:X}=Q(G);return I({...B,feeOptionKey:R,from:X,recipient:X})}case x.THORChain:case x.Maya:case x.Kujira:case x.Cosmos:{let{estimateTransactionFee:I}=await import("@swapkit/toolbox-cosmos");return I(B)}case x.Polkadot:{let{address:I,estimateTransactionFee:X}=Q(G);return X({...B,recipient:I})}default:return E}}let v=j.swapkitConfig||{},F=v?.swapkitApiKey||j?.swapkitApiKey,k=v.useHashedApiKey?v.referer:void 0;return{...Z,...o,disconnectAll:n,disconnectChain:m,estimateTransactionFee:$$,getAddress:r,getAllWallets:c,getBalance:p,getExplorerAddressUrl:K,getExplorerTxUrl:W,getWallet:Q,getWalletWithBalance:A,approveAssetValue:g,isAssetValueApproved:s,signMessage:a,swap:t,transfer:l,validateAddress:i,verifyMessage:e,api:F?{getGasRate:()=>M.getGasRate(O,F,k),getPrice:($)=>M.getPrice($,O,F,k),getSwapQuote:($)=>M.getSwapQuote($,O,F,k),getTokenList:($)=>M.getTokenList($),getTokenListProviders:()=>M.getTokenListProvidersV2(O,F,k),getTokenTradingPairs:($)=>M.getTokenTradingPairs($,O,F,k),getTrackerDetails:($)=>M.getTrackerDetails($,F,k)}:{undefined:void 0}}}import{Chain as z}from"@swapkit/helpers";async function H$(){let{cosmosValidateAddress:_}=await import("@swapkit/toolbox-cosmos"),{evmValidateAddress:j}=await import("@swapkit/toolbox-evm"),{substrateValidateAddress:J}=await import("@swapkit/toolbox-substrate"),{utxoValidateAddress:T}=await import("@swapkit/toolbox-utxo"),{validateAddress:P}=await import("@swapkit/toolbox-solana"),{validateAddress:C}=await import("@swapkit/toolbox-radix");return function O({address:Y,chain:Z}){switch(Z){case z.Arbitrum:case z.Avalanche:case z.Optimism:case z.BinanceSmartChain:case z.Base:case z.Polygon:case z.Ethereum:return j({address:Y});case z.Litecoin:case z.Dash:case z.Dogecoin:case z.BitcoinCash:case z.Bitcoin:return T({address:Y,chain:Z});case z.Cosmos:case z.Kujira:case z.Maya:case z.THORChain:return _({address:Y,chain:Z});case z.Polkadot:return J({address:Y,chain:Z});case z.Radix:return C(Y);case z.Solana:return P(Y);default:return!1}}}export{H$ as getAddressValidator,Y$ as SwapKit};

//# debugId=D1A504E9AFF2E6E164756E2164756E21
