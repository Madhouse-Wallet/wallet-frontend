{
  "version": 3,
  "sources": ["../src/index.ts", "../src/client.ts", "../src/helpers/explorerUrls.ts", "../src/helpers/walletAddressValidator.ts"],
  "sourcesContent": [
    "export * from \"@swapkit/api\";\nexport * from \"@swapkit/helpers\";\nexport * from \"./client\";\nexport * from \"./helpers/walletAddressValidator\";\n",
    "import type {\n  EVMTransaction,\n  PriceRequest,\n  QuoteRequest,\n  QuoteResponseRoute,\n  TrackerParams,\n} from \"@swapkit/api\";\nimport { SwapKitApi } from \"@swapkit/api\";\n\nimport {\n  ApproveMode,\n  type ApproveReturnType,\n  AssetValue,\n  Chain,\n  type ChainApis,\n  type ChainWallet,\n  type ConditionalAssetValueReturn,\n  type ConnectConfig,\n  type CryptoChain,\n  type EVMChain,\n  EVMChains,\n  type FeeOption,\n  type FullWallet,\n  ProviderName as PluginNameEnum,\n  SwapKitError,\n  type SwapKitPluginParams,\n  type SwapKitWallet,\n  type SwapParams,\n} from \"@swapkit/helpers\";\nimport type { TransferParams as CosmosTransferParams } from \"@swapkit/toolbox-cosmos\";\nimport type { TransferParams as EVMTransferParams } from \"@swapkit/toolbox-evm\";\nimport type { UTXOTransferParams } from \"@swapkit/toolbox-utxo\";\n\nimport {\n  getExplorerAddressUrl as getAddressUrl,\n  getExplorerTxUrl as getTxUrl,\n} from \"./helpers/explorerUrls\";\n\nexport type PluginsType = {\n  [key in string]: {\n    plugin: (params: SwapKitPluginParams<any>) => any;\n    config?: any;\n  };\n};\n\nexport type WalletsType = {\n  [key in string]: SwapKitWallet<any[]>;\n};\n\nexport type SwapKitParams<P, W> = {\n  apis?: ChainApis;\n  config?: ConnectConfig;\n  plugins?: P;\n  rpcUrls?: { [key in CryptoChain]?: string };\n  wallets?: W;\n};\n\nexport function SwapKit<Plugins extends PluginsType, Wallets extends WalletsType>({\n  apis = {},\n  config = {},\n  plugins,\n  rpcUrls = {},\n  wallets = {} as Wallets,\n}: SwapKitParams<Plugins, Wallets> = {}) {\n  const stagenet = config.stagenet;\n  const isDev = config.swapkitConfig?.isDev;\n  type PluginName = keyof Plugins;\n  const connectedWallets = {} as FullWallet;\n\n  const availablePlugins = Object.entries(plugins || {}).reduce(\n    (acc, [pluginName, { plugin, config: pluginConfig }]) => {\n      const methods = plugin({ getWallet, stagenet, config: pluginConfig ?? config });\n\n      // @ts-expect-error key is generic and cannot be indexed\n      acc[pluginName] = methods;\n      return acc;\n    },\n    {} as { [key in PluginName]: ReturnType<Plugins[key][\"plugin\"]> },\n  );\n\n  const connectWalletMethods = Object.entries(wallets).reduce(\n    (acc, [walletName, wallet]) => {\n      const connectWallet = wallet({ addChain, config, apis, rpcUrls });\n\n      // @ts-expect-error walletName is generic and cannot be indexed\n      acc[walletName] = connectWallet;\n      return acc;\n    },\n    {} as { [key in keyof Wallets]: ReturnType<Wallets[key]> },\n  );\n\n  function getSwapKitPlugin<T extends PluginName>(pluginName: T) {\n    const plugin = availablePlugins[pluginName] || Object.values(availablePlugins)[0];\n\n    if (!plugin) {\n      throw new SwapKitError(\"core_plugin_not_found\");\n    }\n\n    return plugin;\n  }\n\n  function getSwapKitPluginForSKProvider(pluginName: PluginNameEnum): Plugins[keyof Plugins] {\n    const plugin = Object.values(availablePlugins).find((plugin) =>\n      plugin.supportedSwapkitProviders?.includes(pluginName),\n    );\n\n    if (!plugin) {\n      throw new SwapKitError(\"core_plugin_not_found\");\n    }\n\n    return plugin;\n  }\n\n  function addChain<T extends CryptoChain>(connectWallet: ChainWallet<T>) {\n    const currentWallet = getWallet(connectWallet.chain);\n\n    connectedWallets[connectWallet.chain] = { ...currentWallet, ...connectWallet };\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: <explanation>\n  function approve<T extends ApproveMode>({\n    assetValue,\n    type = \"checkOnly\" as T,\n    contractAddress: spenderAddress,\n  }: {\n    type: T;\n    assetValue: AssetValue;\n    contractAddress: string | PluginName;\n  }) {\n    const plugin = availablePlugins[spenderAddress];\n\n    if (plugin) {\n      if (type === ApproveMode.CheckOnly && \"isAssetValueApproved\" in plugin) {\n        return plugin.isAssetValueApproved({ assetValue }) as ApproveReturnType<T>;\n      }\n      if (type === ApproveMode.Approve && \"approveAssetValue\" in plugin) {\n        return plugin.approveAssetValue({ assetValue }) as ApproveReturnType<T>;\n      }\n\n      throw new SwapKitError({\n        errorKey: \"core_approve_asset_target_invalid\",\n        info: { message: `Target ${String(spenderAddress)} cannot be used for approve operation` },\n      });\n    }\n\n    const chain = assetValue.chain as EVMChain;\n    const isEVMChain = EVMChains.includes(chain);\n    const isNativeEVM = isEVMChain && assetValue.isGasAsset;\n\n    if (isNativeEVM || !isEVMChain || assetValue.isSynthetic) {\n      return Promise.resolve(type === \"checkOnly\" ? true : \"approved\") as ApproveReturnType<T>;\n    }\n\n    const wallet = getWallet(chain);\n    const walletAction = type === \"checkOnly\" ? wallet.isApproved : wallet.approve;\n    if (!walletAction) throw new SwapKitError(\"core_wallet_connection_not_found\");\n\n    if (!(assetValue.address && wallet.address && typeof spenderAddress === \"string\")) {\n      throw new SwapKitError(\"core_approve_asset_address_or_from_not_found\");\n    }\n\n    return walletAction({\n      amount: assetValue.getBaseValue(\"bigint\"),\n      assetAddress: assetValue.address,\n      from: wallet.address,\n      spenderAddress,\n    }) as ApproveReturnType<T>;\n  }\n\n  /**\n   * @Public\n   */\n  function getWallet<T extends Chain>(chain: T) {\n    return connectedWallets[chain];\n  }\n\n  function getAllWallets() {\n    return { ...connectedWallets };\n  }\n\n  function getAddress<T extends Chain>(chain: T) {\n    return getWallet(chain)?.address || \"\";\n  }\n\n  function approveAssetValue(assetValue: AssetValue, contractAddress: string | PluginName) {\n    return approve({ assetValue, contractAddress, type: ApproveMode.Approve });\n  }\n\n  function isAssetValueApproved(assetValue: AssetValue, contractAddress: string | PluginName) {\n    return approve({ assetValue, contractAddress, type: ApproveMode.CheckOnly });\n  }\n\n  function disconnectChain<T extends Chain>(chain: T) {\n    const wallet = getWallet(chain);\n    wallet?.disconnect?.();\n    delete connectedWallets[chain];\n  }\n\n  function disconnectAll() {\n    for (const chain of Object.keys(connectedWallets) as (keyof typeof connectedWallets)[]) {\n      disconnectChain(chain);\n    }\n  }\n\n  function getBalance<T extends Chain, R extends boolean>(\n    chain: T,\n    refresh?: R,\n  ): ConditionalAssetValueReturn<R> {\n    return (\n      refresh\n        ? getWalletWithBalance(chain).then(({ balance }) => balance)\n        : getWallet(chain)?.balance || []\n    ) as ConditionalAssetValueReturn<R>;\n  }\n\n  /**\n   * @deprecated - use toolbox directly or use getAddressValidator() function\n   */\n  function validateAddress(_: { address: string; chain: Chain }) {\n    throw new SwapKitError(\"not_implemented\", {\n      message:\n        \"validateAddress is deprecated - use toolbox directly or import { getAddressValidator } from '@swapkit/core'\",\n    });\n  }\n\n  async function getWalletWithBalance<T extends Chain>(chain: T, potentialScamFilter = true) {\n    if (chain === Chain.Fiat || !getWallet(chain)) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n    const wallet = getWallet(chain as Exclude<Chain, Chain.Fiat>);\n    const defaultBalance = [AssetValue.from({ chain })];\n\n    if (\"getBalance\" in wallet) {\n      const balance = await wallet.getBalance(wallet.address, potentialScamFilter);\n      wallet.balance = balance?.length ? balance : defaultBalance;\n    }\n\n    return wallet;\n  }\n\n  function swap<T extends PluginName>({\n    route,\n    pluginName,\n    ...rest\n  }: SwapParams<T, QuoteResponseRoute>) {\n    const plugin =\n      (pluginName && getSwapKitPlugin(pluginName)) ||\n      getSwapKitPluginForSKProvider(route.providers[0] as PluginNameEnum);\n\n    if (!plugin) throw new SwapKitError(\"core_swap_route_not_complete\");\n\n    if (\"swap\" in plugin) {\n      return plugin.swap({ ...rest, route });\n    }\n\n    throw new SwapKitError(\"core_plugin_swap_not_found\");\n  }\n\n  function transfer({\n    assetValue,\n    ...params\n  }: UTXOTransferParams | EVMTransferParams | CosmosTransferParams) {\n    const chain = assetValue.chain;\n    if ([Chain.Fiat, Chain.Radix].includes(chain) || !getWallet(chain)) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n    const wallet = getWallet(chain as Exclude<Chain, Chain.Fiat | Chain.Radix>);\n\n    return wallet.transfer({ ...params, assetValue });\n  }\n\n  function signMessage({ chain, message }: { chain: Chain; message: string }) {\n    const wallet = getWallet(chain);\n    if (!wallet) throw new SwapKitError(\"core_wallet_connection_not_found\");\n\n    if (\"signMessage\" in wallet) {\n      return wallet.signMessage?.(message);\n    }\n\n    throw new SwapKitError({\n      errorKey: \"core_wallet_sign_message_not_supported\",\n      info: { chain, wallet: wallet.walletType },\n    });\n  }\n\n  async function verifyMessage({\n    address,\n    chain,\n    message,\n    signature,\n  }: { chain: Chain; signature: string; message: string; address: string }) {\n    switch (chain) {\n      case Chain.THORChain: {\n        const { getToolboxByChain } = await import(\"@swapkit/toolbox-cosmos\");\n        const toolbox = getToolboxByChain(chain);\n        return toolbox().verifySignature({ signature, message, address });\n      }\n\n      default:\n        throw new SwapKitError({ errorKey: \"core_verify_message_not_supported\", info: { chain } });\n    }\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO clean this up\n  async function estimateTransactionFee<T extends PluginName>({\n    type,\n    feeOptionKey,\n    params,\n  }: (\n    | { type: \"swap\"; params: SwapParams<T, QuoteResponseRoute> & { assetValue: AssetValue } }\n    | { type: \"transfer\"; params: UTXOTransferParams | EVMTransferParams | CosmosTransferParams }\n    | {\n        type: \"approve\";\n        params: {\n          assetValue: AssetValue;\n          contractAddress: string | PluginName;\n          feeOptionKey?: FeeOption;\n        };\n      }\n  ) & {\n    feeOptionKey: FeeOption;\n  }): Promise<AssetValue | undefined> {\n    const { assetValue } = params;\n    const { chain } = assetValue;\n\n    if (!getWallet(chain as Chain)) throw new SwapKitError(\"core_wallet_connection_not_found\");\n\n    const baseValue = AssetValue.from({ chain });\n\n    switch (chain) {\n      case Chain.Arbitrum:\n      case Chain.Avalanche:\n      case Chain.Ethereum:\n      case Chain.BinanceSmartChain:\n      case Chain.Polygon: {\n        const wallet = getWallet(chain);\n        if (type === \"transfer\") {\n          const txObject = await wallet.createTransferTx(params);\n          return wallet.estimateTransactionFee(txObject, feeOptionKey);\n        }\n\n        if (type === \"approve\" && !assetValue.isGasAsset) {\n          return wallet.estimateTransactionFee(\n            await wallet.createApprovalTx({\n              assetAddress: assetValue.address as string,\n              spenderAddress: params.contractAddress as string,\n              amount: assetValue.getBaseValue(\"bigint\"),\n              from: wallet.address,\n            }),\n            feeOptionKey,\n          );\n        }\n\n        if (type === \"swap\") {\n          const plugin = params.route.providers[0] as PluginNameEnum;\n          if ([PluginNameEnum.CHAINFLIP, PluginNameEnum.CHAINFLIP_STREAMING].includes(plugin)) {\n            const txObject = await wallet.createTransferTx({\n              from: wallet.address,\n              recipient: wallet.address,\n              assetValue,\n            });\n            return wallet.estimateTransactionFee(txObject, feeOptionKey);\n          }\n\n          const { tx } = params.route;\n          if (!tx) {\n            return undefined;\n          }\n\n          return wallet.estimateTransactionFee(\n            { ...(tx as EVMTransaction), value: BigInt((tx as EVMTransaction).value) },\n            feeOptionKey,\n          );\n        }\n\n        return AssetValue.from({ chain });\n      }\n\n      case Chain.Bitcoin:\n      case Chain.BitcoinCash:\n      case Chain.Dogecoin:\n      case Chain.Dash:\n      case Chain.Litecoin: {\n        const { estimateTransactionFee, address } = getWallet(chain);\n\n        return estimateTransactionFee({\n          ...params,\n          feeOptionKey,\n          from: address,\n          recipient: address,\n        });\n      }\n\n      case Chain.THORChain:\n      case Chain.Maya:\n      case Chain.Kujira:\n      case Chain.Cosmos: {\n        const { estimateTransactionFee } = await import(\"@swapkit/toolbox-cosmos\");\n        return estimateTransactionFee(params);\n      }\n\n      case Chain.Polkadot: {\n        const { address, estimateTransactionFee } = getWallet(chain);\n\n        return estimateTransactionFee({ ...params, recipient: address });\n      }\n\n      default:\n        return baseValue;\n    }\n  }\n\n  const swapkitConfig = config.swapkitConfig || {};\n  const swapkitApiKey = swapkitConfig?.swapkitApiKey || config?.swapkitApiKey;\n  const referer = swapkitConfig.useHashedApiKey ? swapkitConfig.referer : undefined;\n\n  const api = swapkitApiKey\n    ? {\n        getGasRate: () => SwapKitApi.getGasRate(isDev, swapkitApiKey, referer),\n        getPrice: (body: PriceRequest) => SwapKitApi.getPrice(body, isDev, swapkitApiKey, referer),\n        getSwapQuote: (params: QuoteRequest) =>\n          SwapKitApi.getSwapQuote(params, isDev, swapkitApiKey, referer),\n        getTokenList: (provider: string) => SwapKitApi.getTokenList(provider),\n        getTokenListProviders: () =>\n          SwapKitApi.getTokenListProvidersV2(isDev, swapkitApiKey, referer),\n        getTokenTradingPairs: (providers: PluginNameEnum[]) =>\n          SwapKitApi.getTokenTradingPairs(providers, isDev, swapkitApiKey, referer),\n        getTrackerDetails: (payload: TrackerParams) =>\n          SwapKitApi.getTrackerDetails(payload, swapkitApiKey, referer),\n      }\n    : { undefined };\n\n  return {\n    ...availablePlugins,\n    ...connectWalletMethods,\n\n    disconnectAll,\n    disconnectChain,\n    estimateTransactionFee,\n    getAddress,\n    getAllWallets,\n    getBalance,\n    getExplorerAddressUrl: getAddressUrl,\n    getExplorerTxUrl: getTxUrl,\n    getWallet,\n    getWalletWithBalance,\n\n    approveAssetValue,\n    isAssetValueApproved,\n    signMessage,\n    swap,\n    transfer,\n    validateAddress,\n    verifyMessage,\n    api,\n  };\n}\n",
    "import { Chain, ChainToExplorerUrl, SwapKitError } from \"@swapkit/helpers\";\n\nexport function getExplorerTxUrl({ chain, txHash }: { txHash: string; chain: Chain }) {\n  const baseUrl = ChainToExplorerUrl[chain];\n\n  switch (chain) {\n    case Chain.Maya:\n    case Chain.Kujira:\n    case Chain.Cosmos:\n    case Chain.THORChain:\n    case Chain.Solana:\n      return `${baseUrl}/tx/${txHash.startsWith(\"0x\") ? txHash.slice(2) : txHash}`;\n\n    case Chain.Arbitrum:\n    case Chain.Avalanche:\n    case Chain.BinanceSmartChain:\n    case Chain.Base:\n    case Chain.Ethereum:\n    case Chain.Optimism:\n    case Chain.Polkadot:\n    case Chain.Polygon:\n      return `${baseUrl}/tx/${txHash.startsWith(\"0x\") ? txHash : `0x${txHash}`}`;\n\n    case Chain.Litecoin:\n    case Chain.Bitcoin:\n    case Chain.BitcoinCash:\n    case Chain.Dogecoin:\n    case Chain.Radix:\n      return `${baseUrl}/transaction/${txHash.toLowerCase()}`;\n\n    default:\n      throw new SwapKitError({ errorKey: \"core_explorer_unsupported_chain\", info: { chain } });\n  }\n}\n\nexport function getExplorerAddressUrl({ chain, address }: { address: string; chain: Chain }) {\n  const baseUrl = ChainToExplorerUrl[chain];\n\n  switch (chain) {\n    case Chain.Solana:\n    case Chain.Radix:\n      return `${baseUrl}/account/${address}`;\n\n    default:\n      return `${baseUrl}/address/${address}`;\n  }\n}\n",
    "import { Chain } from \"@swapkit/helpers\";\n\nexport async function getAddressValidator() {\n  const { cosmosValidateAddress } = await import(\"@swapkit/toolbox-cosmos\");\n  const { evmValidateAddress } = await import(\"@swapkit/toolbox-evm\");\n  const { substrateValidateAddress } = await import(\"@swapkit/toolbox-substrate\");\n  const { utxoValidateAddress } = await import(\"@swapkit/toolbox-utxo\");\n  const { validateAddress: solanaValidateAddress } = await import(\"@swapkit/toolbox-solana\");\n  const { validateAddress: validateRadixAddress } = await import(\"@swapkit/toolbox-radix\");\n\n  return function validateAddress({ address, chain }: { address: string; chain: Chain }) {\n    switch (chain) {\n      case Chain.Arbitrum:\n      case Chain.Avalanche:\n      case Chain.Optimism:\n      case Chain.BinanceSmartChain:\n      case Chain.Base:\n      case Chain.Polygon:\n      case Chain.Ethereum:\n        return evmValidateAddress({ address });\n\n      case Chain.Litecoin:\n      case Chain.Dash:\n      case Chain.Dogecoin:\n      case Chain.BitcoinCash:\n      case Chain.Bitcoin:\n        return utxoValidateAddress({ address, chain });\n\n      case Chain.Cosmos:\n      case Chain.Kujira:\n      case Chain.Maya:\n      case Chain.THORChain: {\n        return cosmosValidateAddress({ address, chain });\n      }\n\n      case Chain.Polkadot: {\n        return substrateValidateAddress({ address, chain });\n      }\n\n      case Chain.Radix: {\n        return validateRadixAddress(address);\n      }\n\n      case Chain.Solana: {\n        return solanaValidateAddress(address);\n      }\n\n      default:\n        return false;\n    }\n  };\n}\n"
  ],
  "mappings": "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",
  "debugId": "D1A504E9AFF2E6E164756E2164756E21",
  "names": []
}