import{a as U,c as W}from"./chunk-nm00d52v.js";import{AssetValue as l,Chain as Q,ChainToChainId as g,ChainToHexChainId as x,ChainToRPC as c,SwapKitError as k,WalletOption as f,filterSupportedChains as s,pickEvmApiKey as o,setRequestClientConfig as h}from"@swapkit/helpers";import{Chain as J,EVMChains as K,SwapKitError as B,WalletOption as m,erc20ABI as d,getRPCUrl as C}from"@swapkit/helpers";var E=(Z)=>{switch(Z){case J.Bitcoin:return"bitcoin";case J.BitcoinCash:return"bitcoincash";case J.Dash:return"dash";case J.Dogecoin:return"dogecoin";case J.Litecoin:return"litecoin";default:throw new Error("Unsupported chain")}};function O(Z){if(!window.keepkey)throw new B("wallet_keepkey_not_found");switch(Z){case J.Ethereum:case J.Base:case J.Avalanche:case J.BinanceSmartChain:case J.Arbitrum:case J.Optimism:case J.Polygon:return window.keepkey.ethereum;case J.Cosmos:return window.keepkey.cosmos;case J.Bitcoin:return window.keepkey.bitcoin;case J.BitcoinCash:return window.keepkey.bitcoincash;case J.Dogecoin:return window.keepkey.dogecoin;case J.Litecoin:return window.keepkey.litecoin;case J.Dash:return window.keepkey.dash;case J.THORChain:return window.keepkey.thorchain;case J.Maya:return window.keepkey.mayachain;default:return}}async function p({method:Z,params:z,chain:X}){let $=O(X);return new Promise((G,q)=>{if($&&"request"in $)$.request({method:Z,params:z},(D,R)=>{D?q(D):G(R)});else q(new B("wallet_provider_not_found"))})}async function T(Z){let z=O(Z);if(!z)throw new B({errorKey:"wallet_provider_not_found",info:{wallet:m.KEEPKEY,chain:Z}});let X="request_accounts";if(K.includes(Z))X="eth_requestAccounts";let[$]=await z.request({method:X,params:[]});return $}async function P({assetValue:Z,recipient:z,memo:X,gasLimit:$},G="transfer"){if(!Z)throw new B("wallet_keepkey_asset_not_defined");let q=await T(Z.chain),D=[{amount:{amount:Z.getValue("string"),decimals:Z.decimal},asset:{chain:Z.chain,symbol:Z.symbol.toUpperCase(),ticker:Z.symbol.toUpperCase()},memo:X,from:q,recipient:z,gasLimit:$}];return p({method:G,params:D,chain:Z.chain})}function V({chainId:Z,rpcUrl:z}){return async({from:X,recipient:$,assetValue:G})=>{let{getMsgSendDenom:q,createSigningStargateClient:D}=await import("@swapkit/toolbox-cosmos"),R=window.keepkey?.cosmos?.getOfflineSignerOnlyAmino(Z),F=await D(z||C(J.Cosmos),R),L=[{denom:q(G.symbol).toLowerCase(),amount:G.getBaseValue("string")}];try{let{transactionHash:j}=await F.sendTokens(X,$,L,2);return j}catch(j){throw new B("core_transaction_failed",{error:j})}}}function S(Z){return{call:async({contractAddress:z,abi:X,funcName:$,funcParams:G=[],txOverrides:q})=>{if(!z)throw new B("wallet_keepkey_contract_address_not_provided");let{createContract:D,createContractTxObject:R,isStateChangingCall:F,toHexString:L}=await import("@swapkit/toolbox-evm");if(F(X,$)){let{value:N,from:I,to:M,data:_}=await R(Z,{contractAddress:z,abi:X,funcName:$,funcParams:G,txOverrides:q});return Z.send("eth_sendTransaction",[{value:L(BigInt(N||0)),from:I,to:M,data:_||"0x"}])}let Y=await D(z,X,Z)[$]?.(...G);return typeof Y?.hash==="string"?Y?.hash:Y},approve:async({assetAddress:z,spenderAddress:X,amount:$,from:G})=>{let{MAX_APPROVAL:q,createContractTxObject:D,toHexString:R}=await import("@swapkit/toolbox-evm"),{value:F,to:L,data:j}=await D(Z,{contractAddress:z,abi:d,funcName:"approve",funcParams:[X,BigInt($||q)],txOverrides:{from:G}});return Z.send("eth_sendTransaction",[{value:R(BigInt(F||0)),from:G,to:L,data:j||"0x"}])},sendTransaction:async(z)=>{let{from:X,to:$,data:G,value:q}=z;if(!$)throw new B("wallet_keepkey_send_transaction_no_address");let{toHexString:D}=await import("@swapkit/toolbox-evm");return Z.send("eth_sendTransaction",[{value:D(BigInt(q||0)),from:X,to:$,data:G||"0x"}])}}}var t=[Q.Arbitrum,Q.Avalanche,Q.BinanceSmartChain,Q.Bitcoin,Q.BitcoinCash,Q.Base,Q.Cosmos,Q.Dash,Q.Dogecoin,Q.Ethereum,Q.Kujira,Q.Litecoin,Q.Maya,Q.Optimism,Q.Polygon,Q.Solana,Q.THORChain];async function r({apis:Z,chain:z,blockchairApiKey:X,covalentApiKey:$,ethplorerApiKey:G}){switch(z){case Q.Maya:case Q.THORChain:{let{getToolboxByChain:q,THORCHAIN_GAS_VALUE:D,MAYA_GAS_VALUE:R}=await import("@swapkit/toolbox-cosmos"),F=z===Q.Maya?R:D;return{...q(z)(),deposit:(j)=>P({...j,recipient:""},"deposit"),transfer:(j)=>P({...j,gasLimit:F},"transfer")}}case Q.Cosmos:case Q.Kujira:{let{getToolboxByChain:q}=await import("@swapkit/toolbox-cosmos");return{...q(z)(),transfer:V({chainId:g[z],rpcUrl:c[z]})}}case Q.Dash:case Q.Bitcoin:case Q.BitcoinCash:case Q.Dogecoin:case Q.Litecoin:{let{getToolboxByChain:q}=await import("@swapkit/toolbox-utxo");return{...q(z)({apiKey:X}),getBalance:async()=>{try{let F=E(z),L=await window?.keepkey?.[F]?.request({method:"request_balance"});return[l.from({chain:z,value:L[0].balance})]}catch(F){throw console.error("Error fetching balance:",F),F}},transfer:P}}case Q.Ethereum:case Q.BinanceSmartChain:case Q.Base:case Q.Arbitrum:case Q.Optimism:case Q.Polygon:case Q.Avalanche:{let{prepareNetworkSwitch:q,switchEVMWalletNetwork:D}=await import("@swapkit/helpers"),{getToolboxByChain:R,getBalance:F,covalentApi:L,ethplorerApi:j,getProvider:H}=await import("@swapkit/toolbox-evm"),{BrowserProvider:Y}=await import("./chunk-7r0bsnk5.js"),N=O(z);if(!N)throw new k("wallet_keepkey_not_found");let I=Z?.[z],M=o({chain:z,nonEthApiKey:$,ethApiKey:G}),_=new Y(N,"any"),w=await _.getSigner(),y=R(z)({api:I,apiKey:M,provider:_,signer:w}),v=S(_);try{z!==Q.Ethereum&&await D(_,x[z],y.getNetworkParams())}catch(b){throw new k({errorKey:"wallet_failed_to_add_or_switch_network",info:{wallet:f.KEEPKEY,chain:z}})}if(!((z===Q.Ethereum?G:$)||I))throw new k({errorKey:"wallet_missing_api_key",info:{chain:z}});let u=I||z===Q.Ethereum?j(M):L({apiKey:M,chainId:g[z]});return q({provider:_,chainId:x[z],toolbox:{...y,...v,getBalance:(b,A)=>F({chain:z,provider:H(z),api:u,address:b,potentialScamFilter:A})}})}default:return null}}function n({addChain:Z,apis:z,config:{covalentApiKey:X,ethplorerApiKey:$,blockchairApiKey:G,thorswapApiKey:q}}){return async(D)=>{h({apiKey:q});let F=s(D,t,f.KEEPKEY_BEX).map(async(L)=>{let j=await T(L),H=await r({chain:L,blockchairApiKey:G,covalentApiKey:X,ethplorerApiKey:$,apis:z});Z({...H,address:j,balance:[],chain:L,walletType:f.KEEPKEY_BEX})});return await Promise.all(F),!0}}var i={connectKeepkeyBex:n};export{i as keepkeyBexWallet};

//# debugId=86082777A5C9FE7A64756E2164756E21
