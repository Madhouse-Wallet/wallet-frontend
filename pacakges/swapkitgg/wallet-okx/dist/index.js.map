{
  "version": 3,
  "sources": ["../src/okxWallet.ts", "../src/helpers.ts"],
  "sourcesContent": [
    "import {\n  Chain,\n  type ConnectWalletParams,\n  WalletOption,\n  filterSupportedChains,\n  setRequestClientConfig,\n} from \"@swapkit/helpers\";\n\nimport { getWalletForChain } from \"./helpers\";\n\nexport const OKX_SUPPORTED_CHAINS = [\n  Chain.Arbitrum,\n  Chain.Avalanche,\n  Chain.Base,\n  Chain.BinanceSmartChain,\n  Chain.Bitcoin,\n  Chain.Cosmos,\n  Chain.Ethereum,\n  Chain.Optimism,\n  Chain.Polygon,\n] as const;\n\nfunction connectOkx({\n  addChain,\n  apis,\n  config: { thorswapApiKey, covalentApiKey, ethplorerApiKey, blockchairApiKey },\n}: ConnectWalletParams) {\n  return async function connectOkx(chains: Chain[]) {\n    setRequestClientConfig({ apiKey: thorswapApiKey });\n\n    const supportedChains = filterSupportedChains(chains, OKX_SUPPORTED_CHAINS, WalletOption.OKX);\n\n    const promises = supportedChains.map(async (chain) => {\n      const walletMethods = await getWalletForChain({\n        apis,\n        chain,\n        covalentApiKey,\n        ethplorerApiKey,\n        blockchairApiKey,\n      });\n\n      addChain({\n        ...walletMethods,\n        chain,\n        balance: [],\n        walletType: WalletOption.OKX,\n      });\n    });\n\n    await Promise.all(promises);\n\n    return true;\n  };\n}\n\nexport const okxWallet = { connectOkx } as const;\n",
    "import {\n  Chain,\n  type ChainApis,\n  ChainId,\n  ChainToHexChainId,\n  type EVMChain,\n  getRPCUrl,\n  pickEvmApiKey,\n  prepareNetworkSwitch,\n  switchEVMWalletNetwork,\n} from \"@swapkit/helpers\";\nimport type { GaiaToolbox } from \"@swapkit/toolbox-cosmos\";\nimport type { AlchemyApiType, CovalentApiType, EthplorerApiType } from \"@swapkit/toolbox-evm\";\nimport type { BTCToolbox, Psbt, UTXOTransferParams } from \"@swapkit/toolbox-utxo\";\nimport type { Eip1193Provider } from \"ethers\";\n\nconst cosmosTransfer =\n  (rpcUrl?: string) =>\n  async ({ from, recipient, amount, asset, memo }: any) => {\n    if (!(window.okxwallet && \"keplr\" in window.okxwallet)) {\n      throw new Error(\"No cosmos okxwallet found\");\n    }\n\n    const { keplr: wallet } = window.okxwallet;\n    const offlineSigner = wallet?.getOfflineSignerOnlyAmino(ChainId.Cosmos);\n\n    const { createSigningStargateClient } = await import(\"@swapkit/toolbox-cosmos\");\n    const cosmJS = await createSigningStargateClient(\n      rpcUrl || getRPCUrl(Chain.Cosmos),\n      offlineSigner,\n    );\n\n    const coins = [\n      { denom: asset?.symbol === \"MUON\" ? \"umuon\" : \"uatom\", amount: amount.amount().toString() },\n    ];\n\n    const { transactionHash } = await cosmJS.sendTokens(from, recipient, coins, 1.6, memo);\n    return transactionHash;\n  };\n\nexport const getWalletForChain = async ({\n  apis,\n  chain,\n  ethplorerApiKey,\n  covalentApiKey,\n  blockchairApiKey,\n  rpcUrl,\n}: {\n  apis?: ChainApis;\n  chain: Chain;\n  ethplorerApiKey?: string;\n  covalentApiKey?: string;\n  blockchairApiKey?: string;\n  rpcUrl?: string;\n}): Promise<\n  (\n    | ReturnType<typeof GaiaToolbox>\n    | Awaited<ReturnType<typeof getWeb3WalletMethods>>\n    | ReturnType<typeof BTCToolbox>\n  ) & { address: string }\n> => {\n  switch (chain) {\n    case Chain.Ethereum:\n    case Chain.Base:\n    case Chain.Avalanche:\n    case Chain.Arbitrum:\n    case Chain.Optimism:\n    case Chain.Polygon:\n    case Chain.BinanceSmartChain: {\n      if (!(window.okxwallet && \"send\" in window.okxwallet)) {\n        throw new Error(\"No okxwallet found\");\n      }\n\n      const { getProvider } = await import(\"@swapkit/toolbox-evm\");\n\n      const api = apis?.[chain];\n\n      const apiKey = pickEvmApiKey({\n        chain,\n        nonEthApiKey: covalentApiKey,\n        ethApiKey: ethplorerApiKey,\n      });\n\n      const evmWallet = await getWeb3WalletMethods({\n        chain,\n        api,\n        apiKey,\n        ethereumWindowProvider: window.okxwallet,\n      });\n\n      const address: string = (await window.okxwallet.send(\"eth_requestAccounts\", [])).result[0];\n\n      const getBalance = async (addressOverwrite?: string, potentialScamFilter = true) =>\n        evmWallet.getBalance(addressOverwrite || address, potentialScamFilter, getProvider(chain));\n\n      return { ...evmWallet, getBalance, address };\n    }\n\n    case Chain.Bitcoin: {\n      if (!(window.okxwallet && \"bitcoin\" in window.okxwallet)) {\n        throw new Error(\"No bitcoin okxwallet found\");\n      }\n      const { bitcoin: wallet } = window.okxwallet;\n\n      const { Psbt, BTCToolbox } = await import(\"@swapkit/toolbox-utxo\");\n\n      const api = apis?.[chain];\n\n      const address = (await wallet.connect()).address;\n\n      const toolbox = BTCToolbox({ rpcUrl, apiKey: blockchairApiKey, apiClient: api });\n      const signTransaction = async (psbt: Psbt) => {\n        const signedPsbt = await wallet.signPsbt(psbt.toHex(), { from: address, type: \"list\" });\n\n        return Psbt.fromHex(signedPsbt);\n      };\n\n      const transfer = (transferParams: UTXOTransferParams) => {\n        return toolbox.transfer({ ...transferParams, signTransaction });\n      };\n\n      return { ...toolbox, transfer, address };\n    }\n\n    case Chain.Cosmos: {\n      if (!(window.okxwallet && \"keplr\" in window.okxwallet)) {\n        throw new Error(\"No bitcoin okxwallet found\");\n      }\n      const { keplr: wallet } = window.okxwallet;\n\n      const api = apis?.[chain];\n\n      await wallet.enable(ChainId.Cosmos);\n      const accounts = await wallet.getOfflineSignerOnlyAmino(ChainId.Cosmos).getAccounts();\n      if (!accounts?.[0]) throw new Error(\"No cosmos account found\");\n\n      const { GaiaToolbox } = await import(\"@swapkit/toolbox-cosmos\");\n      const [{ address }] = accounts;\n\n      return {\n        address,\n        ...GaiaToolbox({ server: api }),\n        transfer: cosmosTransfer(rpcUrl),\n      };\n    }\n\n    default:\n      throw new Error(`No wallet for chain ${chain}`);\n  }\n};\n\nexport const getWeb3WalletMethods = async ({\n  ethereumWindowProvider,\n  chain,\n  api,\n  apiKey,\n}: {\n  ethereumWindowProvider: Eip1193Provider | undefined;\n  chain: EVMChain;\n  api?: EthplorerApiType | CovalentApiType | AlchemyApiType;\n  apiKey?: string;\n}) => {\n  const { getToolboxByChain } = await import(\"@swapkit/toolbox-evm\");\n  const { BrowserProvider } = await import(\"ethers\");\n  if (!ethereumWindowProvider) throw new Error(\"Requested web3 wallet is not installed\");\n\n  const provider = new BrowserProvider(ethereumWindowProvider, \"any\");\n\n  const toolbox = getToolboxByChain(chain)({\n    api,\n    apiKey,\n    provider,\n    signer: await provider.getSigner(),\n  });\n\n  try {\n    if (chain !== Chain.Ethereum && \"getNetworkParams\" in toolbox) {\n      await switchEVMWalletNetwork(provider, ChainToHexChainId[chain], toolbox.getNetworkParams());\n    }\n  } catch (_error) {\n    throw new Error(`Failed to add/switch ${chain} network: ${chain}`);\n  }\n\n  return prepareNetworkSwitch({ toolbox, provider, chainId: ChainToHexChainId[chain] });\n};\n"
  ],
  "mappings": "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",
  "debugId": "5852D11D0576D7C864756E2164756E21",
  "names": []
}