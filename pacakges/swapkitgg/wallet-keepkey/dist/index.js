var YJ=Object.create;var{getPrototypeOf:XJ,defineProperty:v$,getOwnPropertyNames:zJ}=Object;var ZJ=Object.prototype.hasOwnProperty;var T0=($,Q,J)=>{J=$!=null?YJ(XJ($)):{};let Y=Q||!$||!$.__esModule?v$(J,"default",{value:$,enumerable:!0}):J;for(let X of zJ($))if(!ZJ.call(Y,X))v$(Y,X,{get:()=>$[X],enumerable:!0});return Y};var GJ=($,Q)=>{for(var J in Q)v$($,J,{get:Q[J],enumerable:!0,configurable:!0,set:(Y)=>Q[J]=()=>Y})};var N0=(($)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy($,{get:(Q,J)=>(typeof require!=="undefined"?require:Q)[J]}):$)(function($){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+$+'" is not supported')});import{Chain as b,WalletOption as QJ,filterSupportedChains as D9,setRequestClientConfig as V9}from"@swapkit/helpers";import{KeepKeySdk as K9}from"@keepkey/keepkey-sdk";import{Chain as MJ,ChainId as B8,DerivationPath as IJ,derivationPathToString as WJ,getRPCUrl as DJ}from"@swapkit/helpers";var K$;((z)=>{z.BTC="Bitcoin";z.BCH="BitcoinCash";z.DOGE="Dogecoin";z.LTC="Litecoin";z.DASH="Dash"})(K$||={});function qJ($){if($==="m/")return!0;return/^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test($)}function U0($){let Q=$;if(!qJ(Q))throw new Error(`Not a bip32 path: '${Q}'`);if(/^m\//i.test(Q))Q=Q.slice(2);let J=Q.split("/");if(J.length===1&&J[0]==="")return[];let Y=new Array(J.length);for(let X=0;X<J.length;X++){let z=J[X];if(z){let Z=/(\d+)([hH']?)/.exec(z);if(Z===null)throw new Error("Invalid input");let[,G="",q=""]=Z;if(Y[X]=Number.parseInt(G,10),Y[X]>=2147483648)throw new Error("Invalid child index");if(q==="h"||q==="H"||q==="'")Y[X]+=2147483648;else if(q.length!==0)throw new Error("Invalid modifier")}}return Y}var F8=async({sdk:$,api:Q,derivationPath:J})=>{let{DEFAULT_COSMOS_FEE_MAINNET:Y,GaiaToolbox:X,createStargateClient:z}=await import("@swapkit/toolbox-cosmos");try{let Z=J?WJ(J):`${IJ.GAIA}/0`,{address:G}=await $.address.cosmosGetAddress({address_n:U0(Z)}),q=X({server:Q});if(Y.amount[0])Y.amount[0].amount=String(await q?.getFeeRateFromThorswap?.(B8.Cosmos,500));return{...q,transfer:async({assetValue:M,recipient:D,memo:O})=>{let w=M.getBaseValue("string"),W=await q.getAccount(G),V=await $.cosmos.cosmosSignAmino({signerAddress:G,signDoc:{fee:Y,memo:O||"",sequence:W?.sequence.toString()??"",chain_id:B8.Cosmos,account_number:W?.accountNumber.toString()??"",msgs:[{value:{amount:[{denom:"uatom",amount:w}],to_address:D,from_address:G},type:"cosmos-sdk/MsgSend"}]}}),K=atob(V.serialized),U=new Uint8Array(K.length).map((R,H)=>K.charCodeAt(H));return(await(await z(DJ(MJ.Cosmos))).broadcastTx(U)).transactionHash},address:G}}catch(Z){throw console.error(Z),Z}};import{ChainToChainId as $9,NetworkDerivationPath as Q9,derivationPathToString as J9}from"@swapkit/helpers";var _8="6.13.5";function VJ($,Q,J){let Y=Q.split("|").map((z)=>z.trim());for(let z=0;z<Y.length;z++)switch(Q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===Q)return}let X=new Error(`invalid value for type ${Q}`);throw X.code="INVALID_ARGUMENT",X.argument=`value.${J}`,X.value=$,X}async function v0($){let Q=Object.keys($);return(await Promise.all(Q.map((Y)=>Promise.resolve($[Y])))).reduce((Y,X,z)=>{return Y[Q[z]]=X,Y},{})}function G0($,Q,J){for(let Y in Q){let X=Q[Y],z=J?J[Y]:null;if(z)VJ(X,z,Y);Object.defineProperty($,Y,{enumerable:!0,value:X,writable:!1})}}function o0($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(o0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let Y=0;Y<$.length;Y++)J+="0123456789abcdef"[$[Y]>>4],J+="0123456789abcdef"[$[Y]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return o0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{let Q=Object.keys($);return Q.sort(),"{ "+Q.map((J)=>`${o0(J)}: ${o0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function m$($,Q){return $&&$.code===Q}function U$($,Q,J){let Y=$;{let z=[];if(J){if("message"in J||"code"in J||"name"in J)throw new Error(`value will overwrite populated values: ${o0(J)}`);for(let Z in J){if(Z==="shortMessage")continue;let G=J[Z];z.push(Z+"="+o0(G))}}if(z.push(`code=${Q}`),z.push(`version=${_8}`),z.length)$+=" ("+z.join(", ")+")"}let X;switch(Q){case"INVALID_ARGUMENT":X=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":X=new RangeError($);break;default:X=new Error($)}if(G0(X,{code:Q}),J)Object.assign(X,J);if(X.shortMessage==null)G0(X,{shortMessage:Y});return X}function A($,Q,J,Y){if(!$)throw U$(Q,J,Y)}function j($,Q,J,Y){A($,Q,"INVALID_ARGUMENT",{argument:J,value:Y})}var A9=["NFD","NFC","NFKD","NFKC"].reduce(($,Q)=>{try{if("test".normalize(Q)!=="test")throw new Error("bad");if(Q==="NFD"){let J=String.fromCharCode(233).normalize("NFD"),Y=String.fromCharCode(101,769);if(J!==Y)throw new Error("broken")}$.push(Q)}catch(J){}return $},[]);function g$($,Q,J){if(J==null)J="";if($!==Q){let Y=J,X="new";if(J)Y+=".",X+=" "+J;A(!1,`private constructor; use ${Y}from* methods`,"UNSUPPORTED_OPERATION",{operation:X})}}function b8($,Q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){let Y=new Uint8Array(($.length-2)/2),X=2;for(let z=0;z<Y.length;z++)Y[z]=parseInt($.substring(X,X+2),16),X+=2;return Y}j(!1,"invalid BytesLike value",Q||"value",$)}function f($,Q){return b8($,Q,!1)}function m0($,Q){return b8($,Q,!0)}function Q0($,Q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Q==="number"&&$.length!==2+2*Q)return!1;if(Q===!0&&$.length%2!==0)return!1;return!0}function Y$($){return Q0($,!0)||$ instanceof Uint8Array}var k8="0123456789abcdef";function P($){let Q=f($),J="0x";for(let Y=0;Y<Q.length;Y++){let X=Q[Y];J+=k8[(X&240)>>4]+k8[X&15]}return J}function q0($){return"0x"+$.map((Q)=>P(Q).substring(2)).join("")}function H0($){if(Q0($,!0))return($.length-2)/2;return f($).length}function KJ($,Q,J){let Y=f($);A(Q>=Y.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(Y),length:Q,offset:Q+1});let X=new Uint8Array(Q);if(X.fill(0),J)X.set(Y,Q-Y.length);else X.set(Y,0);return P(X)}function E0($,Q){return KJ($,Q,!0)}var f8=BigInt(0),b9=BigInt(1),i0=9007199254740991;function g($,Q){switch(typeof $){case"bigint":return $;case"number":return j(Number.isInteger($),"underflow",Q||"value",$),j($>=-i0&&$<=i0,"overflow",Q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){j(!1,`invalid BigNumberish string: ${J.message}`,Q||"value",$)}}j(!1,"invalid BigNumberish value",Q||"value",$)}function c$($,Q){let J=g($,Q);return A(J>=f8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function J0($,Q){switch(typeof $){case"bigint":return j($>=-i0&&$<=i0,"overflow",Q||"value",$),Number($);case"number":return j(Number.isInteger($),"underflow",Q||"value",$),j($>=-i0&&$<=i0,"overflow",Q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return J0(BigInt($),Q)}catch(J){j(!1,`invalid numeric string: ${J.message}`,Q||"value",$)}}j(!1,"invalid numeric value",Q||"value",$)}function O$($,Q){let Y=c$($,"value").toString(16);if(Q==null){if(Y.length%2)Y="0"+Y}else{let X=J0(Q,"width");A(X*2>=Y.length,`value exceeds width (${X} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(Y.length<X*2)Y="0"+Y}return"0x"+Y}function s($){let Q=c$($,"value");if(Q===f8)return new Uint8Array([]);let J=Q.toString(16);if(J.length%2)J="0"+J;let Y=new Uint8Array(J.length/2);for(let X=0;X<Y.length;X++){let z=X*2;Y[X]=parseInt(J.substring(z,z+2),16)}return Y}function UJ($){let Q=$.toString(16);while(Q.length<2)Q="0"+Q;return"0x"+Q}function y8($,Q,J){let Y=0;for(let X=0;X<J;X++)Y=Y*256+$[Q+X];return Y}function x8($,Q,J,Y){let X=[];while(J<Q+1+Y){let z=v8($,J);X.push(z.result),J+=z.consumed,A(J<=Q+1+Y,"child data too short","BUFFER_OVERRUN",{buffer:$,length:Y,offset:Q})}return{consumed:1+Y,result:X}}function v8($,Q){A($.length!==0,"data too short","BUFFER_OVERRUN",{buffer:$,length:0,offset:1});let J=(Y)=>{A(Y<=$.length,"data short segment too short","BUFFER_OVERRUN",{buffer:$,length:$.length,offset:Y})};if($[Q]>=248){let Y=$[Q]-247;J(Q+1+Y);let X=y8($,Q+1,Y);return J(Q+1+Y+X),x8($,Q,Q+1+Y,Y+X)}else if($[Q]>=192){let Y=$[Q]-192;return J(Q+1+Y),x8($,Q,Q+1,Y)}else if($[Q]>=184){let Y=$[Q]-183;J(Q+1+Y);let X=y8($,Q+1,Y);J(Q+1+Y+X);let z=P($.slice(Q+1+Y,Q+1+Y+X));return{consumed:1+Y+X,result:z}}else if($[Q]>=128){let Y=$[Q]-128;J(Q+1+Y);let X=P($.slice(Q+1,Q+1+Y));return{consumed:1+Y,result:X}}return{consumed:1,result:UJ($[Q])}}function r0($){let Q=f($,"data"),J=v8(Q,0);return j(J.consumed===Q.length,"unexpected junk after rlp payload","data",$),J.result}function m8($){let Q=[];while($)Q.unshift($&255),$>>=8;return Q}function c8($){if(Array.isArray($)){let Y=[];if($.forEach(function(z){Y=Y.concat(c8(z))}),Y.length<=55)return Y.unshift(192+Y.length),Y;let X=m8(Y.length);return X.unshift(247+X.length),X.concat(Y)}let Q=Array.prototype.slice.call(f($,"object"));if(Q.length===1&&Q[0]<=127)return Q;else if(Q.length<=55)return Q.unshift(128+Q.length),Q;let J=m8(Q.length);return J.unshift(183+J.length),J.concat(Q)}var g8="0123456789abcdef";function S0($){let Q="0x";for(let J of c8($))Q+=g8[J>>4],Q+=g8[J&15];return Q}function h$($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function u$($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function a0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function T$($,Q){u$($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var OJ=($)=>$ instanceof Uint8Array;var h8=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),N$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),M0=($,Q)=>$<<32-Q|$>>>Q,TJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!TJ)throw new Error("Non little-endian hardware is not supported");function NJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function X$($){if(typeof $==="string")$=NJ($);if(!OJ($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}class z${clone(){return this._cloneInto()}}var GX={}.toString;function s0($){let Q=(Y)=>$().update(X$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function jJ($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),q=Y?4:0,I=Y?0:4;$.setUint32(Q+q,Z,Y),$.setUint32(Q+I,G,Y)}class Z$ extends z${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=N$(this.buffer)}update($){a0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=X$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=N$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){a0(this),T$($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let M=z;M<Y;M++)Q[M]=0;jJ(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=N$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let q=G/4,I=this.get();if(q>I.length)throw new Error("_sha2: outputLen bigger than state");for(let M=0;M<q;M++)Z.setUint32(4*M,I[M],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var wJ=($,Q,J)=>$&Q^~$&J,RJ=($,Q,J)=>$&Q^$&J^Q&J,HJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),C0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),L0=new Uint32Array(64);class u8 extends Z${constructor(){super(64,32,8,!1);this.A=C0[0]|0,this.B=C0[1]|0,this.C=C0[2]|0,this.D=C0[3]|0,this.E=C0[4]|0,this.F=C0[5]|0,this.G=C0[6]|0,this.H=C0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let M=0;M<16;M++,Q+=4)L0[M]=$.getUint32(Q,!1);for(let M=16;M<64;M++){let D=L0[M-15],O=L0[M-2],w=M0(D,7)^M0(D,18)^D>>>3,W=M0(O,17)^M0(O,19)^O>>>10;L0[M]=W+L0[M-7]+w+L0[M-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:q,H:I}=this;for(let M=0;M<64;M++){let D=M0(Z,6)^M0(Z,11)^M0(Z,25),O=I+D+wJ(Z,G,q)+HJ[M]+L0[M]|0,W=(M0(J,2)^M0(J,13)^M0(J,22))+RJ(J,Y,X)|0;I=q,q=G,G=Z,Z=z+O|0,z=X,X=Y,Y=J,J=O+W|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,q=q+this.G|0,I=I+this.H|0,this.set(J,Y,X,z,Z,G,q,I)}roundClean(){L0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var d8=s0(()=>new u8);var j$=BigInt(4294967295),d$=BigInt(32);function p8($,Q=!1){if(Q)return{h:Number($&j$),l:Number($>>d$&j$)};return{h:Number($>>d$&j$)|0,l:Number($&j$)|0}}function p$($,Q=!1){let J=new Uint32Array($.length),Y=new Uint32Array($.length);for(let X=0;X<$.length;X++){let{h:z,l:Z}=p8($[X],Q);[J[X],Y[X]]=[z,Z]}return[J,Y]}var EJ=($,Q)=>BigInt($>>>0)<<d$|BigInt(Q>>>0),SJ=($,Q,J)=>$>>>J,CJ=($,Q,J)=>$<<32-J|Q>>>J,LJ=($,Q,J)=>$>>>J|Q<<32-J,PJ=($,Q,J)=>$<<32-J|Q>>>J,AJ=($,Q,J)=>$<<64-J|Q>>>J-32,BJ=($,Q,J)=>$>>>J-32|Q<<64-J,FJ=($,Q)=>Q,_J=($,Q)=>$,l$=($,Q,J)=>$<<J|Q>>>32-J,n$=($,Q,J)=>Q<<J|$>>>32-J,o$=($,Q,J)=>Q<<J-32|$>>>64-J,i$=($,Q,J)=>$<<J-32|Q>>>64-J;function kJ($,Q,J,Y){let X=(Q>>>0)+(Y>>>0);return{h:$+J+(X/4294967296|0)|0,l:X|0}}var bJ=($,Q,J)=>($>>>0)+(Q>>>0)+(J>>>0),fJ=($,Q,J,Y)=>Q+J+Y+($/4294967296|0)|0,yJ=($,Q,J,Y)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0),xJ=($,Q,J,Y,X)=>Q+J+Y+X+($/4294967296|0)|0,vJ=($,Q,J,Y,X)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0)+(X>>>0),mJ=($,Q,J,Y,X,z)=>Q+J+Y+X+z+($/4294967296|0)|0;var gJ={fromBig:p8,split:p$,toBig:EJ,shrSH:SJ,shrSL:CJ,rotrSH:LJ,rotrSL:PJ,rotrBH:AJ,rotrBL:BJ,rotr32H:FJ,rotr32L:_J,rotlSH:l$,rotlSL:n$,rotlBH:o$,rotlBL:i$,add:kJ,add3L:bJ,add3H:fJ,add4L:yJ,add4H:xJ,add5H:mJ,add5L:vJ},B=gJ;var[cJ,hJ]=(()=>B.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(($)=>BigInt($))))(),P0=new Uint32Array(80),A0=new Uint32Array(80);class l8 extends Z${constructor(){super(128,64,16,!1);this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:$,Al:Q,Bh:J,Bl:Y,Ch:X,Cl:z,Dh:Z,Dl:G,Eh:q,El:I,Fh:M,Fl:D,Gh:O,Gl:w,Hh:W,Hl:V}=this;return[$,Q,J,Y,X,z,Z,G,q,I,M,D,O,w,W,V]}set($,Q,J,Y,X,z,Z,G,q,I,M,D,O,w,W,V){this.Ah=$|0,this.Al=Q|0,this.Bh=J|0,this.Bl=Y|0,this.Ch=X|0,this.Cl=z|0,this.Dh=Z|0,this.Dl=G|0,this.Eh=q|0,this.El=I|0,this.Fh=M|0,this.Fl=D|0,this.Gh=O|0,this.Gl=w|0,this.Hh=W|0,this.Hl=V|0}process($,Q){for(let T=0;T<16;T++,Q+=4)P0[T]=$.getUint32(Q),A0[T]=$.getUint32(Q+=4);for(let T=16;T<80;T++){let C=P0[T-15]|0,R=A0[T-15]|0,H=B.rotrSH(C,R,1)^B.rotrSH(C,R,8)^B.shrSH(C,R,7),S=B.rotrSL(C,R,1)^B.rotrSL(C,R,8)^B.shrSL(C,R,7),E=P0[T-2]|0,y=A0[T-2]|0,_=B.rotrSH(E,y,19)^B.rotrBH(E,y,61)^B.shrSH(E,y,6),F=B.rotrSL(E,y,19)^B.rotrBL(E,y,61)^B.shrSL(E,y,6),h=B.add4L(S,F,A0[T-7],A0[T-16]),r=B.add4H(h,H,_,P0[T-7],P0[T-16]);P0[T]=r|0,A0[T]=h|0}let{Ah:J,Al:Y,Bh:X,Bl:z,Ch:Z,Cl:G,Dh:q,Dl:I,Eh:M,El:D,Fh:O,Fl:w,Gh:W,Gl:V,Hh:K,Hl:U}=this;for(let T=0;T<80;T++){let C=B.rotrSH(M,D,14)^B.rotrSH(M,D,18)^B.rotrBH(M,D,41),R=B.rotrSL(M,D,14)^B.rotrSL(M,D,18)^B.rotrBL(M,D,41),H=M&O^~M&W,S=D&w^~D&V,E=B.add5L(U,R,S,hJ[T],A0[T]),y=B.add5H(E,K,C,H,cJ[T],P0[T]),_=E|0,F=B.rotrSH(J,Y,28)^B.rotrBH(J,Y,34)^B.rotrBH(J,Y,39),h=B.rotrSL(J,Y,28)^B.rotrBL(J,Y,34)^B.rotrBL(J,Y,39),r=J&X^J&Z^X&Z,V0=Y&z^Y&G^z&G;K=W|0,U=V|0,W=O|0,V=w|0,O=M|0,w=D|0,{h:M,l:D}=B.add(q|0,I|0,y|0,_|0),q=Z|0,I=G|0,Z=X|0,G=z|0,X=J|0,z=Y|0;let d=B.add3L(_,h,V0);J=B.add3H(d,y,F,r),Y=d|0}({h:J,l:Y}=B.add(this.Ah|0,this.Al|0,J|0,Y|0)),{h:X,l:z}=B.add(this.Bh|0,this.Bl|0,X|0,z|0),{h:Z,l:G}=B.add(this.Ch|0,this.Cl|0,Z|0,G|0),{h:q,l:I}=B.add(this.Dh|0,this.Dl|0,q|0,I|0),{h:M,l:D}=B.add(this.Eh|0,this.El|0,M|0,D|0),{h:O,l:w}=B.add(this.Fh|0,this.Fl|0,O|0,w|0),{h:W,l:V}=B.add(this.Gh|0,this.Gl|0,W|0,V|0),{h:K,l:U}=B.add(this.Hh|0,this.Hl|0,K|0,U|0),this.set(J,Y,X,z,Z,G,q,I,M,D,O,w,W,V,K,U)}roundClean(){P0.fill(0),A0.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var n8=s0(()=>new l8);function uJ(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw new Error("unable to locate global object")}var o8=uJ(),EX=o8.crypto||o8.msCrypto;function r$($){switch($){case"sha256":return d8.create();case"sha512":return n8.create()}j(!1,"invalid hashing algorithm name","algorithm",$)}var[a8,s8,t8]=[[],[],[]],dJ=BigInt(0),G$=BigInt(1),pJ=BigInt(2),lJ=BigInt(7),nJ=BigInt(256),oJ=BigInt(113);for(let $=0,Q=G$,J=1,Y=0;$<24;$++){[J,Y]=[Y,(2*J+3*Y)%5],a8.push(2*(5*Y+J)),s8.push(($+1)*($+2)/2%64);let X=dJ;for(let z=0;z<7;z++)if(Q=(Q<<G$^(Q>>lJ)*oJ)%nJ,Q&pJ)X^=G$<<(G$<<BigInt(z))-G$;t8.push(X)}var[iJ,rJ]=p$(t8,!0),i8=($,Q,J)=>J>32?o$($,Q,J):l$($,Q,J),r8=($,Q,J)=>J>32?i$($,Q,J):n$($,Q,J);function aJ($,Q=24){let J=new Uint32Array(10);for(let Y=24-Q;Y<24;Y++){for(let Z=0;Z<10;Z++)J[Z]=$[Z]^$[Z+10]^$[Z+20]^$[Z+30]^$[Z+40];for(let Z=0;Z<10;Z+=2){let G=(Z+8)%10,q=(Z+2)%10,I=J[q],M=J[q+1],D=i8(I,M,1)^J[G],O=r8(I,M,1)^J[G+1];for(let w=0;w<50;w+=10)$[Z+w]^=D,$[Z+w+1]^=O}let X=$[2],z=$[3];for(let Z=0;Z<24;Z++){let G=s8[Z],q=i8(X,z,G),I=r8(X,z,G),M=a8[Z];X=$[M],z=$[M+1],$[M]=q,$[M+1]=I}for(let Z=0;Z<50;Z+=10){for(let G=0;G<10;G++)J[G]=$[Z+G];for(let G=0;G<10;G++)$[Z+G]^=~J[(G+2)%10]&J[(G+4)%10]}$[0]^=iJ[Y],$[1]^=rJ[Y]}J.fill(0)}class a$ extends z${constructor($,Q,J,Y=!1,X=24){super();if(this.blockLen=$,this.suffix=Q,this.outputLen=J,this.enableXOF=Y,this.rounds=X,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,h$(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=h8(this.state)}keccak(){aJ(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){a0(this);let{blockLen:Q,state:J}=this;$=X$($);let Y=$.length;for(let X=0;X<Y;){let z=Math.min(Q-this.pos,Y-X);for(let Z=0;Z<z;Z++)J[this.pos++]^=$[X++];if(this.pos===Q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:$,suffix:Q,pos:J,blockLen:Y}=this;if($[J]^=Q,(Q&128)!==0&&J===Y-1)this.keccak();$[Y-1]^=128,this.keccak()}writeInto($){a0(this,!1),u$($),this.finish();let Q=this.state,{blockLen:J}=this;for(let Y=0,X=$.length;Y<X;){if(this.posOut>=J)this.keccak();let z=Math.min(J-this.posOut,X-Y);$.set(Q.subarray(this.posOut,this.posOut+z),Y),this.posOut+=z,Y+=z}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return h$($),this.xofInto(new Uint8Array($))}digestInto($){if(T$($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){let{blockLen:Q,suffix:J,outputLen:Y,rounds:X,enableXOF:z}=this;return $||($=new a$(Q,J,Y,z,X)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=X,$.suffix=J,$.outputLen=Y,$.enableXOF=z,$.destroyed=this.destroyed,$}}var sJ=($,Q,J)=>s0(()=>new a$(Q,$,J));var e8=sJ(1,136,32);var $Q=!1,QQ=function($){return e8($)},JQ=QQ;function Y0($){let Q=f($,"data");return P(JQ(Q))}Y0._=QQ;Y0.lock=function(){$Q=!0};Y0.register=function($){if($Q)throw new TypeError("keccak256 is locked");JQ=$};Object.freeze(Y0);var YQ=function($){return r$("sha256").update($).digest()},XQ=function($){return r$("sha512").update($).digest()},zQ=YQ,ZQ=XQ,GQ=!1,qQ=!1;function B0($){let Q=f($,"data");return P(zQ(Q))}B0._=YQ;B0.lock=function(){GQ=!0};B0.register=function($){if(GQ)throw new Error("sha256 is locked");zQ=$};Object.freeze(B0);function w$($){let Q=f($,"data");return P(ZQ(Q))}w$._=XQ;w$.lock=function(){qQ=!0};w$.register=function($){if(qQ)throw new Error("sha512 is locked");ZQ=$};Object.freeze(B0);function MQ($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function s$($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function IQ($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");MQ($.outputLen),MQ($.blockLen)}function t0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function WQ($,Q){s$($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}var R$=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var DQ=($)=>$ instanceof Uint8Array;var H$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),I0=($,Q)=>$<<32-Q|$>>>Q,tJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!tJ)throw new Error("Non little-endian hardware is not supported");function eJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function q$($){if(typeof $==="string")$=eJ($);if(!DQ($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function VQ(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!DQ(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}class M${clone(){return this._cloneInto()}}var gX={}.toString;function KQ($){let Q=(Y)=>$().update(q$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function UQ($=32){if(R$&&typeof R$.getRandomValues==="function")return R$.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}function $Y($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),q=Y?4:0,I=Y?0:4;$.setUint32(Q+q,Z,Y),$.setUint32(Q+I,G,Y)}class t$ extends M${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=H$(this.buffer)}update($){t0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=q$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=H$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){t0(this),WQ($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let M=z;M<Y;M++)Q[M]=0;$Y(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=H$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let q=G/4,I=this.get();if(q>I.length)throw new Error("_sha2: outputLen bigger than state");for(let M=0;M<q;M++)Z.setUint32(4*M,I[M],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var QY=($,Q,J)=>$&Q^~$&J,JY=($,Q,J)=>$&Q^$&J^Q&J,YY=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),F0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_0=new Uint32Array(64);class OQ extends t${constructor(){super(64,32,8,!1);this.A=F0[0]|0,this.B=F0[1]|0,this.C=F0[2]|0,this.D=F0[3]|0,this.E=F0[4]|0,this.F=F0[5]|0,this.G=F0[6]|0,this.H=F0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let M=0;M<16;M++,Q+=4)_0[M]=$.getUint32(Q,!1);for(let M=16;M<64;M++){let D=_0[M-15],O=_0[M-2],w=I0(D,7)^I0(D,18)^D>>>3,W=I0(O,17)^I0(O,19)^O>>>10;_0[M]=W+_0[M-7]+w+_0[M-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:q,H:I}=this;for(let M=0;M<64;M++){let D=I0(Z,6)^I0(Z,11)^I0(Z,25),O=I+D+QY(Z,G,q)+YY[M]+_0[M]|0,W=(I0(J,2)^I0(J,13)^I0(J,22))+JY(J,Y,X)|0;I=q,q=G,G=Z,Z=z+O|0,z=X,X=Y,Y=J,J=O+W|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,q=q+this.G|0,I=I+this.H|0,this.set(J,Y,X,z,Z,G,q,I)}roundClean(){_0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var TQ=KQ(()=>new OQ);var J8={};GJ(J8,{validateObject:()=>b0,utf8ToBytes:()=>qY,numberToVarBytesBE:()=>ZY,numberToHexUnpadded:()=>wQ,numberToBytesLE:()=>L$,numberToBytesBE:()=>k0,hexToNumber:()=>$8,hexToBytes:()=>c0,equalBytes:()=>GY,ensureBytes:()=>e,createHmacDrbg:()=>Q8,concatBytes:()=>e0,bytesToNumberLE:()=>C$,bytesToNumberBE:()=>j0,bytesToHex:()=>g0,bitSet:()=>WY,bitMask:()=>I$,bitLen:()=>MY,bitGet:()=>IY});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var jQ=BigInt(0),E$=BigInt(1),XY=BigInt(2),S$=($)=>$ instanceof Uint8Array,zY=Array.from({length:256},($,Q)=>Q.toString(16).padStart(2,"0"));function g0($){if(!S$($))throw new Error("Uint8Array expected");let Q="";for(let J=0;J<$.length;J++)Q+=zY[$[J]];return Q}function wQ($){let Q=$.toString(16);return Q.length&1?`0${Q}`:Q}function $8($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function c0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);let Q=$.length;if(Q%2)throw new Error("padded hex string expected, got unpadded hex of length "+Q);let J=new Uint8Array(Q/2);for(let Y=0;Y<J.length;Y++){let X=Y*2,z=$.slice(X,X+2),Z=Number.parseInt(z,16);if(Number.isNaN(Z)||Z<0)throw new Error("Invalid byte sequence");J[Y]=Z}return J}function j0($){return $8(g0($))}function C$($){if(!S$($))throw new Error("Uint8Array expected");return $8(g0(Uint8Array.from($).reverse()))}function k0($,Q){return c0($.toString(16).padStart(Q*2,"0"))}function L$($,Q){return k0($,Q).reverse()}function ZY($){return c0(wQ($))}function e($,Q,J){let Y;if(typeof Q==="string")try{Y=c0(Q)}catch(z){throw new Error(`${$} must be valid hex string, got "${Q}". Cause: ${z}`)}else if(S$(Q))Y=Uint8Array.from(Q);else throw new Error(`${$} must be hex string or Uint8Array`);let X=Y.length;if(typeof J==="number"&&X!==J)throw new Error(`${$} expected ${J} bytes, got ${X}`);return Y}function e0(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!S$(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}function GY($,Q){if($.length!==Q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Q[J])return!1;return!0}function qY($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function MY($){let Q;for(Q=0;$>jQ;$>>=E$,Q+=1);return Q}function IY($,Q){return $>>BigInt(Q)&E$}var WY=($,Q,J)=>{return $|(J?E$:jQ)<<BigInt(Q)},I$=($)=>(XY<<BigInt($-1))-E$,e$=($)=>new Uint8Array($),NQ=($)=>Uint8Array.from($);function Q8($,Q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let Y=e$($),X=e$($),z=0,Z=()=>{Y.fill(1),X.fill(0),z=0},G=(...D)=>J(X,Y,...D),q=(D=e$())=>{if(X=G(NQ([0]),D),Y=G(),D.length===0)return;X=G(NQ([1]),D),Y=G()},I=()=>{if(z++>=1000)throw new Error("drbg: tried 1000 values");let D=0,O=[];while(D<Q){Y=G();let w=Y.slice();O.push(w),D+=Y.length}return e0(...O)};return(D,O)=>{Z(),q(D);let w=void 0;while(!(w=O(I())))q();return Z(),w}}var DY={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,Q)=>Q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function b0($,Q,J={}){let Y=(X,z,Z)=>{let G=DY[z];if(typeof G!=="function")throw new Error(`Invalid validator "${z}", expected function`);let q=$[X];if(Z&&q===void 0)return;if(!G(q,$))throw new Error(`Invalid param ${String(X)}=${q} (${typeof q}), expected ${z}`)};for(let[X,z]of Object.entries(Q))Y(X,z,!1);for(let[X,z]of Object.entries(J))Y(X,z,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var n=BigInt(0),c=BigInt(1),h0=BigInt(2),VY=BigInt(3),Y8=BigInt(4),RQ=BigInt(5),HQ=BigInt(8),KY=BigInt(9),UY=BigInt(16);function a($,Q){let J=$%Q;return J>=n?J:Q+J}function OY($,Q,J){if(J<=n||Q<n)throw new Error("Expected power/modulo > 0");if(J===c)return n;let Y=c;while(Q>n){if(Q&c)Y=Y*$%J;$=$*$%J,Q>>=c}return Y}function $0($,Q,J){let Y=$;while(Q-- >n)Y*=Y,Y%=J;return Y}function P$($,Q){if($===n||Q<=n)throw new Error(`invert: expected positive integers, got n=${$} mod=${Q}`);let J=a($,Q),Y=Q,X=n,z=c,Z=c,G=n;while(J!==n){let I=Y/J,M=Y%J,D=X-Z*I,O=z-G*I;Y=J,J=M,X=Z,z=G,Z=D,G=O}if(Y!==c)throw new Error("invert: does not exist");return a(X,Q)}function TY($){let Q=($-c)/h0,J,Y,X;for(J=$-c,Y=0;J%h0===n;J/=h0,Y++);for(X=h0;X<$&&OY(X,Q,$)!==$-c;X++);if(Y===1){let Z=($+c)/Y8;return function G(q,I){let M=q.pow(I,Z);if(!q.eql(q.sqr(M),I))throw new Error("Cannot find square root");return M}}let z=(J+c)/h0;return function Z(G,q){if(G.pow(q,Q)===G.neg(G.ONE))throw new Error("Cannot find square root");let I=Y,M=G.pow(G.mul(G.ONE,X),J),D=G.pow(q,z),O=G.pow(q,J);while(!G.eql(O,G.ONE)){if(G.eql(O,G.ZERO))return G.ZERO;let w=1;for(let V=G.sqr(O);w<I;w++){if(G.eql(V,G.ONE))break;V=G.sqr(V)}let W=G.pow(M,c<<BigInt(I-w-1));M=G.sqr(W),D=G.mul(D,W),O=G.mul(O,M),I=w}return D}}function NY($){if($%Y8===VY){let Q=($+c)/Y8;return function J(Y,X){let z=Y.pow(X,Q);if(!Y.eql(Y.sqr(z),X))throw new Error("Cannot find square root");return z}}if($%HQ===RQ){let Q=($-RQ)/HQ;return function J(Y,X){let z=Y.mul(X,h0),Z=Y.pow(z,Q),G=Y.mul(X,Z),q=Y.mul(Y.mul(G,h0),Z),I=Y.mul(G,Y.sub(q,Y.ONE));if(!Y.eql(Y.sqr(I),X))throw new Error("Cannot find square root");return I}}if($%UY===KY);return TY($)}var jY=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function X8($){let Q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=jY.reduce((Y,X)=>{return Y[X]="function",Y},Q);return b0($,J)}function wY($,Q,J){if(J<n)throw new Error("Expected power > 0");if(J===n)return $.ONE;if(J===c)return Q;let Y=$.ONE,X=Q;while(J>n){if(J&c)Y=$.mul(Y,X);X=$.sqr(X),J>>=c}return Y}function RY($,Q){let J=new Array(Q.length),Y=Q.reduce((z,Z,G)=>{if($.is0(Z))return z;return J[G]=z,$.mul(z,Z)},$.ONE),X=$.inv(Y);return Q.reduceRight((z,Z,G)=>{if($.is0(Z))return z;return J[G]=$.mul(z,J[G]),$.mul(z,Z)},X),J}function z8($,Q){let J=Q!==void 0?Q:$.toString(2).length,Y=Math.ceil(J/8);return{nBitLength:J,nByteLength:Y}}function EQ($,Q,J=!1,Y={}){if($<=n)throw new Error(`Expected Field ORDER > 0, got ${$}`);let{nBitLength:X,nByteLength:z}=z8($,Q);if(z>2048)throw new Error("Field lengths over 2048 bytes are not supported");let Z=NY($),G=Object.freeze({ORDER:$,BITS:X,BYTES:z,MASK:I$(X),ZERO:n,ONE:c,create:(q)=>a(q,$),isValid:(q)=>{if(typeof q!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof q}`);return n<=q&&q<$},is0:(q)=>q===n,isOdd:(q)=>(q&c)===c,neg:(q)=>a(-q,$),eql:(q,I)=>q===I,sqr:(q)=>a(q*q,$),add:(q,I)=>a(q+I,$),sub:(q,I)=>a(q-I,$),mul:(q,I)=>a(q*I,$),pow:(q,I)=>wY(G,q,I),div:(q,I)=>a(q*P$(I,$),$),sqrN:(q)=>q*q,addN:(q,I)=>q+I,subN:(q,I)=>q-I,mulN:(q,I)=>q*I,inv:(q)=>P$(q,$),sqrt:Y.sqrt||((q)=>Z(G,q)),invertBatch:(q)=>RY(G,q),cmov:(q,I,M)=>M?I:q,toBytes:(q)=>J?L$(q,z):k0(q,z),fromBytes:(q)=>{if(q.length!==z)throw new Error(`Fp.fromBytes: expected ${z}, got ${q.length}`);return J?C$(q):j0(q)}});return Object.freeze(G)}function SQ($){if(typeof $!=="bigint")throw new Error("field order must be bigint");let Q=$.toString(2).length;return Math.ceil(Q/8)}function Z8($){let Q=SQ($);return Q+Math.ceil(Q/2)}function CQ($,Q,J=!1){let Y=$.length,X=SQ(Q),z=Z8(Q);if(Y<16||Y<z||Y>1024)throw new Error(`expected ${z}-1024 bytes of input, got ${Y}`);let Z=J?j0($):C$($),G=a(Z,Q-c)+c;return J?L$(G,X):k0(G,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var EY=BigInt(0),G8=BigInt(1);function LQ($,Q){let J=(X,z)=>{let Z=z.negate();return X?Z:z},Y=(X)=>{let z=Math.ceil(Q/X)+1,Z=2**(X-1);return{windows:z,windowSize:Z}};return{constTimeNegate:J,unsafeLadder(X,z){let Z=$.ZERO,G=X;while(z>EY){if(z&G8)Z=Z.add(G);G=G.double(),z>>=G8}return Z},precomputeWindow(X,z){let{windows:Z,windowSize:G}=Y(z),q=[],I=X,M=I;for(let D=0;D<Z;D++){M=I,q.push(M);for(let O=1;O<G;O++)M=M.add(I),q.push(M);I=M.double()}return q},wNAF(X,z,Z){let{windows:G,windowSize:q}=Y(X),I=$.ZERO,M=$.BASE,D=BigInt(2**X-1),O=2**X,w=BigInt(X);for(let W=0;W<G;W++){let V=W*q,K=Number(Z&D);if(Z>>=w,K>q)K-=O,Z+=G8;let U=V,T=V+Math.abs(K)-1,C=W%2!==0,R=K<0;if(K===0)M=M.add(J(C,z[U]));else I=I.add(J(R,z[T]))}return{p:I,f:M}},wNAFCached(X,z,Z,G){let q=X._WINDOW_SIZE||1,I=z.get(X);if(!I){if(I=this.precomputeWindow(X,q),q!==1)z.set(X,G(I))}return this.wNAF(q,I,Z)}}}function q8($){return X8($.Fp),b0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...z8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function SY($){let Q=q8($);b0(Q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:J,Fp:Y,a:X}=Q;if(J){if(!Y.eql(X,Y.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Q})}var{bytesToNumberBE:CY,hexToBytes:LY}=J8,u0={Err:class $ extends Error{constructor(Q=""){super(Q)}},_parseInt($){let{Err:Q}=u0;if($.length<2||$[0]!==2)throw new Q("Invalid signature integer tag");let J=$[1],Y=$.subarray(2,J+2);if(!J||Y.length!==J)throw new Q("Invalid signature integer: wrong length");if(Y[0]&128)throw new Q("Invalid signature integer: negative");if(Y[0]===0&&!(Y[1]&128))throw new Q("Invalid signature integer: unnecessary leading zero");return{d:CY(Y),l:$.subarray(J+2)}},toSig($){let{Err:Q}=u0,J=typeof $==="string"?LY($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let Y=J.length;if(Y<2||J[0]!=48)throw new Q("Invalid signature tag");if(J[1]!==Y-2)throw new Q("Invalid signature: incorrect length");let{d:X,l:z}=u0._parseInt(J.subarray(2)),{d:Z,l:G}=u0._parseInt(z);if(G.length)throw new Q("Invalid signature: left bytes after parsing");return{r:X,s:Z}},hexFromSig($){let Q=(I)=>Number.parseInt(I[0],16)&8?"00"+I:I,J=(I)=>{let M=I.toString(16);return M.length&1?`0${M}`:M},Y=Q(J($.s)),X=Q(J($.r)),z=Y.length/2,Z=X.length/2,G=J(z),q=J(Z);return`30${J(Z+z+4)}02${q}${X}02${G}${Y}`}},w0=BigInt(0),X0=BigInt(1),eX=BigInt(2),PQ=BigInt(3),$z=BigInt(4);function PY($){let Q=SY($),{Fp:J}=Q,Y=Q.toBytes||((W,V,K)=>{let U=V.toAffine();return e0(Uint8Array.from([4]),J.toBytes(U.x),J.toBytes(U.y))}),X=Q.fromBytes||((W)=>{let V=W.subarray(1),K=J.fromBytes(V.subarray(0,J.BYTES)),U=J.fromBytes(V.subarray(J.BYTES,2*J.BYTES));return{x:K,y:U}});function z(W){let{a:V,b:K}=Q,U=J.sqr(W),T=J.mul(U,W);return J.add(J.add(T,J.mul(W,V)),K)}if(!J.eql(J.sqr(Q.Gy),z(Q.Gx)))throw new Error("bad generator point: equation left != right");function Z(W){return typeof W==="bigint"&&w0<W&&W<Q.n}function G(W){if(!Z(W))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function q(W){let{allowedPrivateKeyLengths:V,nByteLength:K,wrapPrivateKey:U,n:T}=Q;if(V&&typeof W!=="bigint"){if(W instanceof Uint8Array)W=g0(W);if(typeof W!=="string"||!V.includes(W.length))throw new Error("Invalid key");W=W.padStart(K*2,"0")}let C;try{C=typeof W==="bigint"?W:j0(e("private key",W,K))}catch(R){throw new Error(`private key must be ${K} bytes, hex or bigint, not ${typeof W}`)}if(U)C=a(C,T);return G(C),C}let I=new Map;function M(W){if(!(W instanceof D))throw new Error("ProjectivePoint expected")}class D{constructor(W,V,K){if(this.px=W,this.py=V,this.pz=K,W==null||!J.isValid(W))throw new Error("x required");if(V==null||!J.isValid(V))throw new Error("y required");if(K==null||!J.isValid(K))throw new Error("z required")}static fromAffine(W){let{x:V,y:K}=W||{};if(!W||!J.isValid(V)||!J.isValid(K))throw new Error("invalid affine point");if(W instanceof D)throw new Error("projective point not allowed");let U=(T)=>J.eql(T,J.ZERO);if(U(V)&&U(K))return D.ZERO;return new D(V,K,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(W){let V=J.invertBatch(W.map((K)=>K.pz));return W.map((K,U)=>K.toAffine(V[U])).map(D.fromAffine)}static fromHex(W){let V=D.fromAffine(X(e("pointHex",W)));return V.assertValidity(),V}static fromPrivateKey(W){return D.BASE.multiply(q(W))}_setWindowSize(W){this._WINDOW_SIZE=W,I.delete(this)}assertValidity(){if(this.is0()){if(Q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:W,y:V}=this.toAffine();if(!J.isValid(W)||!J.isValid(V))throw new Error("bad point: x or y not FE");let K=J.sqr(V),U=z(W);if(!J.eql(K,U))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:W}=this.toAffine();if(J.isOdd)return!J.isOdd(W);throw new Error("Field doesn't support isOdd")}equals(W){M(W);let{px:V,py:K,pz:U}=this,{px:T,py:C,pz:R}=W,H=J.eql(J.mul(V,R),J.mul(T,U)),S=J.eql(J.mul(K,R),J.mul(C,U));return H&&S}negate(){return new D(this.px,J.neg(this.py),this.pz)}double(){let{a:W,b:V}=Q,K=J.mul(V,PQ),{px:U,py:T,pz:C}=this,R=J.ZERO,H=J.ZERO,S=J.ZERO,E=J.mul(U,U),y=J.mul(T,T),_=J.mul(C,C),F=J.mul(U,T);return F=J.add(F,F),S=J.mul(U,C),S=J.add(S,S),R=J.mul(W,S),H=J.mul(K,_),H=J.add(R,H),R=J.sub(y,H),H=J.add(y,H),H=J.mul(R,H),R=J.mul(F,R),S=J.mul(K,S),_=J.mul(W,_),F=J.sub(E,_),F=J.mul(W,F),F=J.add(F,S),S=J.add(E,E),E=J.add(S,E),E=J.add(E,_),E=J.mul(E,F),H=J.add(H,E),_=J.mul(T,C),_=J.add(_,_),E=J.mul(_,F),R=J.sub(R,E),S=J.mul(_,y),S=J.add(S,S),S=J.add(S,S),new D(R,H,S)}add(W){M(W);let{px:V,py:K,pz:U}=this,{px:T,py:C,pz:R}=W,H=J.ZERO,S=J.ZERO,E=J.ZERO,y=Q.a,_=J.mul(Q.b,PQ),F=J.mul(V,T),h=J.mul(K,C),r=J.mul(U,R),V0=J.add(V,K),d=J.add(T,C);V0=J.mul(V0,d),d=J.add(F,h),V0=J.sub(V0,d),d=J.add(V,U);let N=J.add(T,R);return d=J.mul(d,N),N=J.add(F,r),d=J.sub(d,N),N=J.add(K,U),H=J.add(C,R),N=J.mul(N,H),H=J.add(h,r),N=J.sub(N,H),E=J.mul(y,d),H=J.mul(_,r),E=J.add(H,E),H=J.sub(h,E),E=J.add(h,E),S=J.mul(H,E),h=J.add(F,F),h=J.add(h,F),r=J.mul(y,r),d=J.mul(_,d),h=J.add(h,r),r=J.sub(F,r),r=J.mul(y,r),d=J.add(d,r),F=J.mul(h,d),S=J.add(S,F),F=J.mul(N,d),H=J.mul(V0,H),H=J.sub(H,F),F=J.mul(V0,h),E=J.mul(N,E),E=J.add(E,F),new D(H,S,E)}subtract(W){return this.add(W.negate())}is0(){return this.equals(D.ZERO)}wNAF(W){return w.wNAFCached(this,I,W,(V)=>{let K=J.invertBatch(V.map((U)=>U.pz));return V.map((U,T)=>U.toAffine(K[T])).map(D.fromAffine)})}multiplyUnsafe(W){let V=D.ZERO;if(W===w0)return V;if(G(W),W===X0)return this;let{endo:K}=Q;if(!K)return w.unsafeLadder(this,W);let{k1neg:U,k1:T,k2neg:C,k2:R}=K.splitScalar(W),H=V,S=V,E=this;while(T>w0||R>w0){if(T&X0)H=H.add(E);if(R&X0)S=S.add(E);E=E.double(),T>>=X0,R>>=X0}if(U)H=H.negate();if(C)S=S.negate();return S=new D(J.mul(S.px,K.beta),S.py,S.pz),H.add(S)}multiply(W){G(W);let V=W,K,U,{endo:T}=Q;if(T){let{k1neg:C,k1:R,k2neg:H,k2:S}=T.splitScalar(V),{p:E,f:y}=this.wNAF(R),{p:_,f:F}=this.wNAF(S);E=w.constTimeNegate(C,E),_=w.constTimeNegate(H,_),_=new D(J.mul(_.px,T.beta),_.py,_.pz),K=E.add(_),U=y.add(F)}else{let{p:C,f:R}=this.wNAF(V);K=C,U=R}return D.normalizeZ([K,U])[0]}multiplyAndAddUnsafe(W,V,K){let U=D.BASE,T=(R,H)=>H===w0||H===X0||!R.equals(U)?R.multiplyUnsafe(H):R.multiply(H),C=T(this,V).add(T(W,K));return C.is0()?void 0:C}toAffine(W){let{px:V,py:K,pz:U}=this,T=this.is0();if(W==null)W=T?J.ONE:J.inv(U);let C=J.mul(V,W),R=J.mul(K,W),H=J.mul(U,W);if(T)return{x:J.ZERO,y:J.ZERO};if(!J.eql(H,J.ONE))throw new Error("invZ was invalid");return{x:C,y:R}}isTorsionFree(){let{h:W,isTorsionFree:V}=Q;if(W===X0)return!0;if(V)return V(D,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:W,clearCofactor:V}=Q;if(W===X0)return this;if(V)return V(D,this);return this.multiplyUnsafe(Q.h)}toRawBytes(W=!0){return this.assertValidity(),Y(D,this,W)}toHex(W=!0){return g0(this.toRawBytes(W))}}D.BASE=new D(Q.Gx,Q.Gy,J.ONE),D.ZERO=new D(J.ZERO,J.ONE,J.ZERO);let O=Q.nBitLength,w=LQ(D,Q.endo?Math.ceil(O/2):O);return{CURVE:Q,ProjectivePoint:D,normPrivateKeyToScalar:q,weierstrassEquation:z,isWithinCurveOrder:Z}}function AY($){let Q=q8($);return b0(Q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Q})}function AQ($){let Q=AY($),{Fp:J,n:Y}=Q,X=J.BYTES+1,z=2*J.BYTES+1;function Z(N){return w0<N&&N<J.ORDER}function G(N){return a(N,Y)}function q(N){return P$(N,Y)}let{ProjectivePoint:I,normPrivateKeyToScalar:M,weierstrassEquation:D,isWithinCurveOrder:O}=PY({...Q,toBytes(N,L,k){let x=L.toAffine(),m=J.toBytes(x.x),p=e0;if(k)return p(Uint8Array.from([L.hasEvenY()?2:3]),m);else return p(Uint8Array.from([4]),m,J.toBytes(x.y))},fromBytes(N){let L=N.length,k=N[0],x=N.subarray(1);if(L===X&&(k===2||k===3)){let m=j0(x);if(!Z(m))throw new Error("Point is not on curve");let p=D(m),Z0=J.sqrt(p),t=(Z0&X0)===X0;if((k&1)===1!==t)Z0=J.neg(Z0);return{x:m,y:Z0}}else if(L===z&&k===4){let m=J.fromBytes(x.subarray(0,J.BYTES)),p=J.fromBytes(x.subarray(J.BYTES,2*J.BYTES));return{x:m,y:p}}else throw new Error(`Point of length ${L} was invalid. Expected ${X} compressed bytes or ${z} uncompressed bytes`)}}),w=(N)=>g0(k0(N,Q.nByteLength));function W(N){let L=Y>>X0;return N>L}function V(N){return W(N)?G(-N):N}let K=(N,L,k)=>j0(N.slice(L,k));class U{constructor(N,L,k){this.r=N,this.s=L,this.recovery=k,this.assertValidity()}static fromCompact(N){let L=Q.nByteLength;return N=e("compactSignature",N,L*2),new U(K(N,0,L),K(N,L,2*L))}static fromDER(N){let{r:L,s:k}=u0.toSig(e("DER",N));return new U(L,k)}assertValidity(){if(!O(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!O(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(N){return new U(this.r,this.s,N)}recoverPublicKey(N){let{r:L,s:k,recovery:x}=this,m=E(e("msgHash",N));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");let p=x===2||x===3?L+Q.n:L;if(p>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");let Z0=(x&1)===0?"02":"03",t=I.fromHex(Z0+w(p)),O0=q(p),f0=G(-m*O0),p0=G(k*O0),y0=I.BASE.multiplyAndAddUnsafe(t,f0,p0);if(!y0)throw new Error("point at infinify");return y0.assertValidity(),y0}hasHighS(){return W(this.s)}normalizeS(){return this.hasHighS()?new U(this.r,G(-this.s),this.recovery):this}toDERRawBytes(){return c0(this.toDERHex())}toDERHex(){return u0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return c0(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}let T={isValidPrivateKey(N){try{return M(N),!0}catch(L){return!1}},normPrivateKeyToScalar:M,randomPrivateKey:()=>{let N=Z8(Q.n);return CQ(Q.randomBytes(N),Q.n)},precompute(N=8,L=I.BASE){return L._setWindowSize(N),L.multiply(BigInt(3)),L}};function C(N,L=!0){return I.fromPrivateKey(N).toRawBytes(L)}function R(N){let L=N instanceof Uint8Array,k=typeof N==="string",x=(L||k)&&N.length;if(L)return x===X||x===z;if(k)return x===2*X||x===2*z;if(N instanceof I)return!0;return!1}function H(N,L,k=!0){if(R(N))throw new Error("first arg must be private key");if(!R(L))throw new Error("second arg must be public key");return I.fromHex(L).multiply(M(N)).toRawBytes(k)}let S=Q.bits2int||function(N){let L=j0(N),k=N.length*8-Q.nBitLength;return k>0?L>>BigInt(k):L},E=Q.bits2int_modN||function(N){return G(S(N))},y=I$(Q.nBitLength);function _(N){if(typeof N!=="bigint")throw new Error("bigint expected");if(!(w0<=N&&N<y))throw new Error(`bigint expected < 2^${Q.nBitLength}`);return k0(N,Q.nByteLength)}function F(N,L,k=h){if(["recovered","canonical"].some((x0)=>(x0 in k)))throw new Error("sign() legacy options not supported");let{hash:x,randomBytes:m}=Q,{lowS:p,prehash:Z0,extraEntropy:t}=k;if(p==null)p=!0;if(N=e("msgHash",N),Z0)N=e("prehashed msgHash",x(N));let O0=E(N),f0=M(L),p0=[_(f0),_(O0)];if(t!=null){let x0=t===!0?m(J.BYTES):t;p0.push(e("extraEntropy",x0))}let y0=e0(...p0),D$=O0;function x$(x0){let l0=S(x0);if(!O(l0))return;let L8=q(l0),K0=I.BASE.multiply(l0).toAffine(),n0=G(K0.x);if(n0===w0)return;let V$=G(L8*G(D$+n0*f0));if(V$===w0)return;let P8=(K0.x===n0?0:2)|Number(K0.y&X0),A8=V$;if(p&&W(V$))A8=V(V$),P8^=1;return new U(n0,A8,P8)}return{seed:y0,k2sig:x$}}let h={lowS:Q.lowS,prehash:!1},r={lowS:Q.lowS,prehash:!1};function V0(N,L,k=h){let{seed:x,k2sig:m}=F(N,L,k),p=Q;return Q8(p.hash.outputLen,p.nByteLength,p.hmac)(x,m)}I.BASE._setWindowSize(8);function d(N,L,k,x=r){let m=N;if(L=e("msgHash",L),k=e("publicKey",k),"strict"in x)throw new Error("options.strict was renamed to lowS");let{lowS:p,prehash:Z0}=x,t=void 0,O0;try{if(typeof m==="string"||m instanceof Uint8Array)try{t=U.fromDER(m)}catch(K0){if(!(K0 instanceof u0.Err))throw K0;t=U.fromCompact(m)}else if(typeof m==="object"&&typeof m.r==="bigint"&&typeof m.s==="bigint"){let{r:K0,s:n0}=m;t=new U(K0,n0)}else throw new Error("PARSE");O0=I.fromHex(k)}catch(K0){if(K0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(p&&t.hasHighS())return!1;if(Z0)L=Q.hash(L);let{r:f0,s:p0}=t,y0=E(L),D$=q(p0),x$=G(y0*D$),x0=G(f0*D$),l0=I.BASE.multiplyAndAddUnsafe(O0,x$,x0)?.toAffine();if(!l0)return!1;return G(l0.x)===f0}return{CURVE:Q,getPublicKey:C,getSharedSecret:H,sign:V0,verify:d,ProjectivePoint:I,Signature:U,utils:T}}class M8 extends M${constructor($,Q){super();this.finished=!1,this.destroyed=!1,IQ($);let J=q$(Q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let Y=this.blockLen,X=new Uint8Array(Y);X.set(J.length>Y?$.create().update(J).digest():J);for(let z=0;z<X.length;z++)X[z]^=54;this.iHash.update(X),this.oHash=$.create();for(let z=0;z<X.length;z++)X[z]^=106;this.oHash.update(X),X.fill(0)}update($){return t0(this),this.iHash.update($),this}digestInto($){t0(this),s$($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){let $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));let{oHash:Q,iHash:J,finished:Y,destroyed:X,blockLen:z,outputLen:Z}=this;return $=$,$.finished=Y,$.destroyed=X,$.blockLen=z,$.outputLen=Z,$.oHash=Q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var I8=($,Q,J)=>new M8($,Q).update(J).digest();I8.create=($,Q)=>new M8($,Q);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function BY($){return{hash:$,hmac:(Q,...J)=>I8($,Q,VQ(...J)),randomBytes:UQ}}function BQ($,Q){let J=(Y)=>AQ({...$,...BY(Y)});return Object.freeze({...J(Q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var kQ=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),FQ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),FY=BigInt(1),W8=BigInt(2),_Q=($,Q)=>($+Q/W8)/Q;function _Y($){let Q=kQ,J=BigInt(3),Y=BigInt(6),X=BigInt(11),z=BigInt(22),Z=BigInt(23),G=BigInt(44),q=BigInt(88),I=$*$*$%Q,M=I*I*$%Q,D=$0(M,J,Q)*M%Q,O=$0(D,J,Q)*M%Q,w=$0(O,W8,Q)*I%Q,W=$0(w,X,Q)*w%Q,V=$0(W,z,Q)*W%Q,K=$0(V,G,Q)*V%Q,U=$0(K,q,Q)*K%Q,T=$0(U,G,Q)*V%Q,C=$0(T,J,Q)*M%Q,R=$0(C,Z,Q)*W%Q,H=$0(R,Y,Q)*I%Q,S=$0(H,W8,Q);if(!D8.eql(D8.sqr(S),$))throw new Error("Cannot find square root");return S}var D8=EQ(kQ,void 0,void 0,{sqrt:_Y}),R0=BQ({a:BigInt(0),b:BigInt(7),Fp:D8,n:FQ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{let Q=FQ,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Y=-FY*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),z=J,Z=BigInt("0x100000000000000000000000000000000"),G=_Q(z*$,Q),q=_Q(-Y*$,Q),I=a($-G*J-q*X,Q),M=a(-G*Y-q*z,Q),D=I>Z,O=M>Z;if(D)I=Q-I;if(O)M=Q-M;if(I>Z||M>Z)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:D,k1:I,k2neg:O,k2:M}}}},TQ),Dz=BigInt(0);var Vz=R0.ProjectivePoint;var V8="0x0000000000000000000000000000000000000000";var A$="0x0000000000000000000000000000000000000000000000000000000000000000";var bQ=BigInt(0),fQ=BigInt(1),yQ=BigInt(2),xQ=BigInt(27),vQ=BigInt(28),B$=BigInt(35),$$={};function mQ($){return E0(s($),32)}class l{#$;#J;#Y;#Q;get r(){return this.#$}set r($){j(H0($)===32,"invalid r","value",$),this.#$=P($)}get s(){return this.#J}set s($){j(H0($)===32,"invalid s","value",$);let Q=P($);j(parseInt(Q.substring(0,3))<8,"non-canonical s","value",Q),this.#J=Q}get v(){return this.#Y}set v($){let Q=J0($,"value");j(Q===27||Q===28,"invalid v","v",$),this.#Y=Q}get networkV(){return this.#Q}get legacyChainId(){let $=this.networkV;if($==null)return null;return l.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){let $=f(this.s);if(this.yParity)$[0]|=128;return P($)}get compactSerialized(){return q0([this.r,this.yParityAndS])}get serialized(){return q0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,Q,J,Y){g$($,$$,"Signature"),this.#$=Q,this.#J=J,this.#Y=Y,this.#Q=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){let $=new l($$,this.r,this.s,this.v);if(this.networkV)$.#Q=this.networkV;return $}toJSON(){let $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){let Q=g($,"v");if(Q==xQ||Q==vQ)return bQ;return j(Q>=B$,"invalid EIP-155 v","v",$),(Q-B$)/yQ}static getChainIdV($,Q){return g($)*yQ+BigInt(35+Q-27)}static getNormalizedV($){let Q=g($);if(Q===bQ||Q===xQ)return 27;if(Q===fQ||Q===vQ)return 28;return j(Q>=B$,"invalid v","v",$),Q&fQ?27:28}static from($){function Q(q,I){j(q,I,"signature",$)}if($==null)return new l($$,A$,A$,27);if(typeof $==="string"){let q=f($,"signature");if(q.length===64){let I=P(q.slice(0,32)),M=q.slice(32,64),D=M[0]&128?28:27;return M[0]&=127,new l($$,I,P(M),D)}if(q.length===65){let I=P(q.slice(0,32)),M=q.slice(32,64);Q((M[0]&128)===0,"non-canonical s");let D=l.getNormalizedV(q[64]);return new l($$,I,P(M),D)}Q(!1,"invalid raw signature length")}if($ instanceof l)return $.clone();let J=$.r;Q(J!=null,"missing r");let Y=mQ(J),X=function(q,I){if(q!=null)return mQ(q);if(I!=null){Q(Q0(I,32),"invalid yParityAndS");let M=f(I);return M[0]&=127,P(M)}Q(!1,"missing s")}($.s,$.yParityAndS);Q((f(X)[0]&128)==0,"non-canonical s");let{networkV:z,v:Z}=function(q,I,M){if(q!=null){let D=g(q);return{networkV:D>=B$?D:void 0,v:l.getNormalizedV(D)}}if(I!=null)return Q(Q0(I,32),"invalid yParityAndS"),{v:f(I)[0]&128?28:27};if(M!=null){switch(J0(M,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Q(!1,"invalid yParity")}Q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),G=new l($$,Y,X,Z);if(z)G.#Q=z;return Q($.yParity==null||J0($.yParity,"sig.yParity")===G.yParity,"yParity mismatch"),Q($.yParityAndS==null||$.yParityAndS===G.yParityAndS,"yParityAndS mismatch"),G}}class z0{#$;constructor($){j(H0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=P($)}get privateKey(){return this.#$}get publicKey(){return z0.computePublicKey(this.#$)}get compressedPublicKey(){return z0.computePublicKey(this.#$,!0)}sign($){j(H0($)===32,"invalid digest length","digest",$);let Q=R0.sign(m0($),m0(this.#$),{lowS:!0});return l.from({r:O$(Q.r,32),s:O$(Q.s,32),v:Q.recovery?28:27})}computeSharedSecret($){let Q=z0.computePublicKey($);return P(R0.getSharedSecret(m0(this.#$),f(Q),!1))}static computePublicKey($,Q){let J=f($,"key");if(J.length===32){let X=R0.getPublicKey(J,!!Q);return P(X)}if(J.length===64){let X=new Uint8Array(65);X[0]=4,X.set(J,1),J=X}let Y=R0.ProjectivePoint.fromHex(J);return P(Y.toRawBytes(Q))}static recoverPublicKey($,Q){j(H0($)===32,"invalid digest length","digest",$);let J=l.from(Q),Y=R0.Signature.fromCompact(m0(q0([J.r,J.s])));Y=Y.addRecoveryBit(J.yParity);let X=Y.recoverPublicKey(m0($));return j(X!=null,"invalid signautre for digest","signature",Q),"0x"+X.toHex(!1)}static addPoints($,Q,J){let Y=R0.ProjectivePoint.fromHex(z0.computePublicKey($).substring(2)),X=R0.ProjectivePoint.fromHex(z0.computePublicKey(Q).substring(2));return"0x"+Y.add(X).toHex(!!J)}}var kY=BigInt(0),bY=BigInt(36);function gQ($){$=$.toLowerCase();let Q=$.substring(2).split(""),J=new Uint8Array(40);for(let X=0;X<40;X++)J[X]=Q[X].charCodeAt(0);let Y=f(Y0(J));for(let X=0;X<40;X+=2){if(Y[X>>1]>>4>=8)Q[X]=Q[X].toUpperCase();if((Y[X>>1]&15)>=8)Q[X+1]=Q[X+1].toUpperCase()}return"0x"+Q.join("")}var K8={};for(let $=0;$<10;$++)K8[String($)]=String($);for(let $=0;$<26;$++)K8[String.fromCharCode(65+$)]=String(10+$);var cQ=15;function fY($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let Q=$.split("").map((Y)=>{return K8[Y]}).join("");while(Q.length>=cQ){let Y=Q.substring(0,cQ);Q=parseInt(Y,10)%97+Q.substring(Y.length)}let J=String(98-parseInt(Q,10)%97);while(J.length<2)J="0"+J;return J}var yY=function(){let $={};for(let Q=0;Q<36;Q++){let J="0123456789abcdefghijklmnopqrstuvwxyz"[Q];$[J]=BigInt(Q)}return $}();function xY($){$=$.toLowerCase();let Q=kY;for(let J=0;J<$.length;J++)Q=Q*bY+yY[$[J]];return Q}function W0($){if(j(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;let Q=gQ($);return j(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Q===$,"bad address checksum","address",$),Q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){j($.substring(2,4)===fY($),"bad icap checksum","address",$);let Q=xY($.substring(4)).toString(16);while(Q.length<40)Q="0"+Q;return gQ("0x"+Q)}j(!1,"invalid address","address",$)}function hQ($){return $&&typeof $.getAddress==="function"}async function U8($,Q){let J=await Q;if(J==null||J==="0x0000000000000000000000000000000000000000")A(typeof $!=="string","unconfigured name","UNCONFIGURED_NAME",{value:$}),j(!1,"invalid AddressLike value; did not resolve to a value address","target",$);return W0(J)}function F$($,Q){if(typeof $==="string"){if($.match(/^0x[0-9a-f]{40}$/i))return W0($);return A(Q!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),U8($,Q.resolveName($))}else if(hQ($))return U8($,$.getAddress());else if($&&typeof $.then==="function")return U8($,$);j(!1,"unsupported addressable value","target",$)}function O8($,Q){return{address:W0($),storageKeys:Q.map((J,Y)=>{return j(Q0(J,32),"invalid slot",`storageKeys[${Y}]`,J),J.toLowerCase()})}}function d0($){if(Array.isArray($))return $.map((J,Y)=>{if(Array.isArray(J))return j(J.length===2,"invalid slot set",`value[${Y}]`,J),O8(J[0],J[1]);return j(J!=null&&typeof J==="object","invalid address-slot set","value",$),O8(J.address,J.storageKeys)});j($!=null&&typeof $==="object","invalid access list","value",$);let Q=Object.keys($).map((J)=>{let Y=$[J].reduce((X,z)=>{return X[z]=!0,X},{});return O8(J,Object.keys(Y).sort())});return Q.sort((J,Y)=>J.address.localeCompare(Y.address)),Q}function vY($){let Q;if(typeof $==="string")Q=z0.computePublicKey($,!1);else Q=$.publicKey;return W0(Y0("0x"+Q.substring(4)).substring(26))}function uQ($,Q){return vY(z0.recoverPublicKey($,Q))}var o=BigInt(0),mY=BigInt(2),gY=BigInt(27),cY=BigInt(28),hY=BigInt(35),uY=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),T8=131072;function dQ($,Q){let J=$.toString(16);while(J.length<2)J="0"+J;return J+=B0(Q).substring(4),"0x"+J}function _$($){if($==="0x")return null;return W0($)}function N8($,Q){try{return d0($)}catch(J){j(!1,J.message,Q,$)}}function W$($,Q){if($==="0x")return 0;return J0($,Q)}function u($,Q){if($==="0x")return o;let J=g($,Q);return j(J<=uY,"value exceeds uint size",Q,J),J}function v($,Q){let J=g($,"value"),Y=s(J);return j(Y.length<=32,"value too large",`tx.${Q}`,J),Y}function j8($){return d0($).map((Q)=>[Q.address,Q.storageKeys])}function dY($,Q){j(Array.isArray($),`invalid ${Q}`,"value",$);for(let J=0;J<$.length;J++)j(Q0($[J],32),"invalid ${ param } hash",`value[${J}]`,$[J]);return $}function pY($){let Q=r0($);j(Array.isArray(Q)&&(Q.length===9||Q.length===6),"invalid field count for legacy transaction","data",$);let J={type:0,nonce:W$(Q[0],"nonce"),gasPrice:u(Q[1],"gasPrice"),gasLimit:u(Q[2],"gasLimit"),to:_$(Q[3]),value:u(Q[4],"value"),data:P(Q[5]),chainId:o};if(Q.length===6)return J;let Y=u(Q[6],"v"),X=u(Q[7],"r"),z=u(Q[8],"s");if(X===o&&z===o)J.chainId=Y;else{let Z=(Y-hY)/mY;if(Z<o)Z=o;J.chainId=Z,j(Z!==o||(Y===gY||Y===cY),"non-canonical legacy v","v",Q[6]),J.signature=l.from({r:E0(Q[7],32),s:E0(Q[8],32),v:Y})}return J}function lY($,Q){let J=[v($.nonce,"nonce"),v($.gasPrice||0,"gasPrice"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data],Y=o;if($.chainId!=o)Y=g($.chainId,"tx.chainId"),j(!Q||Q.networkV==null||Q.legacyChainId===Y,"tx.chainId/sig.v mismatch","sig",Q);else if($.signature){let z=$.signature.legacyChainId;if(z!=null)Y=z}if(!Q){if(Y!==o)J.push(s(Y)),J.push("0x"),J.push("0x");return S0(J)}let X=BigInt(27+Q.yParity);if(Y!==o)X=l.getChainIdV(Y,Q.v);else if(BigInt(Q.v)!==X)j(!1,"tx.chainId/sig.v mismatch","sig",Q);return J.push(s(X)),J.push(s(Q.r)),J.push(s(Q.s)),S0(J)}function w8($,Q){let J;try{if(J=W$(Q[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(Z){j(!1,"invalid yParity","yParity",Q[0])}let Y=E0(Q[1],32),X=E0(Q[2],32),z=l.from({r:Y,s:X,yParity:J});$.signature=z}function nY($){let Q=r0(f($).slice(1));j(Array.isArray(Q)&&(Q.length===9||Q.length===12),"invalid field count for transaction type: 2","data",P($));let J={type:2,chainId:u(Q[0],"chainId"),nonce:W$(Q[1],"nonce"),maxPriorityFeePerGas:u(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:u(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:u(Q[4],"gasLimit"),to:_$(Q[5]),value:u(Q[6],"value"),data:P(Q[7]),accessList:N8(Q[8],"accessList")};if(Q.length===9)return J;return w8(J,Q.slice(9)),J}function oY($,Q){let J=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),v($.maxFeePerGas||0,"maxFeePerGas"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data,j8($.accessList||[])];if(Q)J.push(v(Q.yParity,"yParity")),J.push(s(Q.r)),J.push(s(Q.s));return q0(["0x02",S0(J)])}function iY($){let Q=r0(f($).slice(1));j(Array.isArray(Q)&&(Q.length===8||Q.length===11),"invalid field count for transaction type: 1","data",P($));let J={type:1,chainId:u(Q[0],"chainId"),nonce:W$(Q[1],"nonce"),gasPrice:u(Q[2],"gasPrice"),gasLimit:u(Q[3],"gasLimit"),to:_$(Q[4]),value:u(Q[5],"value"),data:P(Q[6]),accessList:N8(Q[7],"accessList")};if(Q.length===8)return J;return w8(J,Q.slice(8)),J}function rY($,Q){let J=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.gasPrice||0,"gasPrice"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data,j8($.accessList||[])];if(Q)J.push(v(Q.yParity,"recoveryParam")),J.push(s(Q.r)),J.push(s(Q.s));return q0(["0x01",S0(J)])}function aY($){let Q=r0(f($).slice(1)),J="3",Y=null;if(Q.length===4&&Array.isArray(Q[0])){J="3 (network format)";let z=Q[1],Z=Q[2],G=Q[3];j(Array.isArray(z),"invalid network format: blobs not an array","fields[1]",z),j(Array.isArray(Z),"invalid network format: commitments not an array","fields[2]",Z),j(Array.isArray(G),"invalid network format: proofs not an array","fields[3]",G),j(z.length===Z.length,"invalid network format: blobs/commitments length mismatch","fields",Q),j(z.length===G.length,"invalid network format: blobs/proofs length mismatch","fields",Q),Y=[];for(let q=0;q<Q[1].length;q++)Y.push({data:z[q],commitment:Z[q],proof:G[q]});Q=Q[0]}j(Array.isArray(Q)&&(Q.length===11||Q.length===14),`invalid field count for transaction type: ${J}`,"data",P($));let X={type:3,chainId:u(Q[0],"chainId"),nonce:W$(Q[1],"nonce"),maxPriorityFeePerGas:u(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:u(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:u(Q[4],"gasLimit"),to:_$(Q[5]),value:u(Q[6],"value"),data:P(Q[7]),accessList:N8(Q[8],"accessList"),maxFeePerBlobGas:u(Q[9],"maxFeePerBlobGas"),blobVersionedHashes:Q[10]};if(Y)X.blobs=Y;j(X.to!=null,`invalid address for transaction type: ${J}`,"data",$),j(Array.isArray(X.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",$);for(let z=0;z<X.blobVersionedHashes.length;z++)j(Q0(X.blobVersionedHashes[z],32),`invalid blobVersionedHash at index ${z}: must be length 32`,"data",$);if(Q.length===11)return X;return w8(X,Q.slice(11)),X}function sY($,Q,J){let Y=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),v($.maxFeePerGas||0,"maxFeePerGas"),v($.gasLimit,"gasLimit"),$.to||V8,v($.value,"value"),$.data,j8($.accessList||[]),v($.maxFeePerBlobGas||0,"maxFeePerBlobGas"),dY($.blobVersionedHashes||[],"blobVersionedHashes")];if(Q){if(Y.push(v(Q.yParity,"yParity")),Y.push(s(Q.r)),Y.push(s(Q.s)),J)return q0(["0x03",S0([Y,J.map((X)=>X.data),J.map((X)=>X.commitment),J.map((X)=>X.proof)])])}return q0(["0x03",S0(Y)])}class D0{#$;#J;#Y;#Q;#q;#M;#I;#W;#D;#V;#K;#U;#G;#z;#X;#Z;get type(){return this.#$}set type($){switch($){case null:this.#$=null;break;case 0:case"legacy":this.#$=0;break;case 1:case"berlin":case"eip-2930":this.#$=1;break;case 2:case"london":case"eip-1559":this.#$=2;break;case 3:case"cancun":case"eip-4844":this.#$=3;break;default:j(!1,"unsupported transaction type","type",$)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844"}return null}get to(){let $=this.#J;if($==null&&this.type===3)return V8;return $}set to($){this.#J=$==null?null:W0($)}get nonce(){return this.#Q}set nonce($){this.#Q=J0($,"value")}get gasLimit(){return this.#q}set gasLimit($){this.#q=g($)}get gasPrice(){let $=this.#M;if($==null&&(this.type===0||this.type===1))return o;return $}set gasPrice($){this.#M=$==null?null:g($,"gasPrice")}get maxPriorityFeePerGas(){let $=this.#I;if($==null){if(this.type===2||this.type===3)return o;return null}return $}set maxPriorityFeePerGas($){this.#I=$==null?null:g($,"maxPriorityFeePerGas")}get maxFeePerGas(){let $=this.#W;if($==null){if(this.type===2||this.type===3)return o;return null}return $}set maxFeePerGas($){this.#W=$==null?null:g($,"maxFeePerGas")}get data(){return this.#Y}set data($){this.#Y=P($)}get value(){return this.#D}set value($){this.#D=g($,"value")}get chainId(){return this.#V}set chainId($){this.#V=g($)}get signature(){return this.#K||null}set signature($){this.#K=$==null?null:l.from($)}get accessList(){let $=this.#U||null;if($==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return $}set accessList($){this.#U=$==null?null:d0($)}get maxFeePerBlobGas(){let $=this.#G;if($==null&&this.type===3)return o;return $}set maxFeePerBlobGas($){this.#G=$==null?null:g($,"maxFeePerBlobGas")}get blobVersionedHashes(){let $=this.#z;if($==null&&this.type===3)return[];return $}set blobVersionedHashes($){if($!=null){j(Array.isArray($),"blobVersionedHashes must be an Array","value",$),$=$.slice();for(let Q=0;Q<$.length;Q++)j(Q0($[Q],32),"invalid blobVersionedHash",`value[${Q}]`,$[Q])}this.#z=$}get blobs(){if(this.#Z==null)return null;return this.#Z.map(($)=>Object.assign({},$))}set blobs($){if($==null){this.#Z=null;return}let Q=[],J=[];for(let Y=0;Y<$.length;Y++){let X=$[Y];if(Y$(X)){A(this.#X,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let z=f(X);if(j(z.length<=T8,"blob is too large",`blobs[${Y}]`,X),z.length!==T8){let q=new Uint8Array(T8);q.set(z),z=q}let Z=this.#X.blobToKzgCommitment(z),G=P(this.#X.computeBlobKzgProof(z,Z));Q.push({data:P(z),commitment:P(Z),proof:G}),J.push(dQ(1,Z))}else{let z=P(X.commitment);Q.push({data:P(X.data),commitment:z,proof:P(X.proof)}),J.push(dQ(1,z))}}this.#Z=Q,this.#z=J}get kzg(){return this.#X}set kzg($){this.#X=$}constructor(){this.#$=null,this.#J=null,this.#Q=0,this.#q=o,this.#M=null,this.#I=null,this.#W=null,this.#Y="0x",this.#D=o,this.#V=o,this.#K=null,this.#U=null,this.#G=null,this.#z=null,this.#Z=null,this.#X=null}get hash(){if(this.signature==null)return null;return Y0(this.#O(!0,!1))}get unsignedHash(){return Y0(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return uQ(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return z0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#O($,Q){A(!$||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});let J=$?this.signature:null;switch(this.inferType()){case 0:return lY(this,J);case 1:return rY(this,J);case 2:return oY(this,J);case 3:return sY(this,J,Q?this.blobs:null)}A(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#O(!0,!0)}get unsignedSerialized(){return this.#O(!1,!1)}inferType(){let $=this.inferTypes();if($.indexOf(2)>=0)return 2;return $.pop()}inferTypes(){let $=this.gasPrice!=null,Q=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,Y=this.#G!=null||this.#z;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)A(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});A(!Q||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),A(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});let X=[];if(this.type!=null)X.push(this.type);else if(Q)X.push(2);else if($){if(X.push(1),!J)X.push(0)}else if(J)X.push(1),X.push(2);else if(Y&&this.to)X.push(3);else X.push(0),X.push(1),X.push(2),X.push(3);return X.sort(),X}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return D0.from(this)}toJSON(){let $=(Q)=>{if(Q==null)return null;return Q.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:$(this.gasLimit),gasPrice:$(this.gasPrice),maxPriorityFeePerGas:$(this.maxPriorityFeePerGas),maxFeePerGas:$(this.maxFeePerGas),value:$(this.value),chainId:$(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from($){if($==null)return new D0;if(typeof $==="string"){let J=f($);if(J[0]>=127)return D0.from(pY(J));switch(J[0]){case 1:return D0.from(iY(J));case 2:return D0.from(nY(J));case 3:return D0.from(aY(J))}A(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}let Q=new D0;if($.type!=null)Q.type=$.type;if($.to!=null)Q.to=$.to;if($.nonce!=null)Q.nonce=$.nonce;if($.gasLimit!=null)Q.gasLimit=$.gasLimit;if($.gasPrice!=null)Q.gasPrice=$.gasPrice;if($.maxPriorityFeePerGas!=null)Q.maxPriorityFeePerGas=$.maxPriorityFeePerGas;if($.maxFeePerGas!=null)Q.maxFeePerGas=$.maxFeePerGas;if($.maxFeePerBlobGas!=null)Q.maxFeePerBlobGas=$.maxFeePerBlobGas;if($.data!=null)Q.data=$.data;if($.value!=null)Q.value=$.value;if($.chainId!=null)Q.chainId=$.chainId;if($.signature!=null)Q.signature=l.from($.signature);if($.accessList!=null)Q.accessList=$.accessList;if($.blobVersionedHashes!=null)Q.blobVersionedHashes=$.blobVersionedHashes;if($.kzg!=null)Q.kzg=$.kzg;if($.blobs!=null)Q.blobs=$.blobs;if($.hash!=null)j(Q.isSigned(),"unsigned transaction cannot define '.hash'","tx",$),j(Q.hash===$.hash,"hash mismatch","tx",$);if($.from!=null)j(Q.isSigned(),"unsigned transaction cannot define '.from'","tx",$),j(Q.from.toLowerCase()===($.from||"").toLowerCase(),"from mismatch","tx",$);return Q}}var pQ=BigInt(0);function R8($){if($==null)return null;return $}function i($){if($==null)return null;return $.toString()}function H8($){let Q={};if($.to)Q.to=$.to;if($.from)Q.from=$.from;if($.data)Q.data=P($.data);let J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let X of J){if(!(X in $)||$[X]==null)continue;Q[X]=g($[X],`request.${X}`)}let Y="type,nonce".split(/,/);for(let X of Y){if(!(X in $)||$[X]==null)continue;Q[X]=J0($[X],`request.${X}`)}if($.accessList)Q.accessList=d0($.accessList);if("blockTag"in $)Q.blockTag=$.blockTag;if("enableCcipRead"in $)Q.enableCcipRead=!!$.enableCcipRead;if("customData"in $)Q.customData=$.customData;if("blobVersionedHashes"in $&&$.blobVersionedHashes)Q.blobVersionedHashes=$.blobVersionedHashes.slice();if("kzg"in $)Q.kzg=$.kzg;if("blobs"in $&&$.blobs)Q.blobs=$.blobs.map((X)=>{if(Y$(X))return P(X);return Object.assign({},X)});return Q}class lQ{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#$;constructor($,Q){this.#$=$.transactions.map((J)=>{if(typeof J!=="string")return new k$(J,Q);return J}),G0(this,{provider:Q,hash:R8($.hash),number:$.number,timestamp:$.timestamp,parentHash:$.parentHash,parentBeaconBlockRoot:$.parentBeaconBlockRoot,nonce:$.nonce,difficulty:$.difficulty,gasLimit:$.gasLimit,gasUsed:$.gasUsed,blobGasUsed:$.blobGasUsed,excessBlobGas:$.excessBlobGas,miner:$.miner,prevRandao:R8($.prevRandao),extraData:$.extraData,baseFeePerGas:R8($.baseFeePerGas),stateRoot:$.stateRoot,receiptsRoot:$.receiptsRoot})}get transactions(){return this.#$.map(($)=>{if(typeof $==="string")return $;return $.hash})}get prefetchedTransactions(){let $=this.#$.slice();if($.length===0)return[];return A(typeof $[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),$}toJSON(){let{baseFeePerGas:$,difficulty:Q,extraData:J,gasLimit:Y,gasUsed:X,hash:z,miner:Z,prevRandao:G,nonce:q,number:I,parentHash:M,parentBeaconBlockRoot:D,stateRoot:O,receiptsRoot:w,timestamp:W,transactions:V}=this;return{_type:"Block",baseFeePerGas:i($),difficulty:i(Q),extraData:J,gasLimit:i(Y),gasUsed:i(X),blobGasUsed:i(this.blobGasUsed),excessBlobGas:i(this.excessBlobGas),hash:z,miner:Z,prevRandao:G,nonce:q,number:I,parentHash:M,timestamp:W,parentBeaconBlockRoot:D,stateRoot:O,receiptsRoot:w,transactions:V}}[Symbol.iterator](){let $=0,Q=this.transactions;return{next:()=>{if($<this.length)return{value:Q[$++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#$.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction($){let Q=void 0;if(typeof $==="number")Q=this.#$[$];else{let J=$.toLowerCase();for(let Y of this.#$)if(typeof Y==="string"){if(Y!==J)continue;Q=Y;break}else{if(Y.hash!==J)continue;Q=Y;break}}if(Q==null)throw new Error("no such tx");if(typeof Q==="string")return await this.provider.getTransaction(Q);else return Q}getPrefetchedTransaction($){let Q=this.prefetchedTransactions;if(typeof $==="number")return Q[$];$=$.toLowerCase();for(let J of Q)if(J.hash===$)return J;j(!1,"no matching transaction","indexOrHash",$)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return tY(this)}}class E8{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor($,Q){this.provider=Q;let J=Object.freeze($.topics.slice());G0(this,{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,removed:$.removed,address:$.address,data:$.data,topics:J,index:$.index,transactionIndex:$.transactionIndex})}toJSON(){let{address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:q}=this;return{_type:"log",address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:q}}async getBlock(){let $=await this.provider.getBlock(this.blockHash);return A(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransaction(){let $=await this.provider.getTransaction(this.transactionHash);return A(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransactionReceipt(){let $=await this.provider.getTransactionReceipt(this.transactionHash);return A(!!$,"failed to find transaction receipt","UNKNOWN_ERROR",{}),$}removedEvent(){return eY(this)}}class nQ{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#$;constructor($,Q){this.#$=Object.freeze($.logs.map((Y)=>{return new E8(Y,Q)}));let J=pQ;if($.effectiveGasPrice!=null)J=$.effectiveGasPrice;else if($.gasPrice!=null)J=$.gasPrice;G0(this,{provider:Q,to:$.to,from:$.from,contractAddress:$.contractAddress,hash:$.hash,index:$.index,blockHash:$.blockHash,blockNumber:$.blockNumber,logsBloom:$.logsBloom,gasUsed:$.gasUsed,cumulativeGasUsed:$.cumulativeGasUsed,blobGasUsed:$.blobGasUsed,gasPrice:J,blobGasPrice:$.blobGasPrice,type:$.type,status:$.status,root:$.root})}get logs(){return this.#$}toJSON(){let{to:$,from:Q,contractAddress:J,hash:Y,index:X,blockHash:z,blockNumber:Z,logsBloom:G,logs:q,status:I,root:M}=this;return{_type:"TransactionReceipt",blockHash:z,blockNumber:Z,contractAddress:J,cumulativeGasUsed:i(this.cumulativeGasUsed),from:Q,gasPrice:i(this.gasPrice),blobGasUsed:i(this.blobGasUsed),blobGasPrice:i(this.blobGasPrice),gasUsed:i(this.gasUsed),hash:Y,index:X,logs:q,logsBloom:G,root:M,status:I,to:$}}get length(){return this.logs.length}[Symbol.iterator](){let $=0;return{next:()=>{if($<this.length)return{value:this.logs[$++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){let $=await this.provider.getBlock(this.blockHash);if($==null)throw new Error("TODO");return $}async getTransaction(){let $=await this.provider.getTransaction(this.hash);if($==null)throw new Error("TODO");return $}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return iQ(this)}reorderedEvent($){return A(!$||$.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),oQ(this,$)}}class k${provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;#$;constructor($,Q){this.provider=Q,this.blockNumber=$.blockNumber!=null?$.blockNumber:null,this.blockHash=$.blockHash!=null?$.blockHash:null,this.hash=$.hash,this.index=$.index,this.type=$.type,this.from=$.from,this.to=$.to||null,this.gasLimit=$.gasLimit,this.nonce=$.nonce,this.data=$.data,this.value=$.value,this.gasPrice=$.gasPrice,this.maxPriorityFeePerGas=$.maxPriorityFeePerGas!=null?$.maxPriorityFeePerGas:null,this.maxFeePerGas=$.maxFeePerGas!=null?$.maxFeePerGas:null,this.maxFeePerBlobGas=$.maxFeePerBlobGas!=null?$.maxFeePerBlobGas:null,this.chainId=$.chainId,this.signature=$.signature,this.accessList=$.accessList!=null?$.accessList:null,this.blobVersionedHashes=$.blobVersionedHashes!=null?$.blobVersionedHashes:null,this.#$=-1}toJSON(){let{blockNumber:$,blockHash:Q,index:J,hash:Y,type:X,to:z,from:Z,nonce:G,data:q,signature:I,accessList:M,blobVersionedHashes:D}=this;return{_type:"TransactionResponse",accessList:M,blockNumber:$,blockHash:Q,blobVersionedHashes:D,chainId:i(this.chainId),data:q,from:Z,gasLimit:i(this.gasLimit),gasPrice:i(this.gasPrice),hash:Y,maxFeePerGas:i(this.maxFeePerGas),maxPriorityFeePerGas:i(this.maxPriorityFeePerGas),maxFeePerBlobGas:i(this.maxFeePerBlobGas),nonce:G,signature:I,to:z,index:J,type:X,value:i(this.value)}}async getBlock(){let $=this.blockNumber;if($==null){let J=await this.getTransaction();if(J)$=J.blockNumber}if($==null)return null;let Q=this.provider.getBlock($);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){let{tx:Q,blockNumber:J}=await v0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Q==null||Q.blockNumber==null)return 0;return J-Q.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait($,Q){let J=$==null?1:$,Y=Q==null?0:Q,X=this.#$,z=-1,Z=X===-1?!0:!1,G=async()=>{if(Z)return null;let{blockNumber:D,nonce:O}=await v0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(O<this.nonce){X=D;return}if(Z)return null;let w=await this.getTransaction();if(w&&w.blockNumber!=null)return;if(z===-1){if(z=X-3,z<this.#$)z=this.#$}while(z<=D){if(Z)return null;let W=await this.provider.getBlock(z,!0);if(W==null)return;for(let V of W)if(V===this.hash)return;for(let V=0;V<W.length;V++){let K=await W.getTransaction(V);if(K.from===this.from&&K.nonce===this.nonce){if(Z)return null;let U=await this.provider.getTransactionReceipt(K.hash);if(U==null)return;if(D-U.blockNumber+1<J)return;let T="replaced";if(K.data===this.data&&K.to===this.to&&K.value===this.value)T="repriced";else if(K.data==="0x"&&K.from===K.to&&K.value===pQ)T="cancelled";A(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:T==="replaced"||T==="cancelled",reason:T,replacement:K.replaceableTransaction(X),hash:K.hash,receipt:U})}}z++}return},q=(D)=>{if(D==null||D.status!==0)return D;A(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:D.to,from:D.from,data:""},receipt:D})},I=await this.provider.getTransactionReceipt(this.hash);if(J===0)return q(I);if(I){if(await I.confirmations()>=J)return q(I)}else if(await G(),J===0)return null;return await new Promise((D,O)=>{let w=[],W=()=>{w.forEach((K)=>K())};if(w.push(()=>{Z=!0}),Y>0){let K=setTimeout(()=>{W(),O(U$("wait for transaction timeout","TIMEOUT"))},Y);w.push(()=>{clearTimeout(K)})}let V=async(K)=>{if(await K.confirmations()>=J){W();try{D(q(K))}catch(U){O(U)}}};if(w.push(()=>{this.provider.off(this.hash,V)}),this.provider.on(this.hash,V),X>=0){let K=async()=>{try{await G()}catch(U){if(m$(U,"TRANSACTION_REPLACED")){W(),O(U);return}}if(!Z)this.provider.once("block",K)};w.push(()=>{this.provider.off("block",K)}),this.provider.once("block",K)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return A(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),iQ(this)}reorderedEvent($){return A(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),A(!$||$.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),oQ(this,$)}replaceableTransaction($){j(Number.isInteger($)&&$>=0,"invalid startBlock","startBlock",$);let Q=new k$(this,this.provider);return Q.#$=$,Q}}function tY($){return{orphan:"drop-block",hash:$.hash,number:$.number}}function oQ($,Q){return{orphan:"reorder-transaction",tx:$,other:Q}}function iQ($){return{orphan:"drop-transaction",tx:$}}function eY($){return{orphan:"drop-log",log:{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,address:$.address,data:$.data,topics:Object.freeze($.topics.slice()),index:$.index}}}function Q$($,Q){if($.provider)return $.provider;A(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Q})}async function rQ($,Q){let J=H8(Q);if(J.to!=null)J.to=F$(J.to,$);if(J.from!=null){let Y=J.from;J.from=Promise.all([$.getAddress(),F$(Y,$)]).then(([X,z])=>{return j(X.toLowerCase()===z.toLowerCase(),"transaction from mismatch","tx.from",z),X})}else J.from=$.getAddress();return await v0(J)}class J${provider;constructor($){G0(this,{provider:$||null})}async getNonce($){return Q$(this,"getTransactionCount").getTransactionCount(await this.getAddress(),$)}async populateCall($){return await rQ(this,$)}async populateTransaction($){let Q=Q$(this,"populateTransaction"),J=await rQ(this,$);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);let Y=await this.provider.getNetwork();if(J.chainId!=null){let z=g(J.chainId);j(z===Y.chainId,"transaction chainId mismatch","tx.chainId",$.chainId)}else J.chainId=Y.chainId;let X=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||X))j(!1,"eip-1559 transaction do not support gasPrice","tx",$);else if((J.type===0||J.type===1)&&X)j(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",$);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){let z=await Q.getFeeData();if(A(z.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=z.gasPrice}else{let z=await Q.getFeeData();if(J.type==null)if(z.maxFeePerGas!=null&&z.maxPriorityFeePerGas!=null)if(J.type=2,J.gasPrice!=null){let Z=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=Z,J.maxPriorityFeePerGas=Z}else{if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}else if(z.gasPrice!=null){if(A(!X,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=z.gasPrice;J.type=0}else A(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3){if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}}return await v0(J)}async estimateGas($){return Q$(this,"estimateGas").estimateGas(await this.populateCall($))}async call($){return Q$(this,"call").call(await this.populateCall($))}async resolveName($){return await Q$(this,"resolveName").resolveName($)}async sendTransaction($){let Q=Q$(this,"sendTransaction"),J=await this.populateTransaction($);delete J.from;let Y=D0.from(J);return await Q.broadcastTransaction(await this.signTransaction(Y))}}class b$ extends J${address;constructor($,Q){super(Q);G0(this,{address:$})}async getAddress(){return this.address}connect($){return new b$(this.address,$)}#$($,Q){A(!1,`VoidSigner cannot sign ${$}`,"UNSUPPORTED_OPERATION",{operation:Q})}async signTransaction($){this.#$("transactions","signTransaction")}async signMessage($){this.#$("messages","signMessage")}async signTypedData($,Q,J){this.#$("typed-data","signTypedData")}}class f$ extends J${sdk;chain;derivationPath;address;provider;constructor({sdk:$,chain:Q,derivationPath:J,provider:Y}){super();this.sdk=$,this.chain=Q,this.derivationPath=J||Q9.ETH,this.address="",this.provider=Y}signTypedData(){throw new Error("this method is not implemented")}getAddress=async()=>{if(this.address)return this.address;let{address:$}=await this.sdk.address.ethereumGetAddress({address_n:U0(J9(this.derivationPath))});return this.address=$,$};signMessage=($)=>this.sdk.eth.ethSign({address:this.address,message:$});signTransaction=async({to:$,value:Q,gasLimit:J,nonce:Y,data:X,maxFeePerGas:z,maxPriorityFeePerGas:Z,gasPrice:G})=>{if(!$)throw new Error("Missing to address");if(!J)throw new Error("Missing gasLimit");if(!X)throw new Error("Missing data");let q=!!((z||Z)&&!G);if(q&&!z)throw new Error("Missing maxFeePerGas");if(q&&!Z)throw new Error("Missing maxFeePerGas");if(!(q||G))throw new Error("Missing gasPrice");let{toHexString:I}=await import("@swapkit/toolbox-evm"),M=Y?BigInt(Y):BigInt(await this.provider.getTransactionCount(await this.getAddress(),"pending")),D={gas:I(BigInt(J)),addressNList:[2147483692,2147483708,2147483648,0,0],from:this.address,chainId:I(BigInt($9[this.chain])),to:$.toString(),value:I(BigInt(Q||0)),nonce:I(M),data:X,...q&&{maxFeePerGas:I(BigInt(z?.toString()||"0")),maxPriorityFeePerGas:I(BigInt(Z?.toString()||"0"))},...!q&&{gasPrice:I(BigInt(G?.toString()||"0"))}};return(await this.sdk.eth.ethSignTransaction(D)).serialized};sendTransaction=async($)=>{if(!this.provider)throw new Error("No provider set");let Q=await this.signTransaction($);return await this.provider.broadcastTransaction(Q)};connect=($)=>new f$({sdk:this.sdk,chain:this.chain,derivationPath:this.derivationPath,provider:$})}import{Chain as S8,ChainId as Y9,DerivationPath as X9,derivationPathToString as z9,getRPCUrl as aQ}from"@swapkit/helpers";var sQ=async({sdk:$,derivationPath:Q})=>{let{createStargateClient:J,getToolboxByChain:Y}=await import("@swapkit/toolbox-cosmos"),X=Y(S8.Maya)(),z=Q?z9(Q):`${X9.MAYA}/0`,{address:Z}=await $.address.mayachainGetAddress({address_n:U0(z)}),G=async({assetValue:M,recipient:D,from:O,memo:w})=>{let{makeSignDoc:W}=await import("@cosmjs/amino"),{getDenomWithChain:V}=await import("@swapkit/toolbox-cosmos"),K=await X.getAccount(O);if(!K)throw new Error("Account not found");let{accountNumber:U,sequence:T=0}=K,C=M.getBaseValue("string"),R=D&&D!=="",H=R?{type:"mayachain/MsgSend",value:{amount:[{amount:C,denom:M.symbol.toLowerCase()}],from_address:O,to_address:D}}:{type:"mayachain/MsgDeposit",value:{coins:[{amount:C,asset:V(M)}],memo:w,signer:O}},S=W([H],{gas:"500000000",amount:[]},Y9.Maya,w,U?.toString(),T),E=R?await $.mayachain.mayachainSignAminoTransfer({signDoc:S,signerAddress:O}):await $.mayachain.mayachainSignAminoDeposit({signDoc:S,signerAddress:O}),y=atob(E.serialized);return new Uint8Array(y.length).map((_,F)=>y.charCodeAt(F))};return{...X,transfer:async({assetValue:M,recipient:D,memo:O})=>{let w=await J(aQ(S8.Maya)),W=await G({assetValue:M,recipient:D,memo:O,from:Z}),{transactionHash:V}=await w.broadcastTx(W);return V},deposit:async({assetValue:M,memo:D})=>{let O=await J(aQ(S8.THORChain)),w=await G({assetValue:M,memo:D,from:Z}),{transactionHash:W}=await O.broadcastTx(w);return W},address:Z}};import{Chain as y$,ChainId as Z9,DerivationPath as G9,derivationPathToString as q9,getRPCUrl as tQ}from"@swapkit/helpers";var eQ=async({sdk:$,derivationPath:Q})=>{let{makeSignDoc:J}=await import("@cosmjs/amino"),{buildAminoMsg:Y,getDefaultChainFee:X,createStargateClient:z,ThorchainToolbox:Z}=await import("@swapkit/toolbox-cosmos"),G=Z({stagenet:!1}),q=Q?q9(Q):`${G9.THOR}/0`,{address:I}=await $.address.thorchainGetAddress({address_n:U0(q)}),M=async({assetValue:w,recipient:W,from:V,memo:K})=>{let U=await G.getAccount(V);if(!U)throw new Error("Account not found");let{accountNumber:T,sequence:C=0}=U,R=W&&W!=="",H=Y({chain:y$.THORChain,from:V,recipient:W,assetValue:w,memo:K}),S=Z9.THORChain,E=J([H],X(y$.THORChain),S,K,T?.toString(),C),y=R?await $.thorchain.thorchainSignAminoTransfer({signDoc:E,signerAddress:V}):await $.thorchain.thorchainSignAminoDeposit({signDoc:E,signerAddress:V}),_=atob(y.serialized);return new Uint8Array(_.length).map((F,h)=>_.charCodeAt(h))};return{...G,transfer:async({assetValue:w,recipient:W,memo:V})=>{let K=await z(tQ(y$.THORChain)),U=await M({assetValue:w,recipient:W,memo:V,from:I}),{transactionHash:T}=await K.broadcastTx(U);return T},deposit:async({assetValue:w,memo:W})=>{let V=await z(tQ(y$.THORChain)),K=await M({assetValue:w,memo:W,from:I}),{transactionHash:U}=await V.broadcastTx(K);return U},address:I}};import{Chain as C8,DerivationPath as M9,FeeOption as I9,derivationPathToString as W9}from"@swapkit/helpers";var $J=async({sdk:$,chain:Q,derivationPath:J,apiKey:Y,apiClient:X})=>{if(!(Y||X))throw new Error("UTXO API key not found");let{getToolboxByChain:z}=await import("@swapkit/toolbox-utxo"),Z=z(Q)({apiClient:X,apiKey:Y}),G=[C8.Bitcoin,C8.Litecoin].includes(Q)?"p2wpkh":"p2pkh",q=J?W9(J):`${M9[Q]}/0`,I={coin:K$[Q],script_type:G,address_n:U0(q)},{address:M}=await $.address.utxoGetAddress(I),D=async(w,W,V="")=>{let K=w.txOutputs.map((C)=>{let{value:R,address:H,change:S}=C,E=Q===C8.BitcoinCash?Z.stripToCashAddress(H):H;if(S||H===M)return{addressNList:I.address_n,isChange:!0,addressType:"change",amount:R,scriptType:G};if(E)return{address:E,amount:R,addressType:"spend"};return null}).filter(Boolean),U=(C)=>{return C.filter((R)=>R!==null&&typeof R==="object"&&Object.keys(R).length!==0)};return(await $.utxo.utxoSignTransaction({coin:K$[Q],inputs:W,outputs:U(K),version:1,locktime:0,opReturnData:V})).serializedTx};return{...Z,signTransaction:D,transfer:async({from:w,recipient:W,feeOptionKey:V,feeRate:K,memo:U,...T})=>{if(!w)throw new Error("From address must be provided");if(!W)throw new Error("Recipient address must be provided");let{psbt:C,inputs:R}=await Z.buildTx({...T,memo:U,feeOptionKey:V,recipient:W,feeRate:K||(await Z.getFeeRates())[V||I9.Fast],sender:w,fetchTxHex:Q}),H=R.map(({value:E,index:y,hash:_,txHex:F})=>({addressNList:I.address_n,scriptType:G,amount:E.toString(),vout:y,txid:_,hex:F||""})),S=await D(C,H,U);return Z.broadcastTx(S)},address:M}};var U9=[b.Arbitrum,b.Avalanche,b.Base,b.BinanceSmartChain,b.Bitcoin,b.BitcoinCash,b.Cosmos,b.Dogecoin,b.Dash,b.Ethereum,b.Litecoin,b.Optimism,b.Polygon,b.THORChain,b.Maya],O9=async({sdk:$,apiClient:Q,rpcUrl:J,chain:Y,derivationPath:X,covalentApiKey:z,ethplorerApiKey:Z,blockchairApiKey:G})=>{let{getProvider:q,getToolboxByChain:I}=await import("@swapkit/toolbox-evm");switch(Y){case b.BinanceSmartChain:case b.Arbitrum:case b.Optimism:case b.Polygon:case b.Avalanche:case b.Ethereum:{if(Y===b.Ethereum&&!Z)throw new Error("Ethplorer API key not found");if(Y!==b.Ethereum&&!z)throw new Error("Covalent API key not found");let M=q(Y,J),D=new f$({sdk:$,chain:Y,derivationPath:X,provider:M}),O=await D.getAddress(),w={api:Q,signer:D,provider:M,covalentApiKey:z,ethplorerApiKey:Z};return{address:O,...I(Y)(w)}}case b.Cosmos:return F8({sdk:$,derivationPath:X,api:Q});case b.THORChain:return eQ({sdk:$,derivationPath:X});case b.Maya:return sQ({sdk:$,derivationPath:X});case b.Bitcoin:case b.BitcoinCash:case b.Dash:case b.Dogecoin:case b.Litecoin:return $J({apiKey:G,apiClient:Q,sdk:$,chain:Y,derivationPath:X});default:throw new Error(`Chain not supported ${Y}`)}},T9=async($="http://localhost:1646/spec/swagger.json")=>{try{return(await fetch($)).status===200}catch(Q){return console.error(Q),!1}},JJ=async($)=>{if($===0)alert("KeepKey desktop is required for keepkey-sdk, please go to https://keepkey.com/get-started");if(!await T9())window.location.assign("keepkey://launch"),await new Promise((J)=>setTimeout(J,30000)),JJ($-1)};function N9({apis:$,rpcUrls:Q,addChain:J,config:{blockchairApiKey:Y,covalentApiKey:X,ethplorerApiKey:z="freekey",keepkeyConfig:Z,thorswapApiKey:G}}){return async function q(I,M,D){if(V9({apiKey:G}),!Z)throw new Error("KeepKey config not found");let O=D9(I,U9,QJ.KEEPKEY);await JJ(3);let w=await K9.create(Z),W=O.map(async(V,K)=>{let U=Array.isArray(M)?M[K]:D?.[V],T=await O9({sdk:w,apiClient:$[V],rpcUrl:Q[V],chain:V,derivationPath:U,covalentApiKey:X,ethplorerApiKey:z,blockchairApiKey:Y});J({...T,balance:[],chain:V,walletType:QJ.KEEPKEY})});return await Promise.all(W),!0}}var NG={connectKeepkey:N9};export{NG as keepkeyWallet,T9 as checkKeepkeyAvailability,U9 as KEEPKEY_SUPPORTED_CHAINS};

//# debugId=36EAC9A119FEA17664756E2164756E21
