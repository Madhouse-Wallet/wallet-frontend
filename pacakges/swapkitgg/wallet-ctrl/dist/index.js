import{a as _,c as j}from"./chunk-nm00d52v.js";import{Chain as F,ChainToChainId as A,ChainToHexChainId as V,SwapKitError as P,WalletOption as I,filterSupportedChains as u,pickEvmApiKey as m,setRequestClientConfig as d}from"@swapkit/helpers";import{Chain as G,ChainId as h,ChainToChainId as b,EVMChains as g,SwapKitError as W,WalletOption as S,erc20ABI as v,getRPCUrl as s}from"@swapkit/helpers";function N(z){if(!window.xfi)throw new W("wallet_ctrl_not_found");switch(z){case G.Arbitrum:case G.Avalanche:case G.Base:case G.BinanceSmartChain:case G.Ethereum:case G.Optimism:case G.Polygon:return window.xfi.ethereum;case G.Cosmos:case G.Kujira:return window.xfi.keplr;case G.Bitcoin:return window.xfi.bitcoin;case G.BitcoinCash:return window.xfi.bitcoincash;case G.Dogecoin:return window.xfi.dogecoin;case G.Litecoin:return window.xfi.litecoin;case G.THORChain:return window.xfi.thorchain;case G.Maya:return window.xfi.mayachain;case G.Solana:return window.xfi.solana;default:return}}async function x({method:z,params:Y,chain:Q}){let Z=N(Q);return new Promise((X,$)=>{if(Z&&"request"in Z)Z.request({method:z,params:Y},(J,q)=>{J?$(J):X(q)})})}async function k(z){let Y=N(z);if(!Y)throw new W({errorKey:"wallet_provider_not_found",info:{wallet:S.CTRL,chain:z}});if([G.Cosmos,G.Kujira].includes(z)){let Q=N(G.Cosmos);if(!Q||"request"in Q)throw new W({errorKey:"wallet_provider_not_found",info:{wallet:S.CTRL,chain:z}});let Z=b[z];await Q.enable(Z);let X=Q.getOfflineSigner(Z),[$]=await X.getAccounts();return $?.address}if(g.includes(z)){let[Q]=await Y.request({method:"eth_requestAccounts",params:[]});return Q}if(z===G.Solana)return(await N(G.Solana).connect()).publicKey.toString();return new Promise((Q,Z)=>Y.request({method:"request_accounts",params:[]},(X,[$])=>X?Z(X):Q($)))}async function M({assetValue:z,recipient:Y,memo:Q,gasLimit:Z},X="transfer"){if(!z)throw new W("wallet_ctrl_asset_not_defined");let $=await k(z.chain),J=[{amount:{amount:z.getBaseValue("number"),decimals:z.decimal},asset:{chain:z.chain,symbol:z.symbol.toUpperCase(),ticker:z.symbol.toUpperCase()},memo:Q||"",from:$,recipient:Y,gasLimit:Z}];return x({method:X,params:J,chain:z.chain})}function T(z,Y){return async({recipient:Q,assetValue:Z,memo:X,isProgramDerivedAddress:$})=>{let J=await z.createSolanaTransaction({recipient:Q,assetValue:Z,memo:X,fromPublicKey:Y,isProgramDerivedAddress:$}),q=await window.xfi?.solana.signTransaction(J);if(!q)throw new W("core_transaction_failed");return z.broadcastTransaction(q)}}function f(z){return{call:async({contractAddress:Y,abi:Q,funcName:Z,funcParams:X=[],txOverrides:$})=>{let J=z;if(!Y)throw new W("wallet_ctrl_contract_address_not_provided");let{createContract:q,createContractTxObject:B,isStateChangingCall:R,toHexString:D}=await import("@swapkit/toolbox-evm");if(R(Q,Z)){let{value:E,from:O,to:y,data:w}=await B(J,{contractAddress:Y,abi:Q,funcName:Z,funcParams:X,txOverrides:$});return z.send("eth_sendTransaction",[{value:D(BigInt(E||0)),from:O,to:y,data:w||"0x"}])}let L=await q(Y,Q,J)[Z]?.(...X);return typeof L?.hash==="string"?L?.hash:L},approve:async({assetAddress:Y,spenderAddress:Q,amount:Z,from:X})=>{let{MAX_APPROVAL:$,createContractTxObject:J,toHexString:q}=await import("@swapkit/toolbox-evm"),B=[Q,BigInt(Z||$)],D={contractAddress:Y,abi:v,funcName:"approve",funcParams:B,txOverrides:{from:X}},{value:H,to:U,data:L}=await J(z,D);return z.send("eth_sendTransaction",[{value:q(BigInt(H||0)),from:X,to:U,data:L||"0x"}])},sendTransaction:async(Y)=>{let{from:Q,to:Z,data:X,value:$}=Y;if(!Z)throw new W("wallet_ctrl_send_transaction_no_address");let{toHexString:J}=await import("@swapkit/toolbox-evm");return z.send("eth_sendTransaction",[{value:J(BigInt($||0)),from:Q,to:Z,data:X||"0x"}])}}}var K=[F.Arbitrum,F.Avalanche,F.Base,F.BinanceSmartChain,F.Bitcoin,F.BitcoinCash,F.Cosmos,F.Dogecoin,F.Ethereum,F.Kujira,F.Litecoin,F.Maya,F.Optimism,F.Polygon,F.Solana,F.THORChain];async function p({chain:z,blockchairApiKey:Y,covalentApiKey:Q,ethplorerApiKey:Z,apis:X}){switch(z){case F.Solana:{let{SOLToolbox:$}=await import("@swapkit/toolbox-solana"),J=$(),q=await window.xfi?.solana?.connect();if(!q)throw new P("wallet_ctrl_not_found");return{...J,transfer:T(J,q.publicKey)}}case F.Maya:case F.THORChain:{let{getToolboxByChain:$,THORCHAIN_GAS_VALUE:J,MAYA_GAS_VALUE:q}=await import("@swapkit/toolbox-cosmos"),B=z===F.Maya?q:J;return{...$(z)(),deposit:(D)=>M({...D,recipient:""},"deposit"),transfer:(D)=>M({...D,gasLimit:B},"transfer")}}case F.Cosmos:case F.Kujira:{let{getToolboxByChain:$}=await import("@swapkit/toolbox-cosmos"),J=A[z];await window.xfi?.keplr?.enable(J);let q=window.xfi?.keplr?.getOfflineSignerOnlyAmino(J),B=$(z)();return{...B,transfer:(D)=>B.transfer({signer:q,...D})}}case F.Bitcoin:case F.BitcoinCash:case F.Dogecoin:case F.Litecoin:{let{getToolboxByChain:$}=await import("@swapkit/toolbox-utxo");return{...$(z)({apiKey:Y}),transfer:M}}case F.Arbitrum:case F.Avalanche:case F.Base:case F.BinanceSmartChain:case F.Ethereum:case F.Optimism:case F.Polygon:{let{prepareNetworkSwitch:$,switchEVMWalletNetwork:J}=await import("@swapkit/helpers"),{getToolboxByChain:q}=await import("@swapkit/toolbox-evm"),{BrowserProvider:B}=await import("./chunk-7r0bsnk5.js"),R=N(z);if(!R)throw new P("wallet_ctrl_not_found");let D=X?.[z],H=m({chain:z,nonEthApiKey:Q,ethApiKey:Z}),U=new B(R,"any"),L=await U.getSigner(),E=q(z)({api:D,apiKey:H,provider:U,signer:L}),O=f(U);try{z!==F.Ethereum&&await J(U,V[z],E.getNetworkParams())}catch(y){throw new P({errorKey:"wallet_failed_to_add_or_switch_network",info:{wallet:I.CTRL,chain:z}})}if(!((z===F.Ethereum?Z:Q)||D))throw new P({errorKey:"wallet_missing_api_key",info:{chain:z}});return $({provider:window.xfi?.ethereum,chainId:V[z],toolbox:{...E,...O}})}default:return null}}function C({addChain:z,apis:Y,config:{covalentApiKey:Q,ethplorerApiKey:Z,blockchairApiKey:X,thorswapApiKey:$}}){return async(J)=>{d({apiKey:$});let B=u(J,K,I.CTRL).map(async(R)=>{let D=await k(R),H=await p({chain:R,blockchairApiKey:X,covalentApiKey:Q,ethplorerApiKey:Z,apis:Y});z({...H,address:D,balance:[],chain:R,walletType:I.CTRL})});return await Promise.all(B),!0}}var l={connectCtrl:C};export{l as ctrlWallet,K as CTRL_SUPPORTED_CHAINS};

//# debugId=8486B638AD2A009664756E2164756E21
