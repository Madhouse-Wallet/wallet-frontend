var wJ=Object.create;var{getPrototypeOf:HJ,defineProperty:c$,getOwnPropertyNames:PJ}=Object;var SJ=Object.prototype.hasOwnProperty;var R0=($,Q,J)=>{J=$!=null?wJ(HJ($)):{};let Y=Q||!$||!$.__esModule?c$(J,"default",{value:$,enumerable:!0}):J;for(let X of PJ($))if(!SJ.call(Y,X))c$(Y,X,{get:()=>$[X],enumerable:!0});return Y};var EJ=($,Q)=>{for(var J in Q)c$($,J,{get:Q[J],enumerable:!0,configurable:!0,set:(Y)=>Q[J]=()=>Y})};var C0=(($)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy($,{get:(Q,J)=>(typeof require!=="undefined"?require:Q)[J]}):$)(function($){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+$+'" is not supported')});var g8="wss://relay.walletconnect.com",c8="eip155:1",h8="eip155:56",d8="eip155:43114",X$="cosmos:thorchain",u8="cosmos:cosmoshub-4",p8="cosmos:kaiyo-1",l8="cosmos:mayachain-mainnet-v1",i8="eip155:42161",n8="eip155:10",o8="eip155:137",r8="eip155:8453",a8="debug",s8={name:"THORSwap",description:"THORSwap multi-chain dex aggregator powered by THORChain",url:"https://app.thorswap.finance/",icons:["https://static.thorswap.net/logo.png"]},O$;((X)=>{X.ETH_SEND_TRANSACTION="eth_sendTransaction";X.ETH_SIGN="eth_sign";X.PERSONAL_SIGN="personal_sign";X.ETH_SIGN_TYPED_DATA="eth_signTypedData"})(O$||={});var h$;((J)=>{J.ETH_CHAIN_CHANGED="chainChanged";J.ETH_ACCOUNTS_CHANGED="accountsChanged"})(h$||={});var N$;((Y)=>{Y.COSMOS_SIGN_DIRECT="cosmos_signDirect";Y.COSMOS_SIGN_AMINO="cosmos_signAmino";Y.COSMOS_GET_ACCOUNTS="cosmos_getAccounts"})(N$||={});var LJ;(($)=>{})(LJ||={});var d$;((J)=>{J.SOL_SIGN_TRANSACTION="solana_signTransaction";J.SOL_SIGN_MESSAGE="solana_signMessage"})(d$||={});var u$;(($)=>{})(u$||={});var p$;((J)=>{J.POLKADOT_SIGN_TRANSACTION="polkadot_signTransaction";J.POLKADOT_SIGN_MESSAGE="polkadot_signMessage"})(p$||={});var l$;(($)=>{})(l$||={});var i$;((z)=>{z.NEAR_SIGN_IN="near_signIn";z.NEAR_SIGN_OUT="near_signOut";z.NEAR_GET_ACCOUNTS="near_getAccounts";z.NEAR_SIGN_AND_SEND_TRANSACTION="near_signAndSendTransaction";z.NEAR_SIGN_AND_SEND_TRANSACTIONS="near_signAndSendTransactions"})(i$||={});var n$;(($)=>{})(n$||={});import{Chain as m,ChainId as j9,SwapKitError as D$,WalletOption as b8,filterSupportedChains as R9,getRPCUrl as C9,pickEvmApiKey as w9,setRequestClientConfig as H9}from"@swapkit/helpers";import{SwapKitError as OJ,WalletOption as T9}from"@swapkit/helpers";var t8="6.13.5";function AJ($,Q,J){let Y=Q.split("|").map((z)=>z.trim());for(let z=0;z<Y.length;z++)switch(Q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===Q)return}let X=new Error(`invalid value for type ${Q}`);throw X.code="INVALID_ARGUMENT",X.argument=`value.${J}`,X.value=$,X}async function v0($){let Q=Object.keys($);return(await Promise.all(Q.map((Y)=>Promise.resolve($[Y])))).reduce((Y,X,z)=>{return Y[Q[z]]=X,Y},{})}function I0($,Q,J){for(let Y in Q){let X=Q[Y],z=J?J[Y]:null;if(z)AJ(X,z,Y);Object.defineProperty($,Y,{enumerable:!0,value:X,writable:!1})}}function n0($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(n0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let Y=0;Y<$.length;Y++)J+="0123456789abcdef"[$[Y]>>4],J+="0123456789abcdef"[$[Y]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return n0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{let Q=Object.keys($);return Q.sort(),"{ "+Q.map((J)=>`${n0(J)}: ${n0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function o$($,Q){return $&&$.code===Q}function j$($,Q,J){let Y=$;{let z=[];if(J){if("message"in J||"code"in J||"name"in J)throw new Error(`value will overwrite populated values: ${n0(J)}`);for(let Z in J){if(Z==="shortMessage")continue;let G=J[Z];z.push(Z+"="+n0(G))}}if(z.push(`code=${Q}`),z.push(`version=${t8}`),z.length)$+=" ("+z.join(", ")+")"}let X;switch(Q){case"INVALID_ARGUMENT":X=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":X=new RangeError($);break;default:X=new Error($)}if(I0(X,{code:Q}),J)Object.assign(X,J);if(X.shortMessage==null)I0(X,{shortMessage:Y});return X}function A($,Q,J,Y){if(!$)throw j$(Q,J,Y)}function U($,Q,J,Y){A($,Q,"INVALID_ARGUMENT",{argument:J,value:Y})}var f9=["NFD","NFC","NFKD","NFKC"].reduce(($,Q)=>{try{if("test".normalize(Q)!=="test")throw new Error("bad");if(Q==="NFD"){let J=String.fromCharCode(233).normalize("NFD"),Y=String.fromCharCode(101,769);if(J!==Y)throw new Error("broken")}$.push(Q)}catch(J){}return $},[]);function r$($,Q,J){if(J==null)J="";if($!==Q){let Y=J,X="new";if(J)Y+=".",X+=" "+J;A(!1,`private constructor; use ${Y}from* methods`,"UNSUPPORTED_OPERATION",{operation:X})}}function $Q($,Q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){let Y=new Uint8Array(($.length-2)/2),X=2;for(let z=0;z<Y.length;z++)Y[z]=parseInt($.substring(X,X+2),16),X+=2;return Y}U(!1,"invalid BytesLike value",Q||"value",$)}function f($,Q){return $Q($,Q,!1)}function m0($,Q){return $Q($,Q,!0)}function Y0($,Q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Q==="number"&&$.length!==2+2*Q)return!1;if(Q===!0&&$.length%2!==0)return!1;return!0}function z$($){return Y0($,!0)||$ instanceof Uint8Array}var e8="0123456789abcdef";function L($){let Q=f($),J="0x";for(let Y=0;Y<Q.length;Y++){let X=Q[Y];J+=e8[(X&240)>>4]+e8[X&15]}return J}function M0($){return"0x"+$.map((Q)=>L(Q).substring(2)).join("")}function w0($){if(Y0($,!0))return($.length-2)/2;return f($).length}function BJ($,Q,J){let Y=f($);A(Q>=Y.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(Y),length:Q,offset:Q+1});let X=new Uint8Array(Q);if(X.fill(0),J)X.set(Y,Q-Y.length);else X.set(Y,0);return L(X)}function H0($,Q){return BJ($,Q,!0)}var QQ=BigInt(0),m9=BigInt(1),o0=9007199254740991;function h($,Q){switch(typeof $){case"bigint":return $;case"number":return U(Number.isInteger($),"underflow",Q||"value",$),U($>=-o0&&$<=o0,"overflow",Q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){U(!1,`invalid BigNumberish string: ${J.message}`,Q||"value",$)}}U(!1,"invalid BigNumberish value",Q||"value",$)}function a$($,Q){let J=h($,Q);return A(J>=QQ,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function X0($,Q){switch(typeof $){case"bigint":return U($>=-o0&&$<=o0,"overflow",Q||"value",$),Number($);case"number":return U(Number.isInteger($),"underflow",Q||"value",$),U($>=-o0&&$<=o0,"overflow",Q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return X0(BigInt($),Q)}catch(J){U(!1,`invalid numeric string: ${J.message}`,Q||"value",$)}}U(!1,"invalid numeric value",Q||"value",$)}function R$($,Q){let Y=a$($,"value").toString(16);if(Q==null){if(Y.length%2)Y="0"+Y}else{let X=X0(Q,"width");A(X*2>=Y.length,`value exceeds width (${X} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(Y.length<X*2)Y="0"+Y}return"0x"+Y}function s($){let Q=a$($,"value");if(Q===QQ)return new Uint8Array([]);let J=Q.toString(16);if(J.length%2)J="0"+J;let Y=new Uint8Array(J.length/2);for(let X=0;X<Y.length;X++){let z=X*2;Y[X]=parseInt(J.substring(z,z+2),16)}return Y}function kJ($){let Q=$.toString(16);while(Q.length<2)Q="0"+Q;return"0x"+Q}function JQ($,Q,J){let Y=0;for(let X=0;X<J;X++)Y=Y*256+$[Q+X];return Y}function YQ($,Q,J,Y){let X=[];while(J<Q+1+Y){let z=XQ($,J);X.push(z.result),J+=z.consumed,A(J<=Q+1+Y,"child data too short","BUFFER_OVERRUN",{buffer:$,length:Y,offset:Q})}return{consumed:1+Y,result:X}}function XQ($,Q){A($.length!==0,"data too short","BUFFER_OVERRUN",{buffer:$,length:0,offset:1});let J=(Y)=>{A(Y<=$.length,"data short segment too short","BUFFER_OVERRUN",{buffer:$,length:$.length,offset:Y})};if($[Q]>=248){let Y=$[Q]-247;J(Q+1+Y);let X=JQ($,Q+1,Y);return J(Q+1+Y+X),YQ($,Q,Q+1+Y,Y+X)}else if($[Q]>=192){let Y=$[Q]-192;return J(Q+1+Y),YQ($,Q,Q+1,Y)}else if($[Q]>=184){let Y=$[Q]-183;J(Q+1+Y);let X=JQ($,Q+1,Y);J(Q+1+Y+X);let z=L($.slice(Q+1+Y,Q+1+Y+X));return{consumed:1+Y+X,result:z}}else if($[Q]>=128){let Y=$[Q]-128;J(Q+1+Y);let X=L($.slice(Q+1,Q+1+Y));return{consumed:1+Y,result:X}}return{consumed:1,result:kJ($[Q])}}function r0($){let Q=f($,"data"),J=XQ(Q,0);return U(J.consumed===Q.length,"unexpected junk after rlp payload","data",$),J.result}function zQ($){let Q=[];while($)Q.unshift($&255),$>>=8;return Q}function GQ($){if(Array.isArray($)){let Y=[];if($.forEach(function(z){Y=Y.concat(GQ(z))}),Y.length<=55)return Y.unshift(192+Y.length),Y;let X=zQ(Y.length);return X.unshift(247+X.length),X.concat(Y)}let Q=Array.prototype.slice.call(f($,"object"));if(Q.length===1&&Q[0]<=127)return Q;else if(Q.length<=55)return Q.unshift(128+Q.length),Q;let J=zQ(Q.length);return J.unshift(183+J.length),J.concat(Q)}var ZQ="0123456789abcdef";function P0($){let Q="0x";for(let J of GQ($))Q+=ZQ[J>>4],Q+=ZQ[J&15];return Q}function s$($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function t$($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function a0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function C$($,Q){t$($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var FJ=($)=>$ instanceof Uint8Array;var IQ=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),w$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),q0=($,Q)=>$<<32-Q|$>>>Q,_J=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!_J)throw new Error("Non little-endian hardware is not supported");function fJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function Z$($){if(typeof $==="string")$=fJ($);if(!FJ($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}class G${clone(){return this._cloneInto()}}var WX={}.toString;function s0($){let Q=(Y)=>$().update(Z$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function yJ($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),I=Y?4:0,M=Y?0:4;$.setUint32(Q+I,Z,Y),$.setUint32(Q+M,G,Y)}class I$ extends G${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=w$(this.buffer)}update($){a0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=Z$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=w$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){a0(this),C$($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let q=z;q<Y;q++)Q[q]=0;yJ(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=w$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let I=G/4,M=this.get();if(I>M.length)throw new Error("_sha2: outputLen bigger than state");for(let q=0;q<I;q++)Z.setUint32(4*q,M[q],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var bJ=($,Q,J)=>$&Q^~$&J,xJ=($,Q,J)=>$&Q^$&J^Q&J,vJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),S0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),E0=new Uint32Array(64);class MQ extends I${constructor(){super(64,32,8,!1);this.A=S0[0]|0,this.B=S0[1]|0,this.C=S0[2]|0,this.D=S0[3]|0,this.E=S0[4]|0,this.F=S0[5]|0,this.G=S0[6]|0,this.H=S0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let q=0;q<16;q++,Q+=4)E0[q]=$.getUint32(Q,!1);for(let q=16;q<64;q++){let W=E0[q-15],j=E0[q-2],R=q0(W,7)^q0(W,18)^W>>>3,K=q0(j,17)^q0(j,19)^j>>>10;E0[q]=K+E0[q-7]+R+E0[q-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:I,H:M}=this;for(let q=0;q<64;q++){let W=q0(Z,6)^q0(Z,11)^q0(Z,25),j=M+W+bJ(Z,G,I)+vJ[q]+E0[q]|0,K=(q0(J,2)^q0(J,13)^q0(J,22))+xJ(J,Y,X)|0;M=I,I=G,G=Z,Z=z+j|0,z=X,X=Y,Y=J,J=j+K|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,I=I+this.G|0,M=M+this.H|0,this.set(J,Y,X,z,Z,G,I,M)}roundClean(){E0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var qQ=s0(()=>new MQ);var H$=BigInt(4294967295),e$=BigInt(32);function KQ($,Q=!1){if(Q)return{h:Number($&H$),l:Number($>>e$&H$)};return{h:Number($>>e$&H$)|0,l:Number($&H$)|0}}function $8($,Q=!1){let J=new Uint32Array($.length),Y=new Uint32Array($.length);for(let X=0;X<$.length;X++){let{h:z,l:Z}=KQ($[X],Q);[J[X],Y[X]]=[z,Z]}return[J,Y]}var mJ=($,Q)=>BigInt($>>>0)<<e$|BigInt(Q>>>0),gJ=($,Q,J)=>$>>>J,cJ=($,Q,J)=>$<<32-J|Q>>>J,hJ=($,Q,J)=>$>>>J|Q<<32-J,dJ=($,Q,J)=>$<<32-J|Q>>>J,uJ=($,Q,J)=>$<<64-J|Q>>>J-32,pJ=($,Q,J)=>$>>>J-32|Q<<64-J,lJ=($,Q)=>Q,iJ=($,Q)=>$,Q8=($,Q,J)=>$<<J|Q>>>32-J,J8=($,Q,J)=>Q<<J|$>>>32-J,Y8=($,Q,J)=>Q<<J-32|$>>>64-J,X8=($,Q,J)=>$<<J-32|Q>>>64-J;function nJ($,Q,J,Y){let X=(Q>>>0)+(Y>>>0);return{h:$+J+(X/4294967296|0)|0,l:X|0}}var oJ=($,Q,J)=>($>>>0)+(Q>>>0)+(J>>>0),rJ=($,Q,J,Y)=>Q+J+Y+($/4294967296|0)|0,aJ=($,Q,J,Y)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0),sJ=($,Q,J,Y,X)=>Q+J+Y+X+($/4294967296|0)|0,tJ=($,Q,J,Y,X)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0)+(X>>>0),eJ=($,Q,J,Y,X,z)=>Q+J+Y+X+z+($/4294967296|0)|0;var $Y={fromBig:KQ,split:$8,toBig:mJ,shrSH:gJ,shrSL:cJ,rotrSH:hJ,rotrSL:dJ,rotrBH:uJ,rotrBL:pJ,rotr32H:lJ,rotr32L:iJ,rotlSH:Q8,rotlSL:J8,rotlBH:Y8,rotlBL:X8,add:nJ,add3L:oJ,add3H:rJ,add4L:aJ,add4H:sJ,add5H:eJ,add5L:tJ},B=$Y;var[QY,JY]=(()=>B.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(($)=>BigInt($))))(),L0=new Uint32Array(80),A0=new Uint32Array(80);class WQ extends I${constructor(){super(128,64,16,!1);this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:$,Al:Q,Bh:J,Bl:Y,Ch:X,Cl:z,Dh:Z,Dl:G,Eh:I,El:M,Fh:q,Fl:W,Gh:j,Gl:R,Hh:K,Hl:D}=this;return[$,Q,J,Y,X,z,Z,G,I,M,q,W,j,R,K,D]}set($,Q,J,Y,X,z,Z,G,I,M,q,W,j,R,K,D){this.Ah=$|0,this.Al=Q|0,this.Bh=J|0,this.Bl=Y|0,this.Ch=X|0,this.Cl=z|0,this.Dh=Z|0,this.Dl=G|0,this.Eh=I|0,this.El=M|0,this.Fh=q|0,this.Fl=W|0,this.Gh=j|0,this.Gl=R|0,this.Hh=K|0,this.Hl=D|0}process($,Q){for(let N=0;N<16;N++,Q+=4)L0[N]=$.getUint32(Q),A0[N]=$.getUint32(Q+=4);for(let N=16;N<80;N++){let E=L0[N-15]|0,H=A0[N-15]|0,w=B.rotrSH(E,H,1)^B.rotrSH(E,H,8)^B.shrSH(E,H,7),P=B.rotrSL(E,H,1)^B.rotrSL(E,H,8)^B.shrSL(E,H,7),C=L0[N-2]|0,y=A0[N-2]|0,_=B.rotrSH(C,y,19)^B.rotrBH(C,y,61)^B.shrSH(C,y,6),k=B.rotrSL(C,y,19)^B.rotrBL(C,y,61)^B.shrSL(C,y,6),u=B.add4L(P,k,A0[N-7],A0[N-16]),l=B.add4H(u,w,_,L0[N-7],L0[N-16]);L0[N]=l|0,A0[N]=u|0}let{Ah:J,Al:Y,Bh:X,Bl:z,Ch:Z,Cl:G,Dh:I,Dl:M,Eh:q,El:W,Fh:j,Fl:R,Gh:K,Gl:D,Hh:V,Hl:O}=this;for(let N=0;N<80;N++){let E=B.rotrSH(q,W,14)^B.rotrSH(q,W,18)^B.rotrBH(q,W,41),H=B.rotrSL(q,W,14)^B.rotrSL(q,W,18)^B.rotrBL(q,W,41),w=q&j^~q&K,P=W&R^~W&D,C=B.add5L(O,H,P,JY[N],A0[N]),y=B.add5H(C,V,E,w,QY[N],L0[N]),_=C|0,k=B.rotrSH(J,Y,28)^B.rotrBH(J,Y,34)^B.rotrBH(J,Y,39),u=B.rotrSL(J,Y,28)^B.rotrBL(J,Y,34)^B.rotrBL(J,Y,39),l=J&X^J&Z^X&Z,e=Y&z^Y&G^z&G;V=K|0,O=D|0,K=j|0,D=R|0,j=q|0,R=W|0,{h:q,l:W}=B.add(I|0,M|0,y|0,_|0),I=Z|0,M=G|0,Z=X|0,G=z|0,X=J|0,z=Y|0;let g=B.add3L(_,u,e);J=B.add3H(g,y,k,l),Y=g|0}({h:J,l:Y}=B.add(this.Ah|0,this.Al|0,J|0,Y|0)),{h:X,l:z}=B.add(this.Bh|0,this.Bl|0,X|0,z|0),{h:Z,l:G}=B.add(this.Ch|0,this.Cl|0,Z|0,G|0),{h:I,l:M}=B.add(this.Dh|0,this.Dl|0,I|0,M|0),{h:q,l:W}=B.add(this.Eh|0,this.El|0,q|0,W|0),{h:j,l:R}=B.add(this.Fh|0,this.Fl|0,j|0,R|0),{h:K,l:D}=B.add(this.Gh|0,this.Gl|0,K|0,D|0),{h:V,l:O}=B.add(this.Hh|0,this.Hl|0,V|0,O|0),this.set(J,Y,X,z,Z,G,I,M,q,W,j,R,K,D,V,O)}roundClean(){L0.fill(0),A0.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var VQ=s0(()=>new WQ);function YY(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw new Error("unable to locate global object")}var DQ=YY(),AX=DQ.crypto||DQ.msCrypto;function z8($){switch($){case"sha256":return qQ.create();case"sha512":return VQ.create()}U(!1,"invalid hashing algorithm name","algorithm",$)}var[OQ,NQ,jQ]=[[],[],[]],XY=BigInt(0),M$=BigInt(1),zY=BigInt(2),ZY=BigInt(7),GY=BigInt(256),IY=BigInt(113);for(let $=0,Q=M$,J=1,Y=0;$<24;$++){[J,Y]=[Y,(2*J+3*Y)%5],OQ.push(2*(5*Y+J)),NQ.push(($+1)*($+2)/2%64);let X=XY;for(let z=0;z<7;z++)if(Q=(Q<<M$^(Q>>ZY)*IY)%GY,Q&zY)X^=M$<<(M$<<BigInt(z))-M$;jQ.push(X)}var[MY,qY]=$8(jQ,!0),TQ=($,Q,J)=>J>32?Y8($,Q,J):Q8($,Q,J),UQ=($,Q,J)=>J>32?X8($,Q,J):J8($,Q,J);function KY($,Q=24){let J=new Uint32Array(10);for(let Y=24-Q;Y<24;Y++){for(let Z=0;Z<10;Z++)J[Z]=$[Z]^$[Z+10]^$[Z+20]^$[Z+30]^$[Z+40];for(let Z=0;Z<10;Z+=2){let G=(Z+8)%10,I=(Z+2)%10,M=J[I],q=J[I+1],W=TQ(M,q,1)^J[G],j=UQ(M,q,1)^J[G+1];for(let R=0;R<50;R+=10)$[Z+R]^=W,$[Z+R+1]^=j}let X=$[2],z=$[3];for(let Z=0;Z<24;Z++){let G=NQ[Z],I=TQ(X,z,G),M=UQ(X,z,G),q=OQ[Z];X=$[q],z=$[q+1],$[q]=I,$[q+1]=M}for(let Z=0;Z<50;Z+=10){for(let G=0;G<10;G++)J[G]=$[Z+G];for(let G=0;G<10;G++)$[Z+G]^=~J[(G+2)%10]&J[(G+4)%10]}$[0]^=MY[Y],$[1]^=qY[Y]}J.fill(0)}class Z8 extends G${constructor($,Q,J,Y=!1,X=24){super();if(this.blockLen=$,this.suffix=Q,this.outputLen=J,this.enableXOF=Y,this.rounds=X,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,s$(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=IQ(this.state)}keccak(){KY(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){a0(this);let{blockLen:Q,state:J}=this;$=Z$($);let Y=$.length;for(let X=0;X<Y;){let z=Math.min(Q-this.pos,Y-X);for(let Z=0;Z<z;Z++)J[this.pos++]^=$[X++];if(this.pos===Q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:$,suffix:Q,pos:J,blockLen:Y}=this;if($[J]^=Q,(Q&128)!==0&&J===Y-1)this.keccak();$[Y-1]^=128,this.keccak()}writeInto($){a0(this,!1),t$($),this.finish();let Q=this.state,{blockLen:J}=this;for(let Y=0,X=$.length;Y<X;){if(this.posOut>=J)this.keccak();let z=Math.min(J-this.posOut,X-Y);$.set(Q.subarray(this.posOut,this.posOut+z),Y),this.posOut+=z,Y+=z}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return s$($),this.xofInto(new Uint8Array($))}digestInto($){if(C$($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){let{blockLen:Q,suffix:J,outputLen:Y,rounds:X,enableXOF:z}=this;return $||($=new Z8(Q,J,Y,z,X)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=X,$.suffix=J,$.outputLen=Y,$.enableXOF=z,$.destroyed=this.destroyed,$}}var WY=($,Q,J)=>s0(()=>new Z8(Q,$,J));var RQ=WY(1,136,32);var CQ=!1,wQ=function($){return RQ($)},HQ=wQ;function z0($){let Q=f($,"data");return L(HQ(Q))}z0._=wQ;z0.lock=function(){CQ=!0};z0.register=function($){if(CQ)throw new TypeError("keccak256 is locked");HQ=$};Object.freeze(z0);var PQ=function($){return z8("sha256").update($).digest()},SQ=function($){return z8("sha512").update($).digest()},EQ=PQ,LQ=SQ,AQ=!1,BQ=!1;function B0($){let Q=f($,"data");return L(EQ(Q))}B0._=PQ;B0.lock=function(){AQ=!0};B0.register=function($){if(AQ)throw new Error("sha256 is locked");EQ=$};Object.freeze(B0);function P$($){let Q=f($,"data");return L(LQ(Q))}P$._=SQ;P$.lock=function(){BQ=!0};P$.register=function($){if(BQ)throw new Error("sha512 is locked");LQ=$};Object.freeze(B0);function kQ($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function G8($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function FQ($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");kQ($.outputLen),kQ($.blockLen)}function t0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function _Q($,Q){G8($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}var S$=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var fQ=($)=>$ instanceof Uint8Array;var E$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),K0=($,Q)=>$<<32-Q|$>>>Q,VY=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!VY)throw new Error("Non little-endian hardware is not supported");function DY($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function q$($){if(typeof $==="string")$=DY($);if(!fQ($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function yQ(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!fQ(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}class K${clone(){return this._cloneInto()}}var pX={}.toString;function bQ($){let Q=(Y)=>$().update(q$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function xQ($=32){if(S$&&typeof S$.getRandomValues==="function")return S$.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}function TY($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),I=Y?4:0,M=Y?0:4;$.setUint32(Q+I,Z,Y),$.setUint32(Q+M,G,Y)}class I8 extends K${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=E$(this.buffer)}update($){t0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=q$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=E$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){t0(this),_Q($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let q=z;q<Y;q++)Q[q]=0;TY(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=E$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let I=G/4,M=this.get();if(I>M.length)throw new Error("_sha2: outputLen bigger than state");for(let q=0;q<I;q++)Z.setUint32(4*q,M[q],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var UY=($,Q,J)=>$&Q^~$&J,OY=($,Q,J)=>$&Q^$&J^Q&J,NY=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),k0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),F0=new Uint32Array(64);class vQ extends I8{constructor(){super(64,32,8,!1);this.A=k0[0]|0,this.B=k0[1]|0,this.C=k0[2]|0,this.D=k0[3]|0,this.E=k0[4]|0,this.F=k0[5]|0,this.G=k0[6]|0,this.H=k0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let q=0;q<16;q++,Q+=4)F0[q]=$.getUint32(Q,!1);for(let q=16;q<64;q++){let W=F0[q-15],j=F0[q-2],R=K0(W,7)^K0(W,18)^W>>>3,K=K0(j,17)^K0(j,19)^j>>>10;F0[q]=K+F0[q-7]+R+F0[q-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:I,H:M}=this;for(let q=0;q<64;q++){let W=K0(Z,6)^K0(Z,11)^K0(Z,25),j=M+W+UY(Z,G,I)+NY[q]+F0[q]|0,K=(K0(J,2)^K0(J,13)^K0(J,22))+OY(J,Y,X)|0;M=I,I=G,G=Z,Z=z+j|0,z=X,X=Y,Y=J,J=j+K|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,I=I+this.G|0,M=M+this.H|0,this.set(J,Y,X,z,Z,G,I,M)}roundClean(){F0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var mQ=bQ(()=>new vQ);var W8={};EJ(W8,{validateObject:()=>f0,utf8ToBytes:()=>HY,numberToVarBytesBE:()=>CY,numberToHexUnpadded:()=>hQ,numberToBytesLE:()=>k$,numberToBytesBE:()=>_0,hexToNumber:()=>q8,hexToBytes:()=>c0,equalBytes:()=>wY,ensureBytes:()=>Q0,createHmacDrbg:()=>K8,concatBytes:()=>e0,bytesToNumberLE:()=>B$,bytesToNumberBE:()=>O0,bytesToHex:()=>g0,bitSet:()=>EY,bitMask:()=>W$,bitLen:()=>PY,bitGet:()=>SY});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var cQ=BigInt(0),L$=BigInt(1),jY=BigInt(2),A$=($)=>$ instanceof Uint8Array,RY=Array.from({length:256},($,Q)=>Q.toString(16).padStart(2,"0"));function g0($){if(!A$($))throw new Error("Uint8Array expected");let Q="";for(let J=0;J<$.length;J++)Q+=RY[$[J]];return Q}function hQ($){let Q=$.toString(16);return Q.length&1?`0${Q}`:Q}function q8($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function c0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);let Q=$.length;if(Q%2)throw new Error("padded hex string expected, got unpadded hex of length "+Q);let J=new Uint8Array(Q/2);for(let Y=0;Y<J.length;Y++){let X=Y*2,z=$.slice(X,X+2),Z=Number.parseInt(z,16);if(Number.isNaN(Z)||Z<0)throw new Error("Invalid byte sequence");J[Y]=Z}return J}function O0($){return q8(g0($))}function B$($){if(!A$($))throw new Error("Uint8Array expected");return q8(g0(Uint8Array.from($).reverse()))}function _0($,Q){return c0($.toString(16).padStart(Q*2,"0"))}function k$($,Q){return _0($,Q).reverse()}function CY($){return c0(hQ($))}function Q0($,Q,J){let Y;if(typeof Q==="string")try{Y=c0(Q)}catch(z){throw new Error(`${$} must be valid hex string, got "${Q}". Cause: ${z}`)}else if(A$(Q))Y=Uint8Array.from(Q);else throw new Error(`${$} must be hex string or Uint8Array`);let X=Y.length;if(typeof J==="number"&&X!==J)throw new Error(`${$} expected ${J} bytes, got ${X}`);return Y}function e0(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!A$(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}function wY($,Q){if($.length!==Q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Q[J])return!1;return!0}function HY($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function PY($){let Q;for(Q=0;$>cQ;$>>=L$,Q+=1);return Q}function SY($,Q){return $>>BigInt(Q)&L$}var EY=($,Q,J)=>{return $|(J?L$:cQ)<<BigInt(Q)},W$=($)=>(jY<<BigInt($-1))-L$,M8=($)=>new Uint8Array($),gQ=($)=>Uint8Array.from($);function K8($,Q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let Y=M8($),X=M8($),z=0,Z=()=>{Y.fill(1),X.fill(0),z=0},G=(...W)=>J(X,Y,...W),I=(W=M8())=>{if(X=G(gQ([0]),W),Y=G(),W.length===0)return;X=G(gQ([1]),W),Y=G()},M=()=>{if(z++>=1000)throw new Error("drbg: tried 1000 values");let W=0,j=[];while(W<Q){Y=G();let R=Y.slice();j.push(R),W+=Y.length}return e0(...j)};return(W,j)=>{Z(),I(W);let R=void 0;while(!(R=j(M())))I();return Z(),R}}var LY={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,Q)=>Q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function f0($,Q,J={}){let Y=(X,z,Z)=>{let G=LY[z];if(typeof G!=="function")throw new Error(`Invalid validator "${z}", expected function`);let I=$[X];if(Z&&I===void 0)return;if(!G(I,$))throw new Error(`Invalid param ${String(X)}=${I} (${typeof I}), expected ${z}`)};for(let[X,z]of Object.entries(Q))Y(X,z,!1);for(let[X,z]of Object.entries(J))Y(X,z,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var n=BigInt(0),d=BigInt(1),h0=BigInt(2),AY=BigInt(3),V8=BigInt(4),dQ=BigInt(5),uQ=BigInt(8),BY=BigInt(9),kY=BigInt(16);function a($,Q){let J=$%Q;return J>=n?J:Q+J}function FY($,Q,J){if(J<=n||Q<n)throw new Error("Expected power/modulo > 0");if(J===d)return n;let Y=d;while(Q>n){if(Q&d)Y=Y*$%J;$=$*$%J,Q>>=d}return Y}function J0($,Q,J){let Y=$;while(Q-- >n)Y*=Y,Y%=J;return Y}function F$($,Q){if($===n||Q<=n)throw new Error(`invert: expected positive integers, got n=${$} mod=${Q}`);let J=a($,Q),Y=Q,X=n,z=d,Z=d,G=n;while(J!==n){let M=Y/J,q=Y%J,W=X-Z*M,j=z-G*M;Y=J,J=q,X=Z,z=G,Z=W,G=j}if(Y!==d)throw new Error("invert: does not exist");return a(X,Q)}function _Y($){let Q=($-d)/h0,J,Y,X;for(J=$-d,Y=0;J%h0===n;J/=h0,Y++);for(X=h0;X<$&&FY(X,Q,$)!==$-d;X++);if(Y===1){let Z=($+d)/V8;return function G(I,M){let q=I.pow(M,Z);if(!I.eql(I.sqr(q),M))throw new Error("Cannot find square root");return q}}let z=(J+d)/h0;return function Z(G,I){if(G.pow(I,Q)===G.neg(G.ONE))throw new Error("Cannot find square root");let M=Y,q=G.pow(G.mul(G.ONE,X),J),W=G.pow(I,z),j=G.pow(I,J);while(!G.eql(j,G.ONE)){if(G.eql(j,G.ZERO))return G.ZERO;let R=1;for(let D=G.sqr(j);R<M;R++){if(G.eql(D,G.ONE))break;D=G.sqr(D)}let K=G.pow(q,d<<BigInt(M-R-1));q=G.sqr(K),W=G.mul(W,K),j=G.mul(j,q),M=R}return W}}function fY($){if($%V8===AY){let Q=($+d)/V8;return function J(Y,X){let z=Y.pow(X,Q);if(!Y.eql(Y.sqr(z),X))throw new Error("Cannot find square root");return z}}if($%uQ===dQ){let Q=($-dQ)/uQ;return function J(Y,X){let z=Y.mul(X,h0),Z=Y.pow(z,Q),G=Y.mul(X,Z),I=Y.mul(Y.mul(G,h0),Z),M=Y.mul(G,Y.sub(I,Y.ONE));if(!Y.eql(Y.sqr(M),X))throw new Error("Cannot find square root");return M}}if($%kY===BY);return _Y($)}var yY=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function D8($){let Q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=yY.reduce((Y,X)=>{return Y[X]="function",Y},Q);return f0($,J)}function bY($,Q,J){if(J<n)throw new Error("Expected power > 0");if(J===n)return $.ONE;if(J===d)return Q;let Y=$.ONE,X=Q;while(J>n){if(J&d)Y=$.mul(Y,X);X=$.sqr(X),J>>=d}return Y}function xY($,Q){let J=new Array(Q.length),Y=Q.reduce((z,Z,G)=>{if($.is0(Z))return z;return J[G]=z,$.mul(z,Z)},$.ONE),X=$.inv(Y);return Q.reduceRight((z,Z,G)=>{if($.is0(Z))return z;return J[G]=$.mul(z,J[G]),$.mul(z,Z)},X),J}function T8($,Q){let J=Q!==void 0?Q:$.toString(2).length,Y=Math.ceil(J/8);return{nBitLength:J,nByteLength:Y}}function pQ($,Q,J=!1,Y={}){if($<=n)throw new Error(`Expected Field ORDER > 0, got ${$}`);let{nBitLength:X,nByteLength:z}=T8($,Q);if(z>2048)throw new Error("Field lengths over 2048 bytes are not supported");let Z=fY($),G=Object.freeze({ORDER:$,BITS:X,BYTES:z,MASK:W$(X),ZERO:n,ONE:d,create:(I)=>a(I,$),isValid:(I)=>{if(typeof I!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof I}`);return n<=I&&I<$},is0:(I)=>I===n,isOdd:(I)=>(I&d)===d,neg:(I)=>a(-I,$),eql:(I,M)=>I===M,sqr:(I)=>a(I*I,$),add:(I,M)=>a(I+M,$),sub:(I,M)=>a(I-M,$),mul:(I,M)=>a(I*M,$),pow:(I,M)=>bY(G,I,M),div:(I,M)=>a(I*F$(M,$),$),sqrN:(I)=>I*I,addN:(I,M)=>I+M,subN:(I,M)=>I-M,mulN:(I,M)=>I*M,inv:(I)=>F$(I,$),sqrt:Y.sqrt||((I)=>Z(G,I)),invertBatch:(I)=>xY(G,I),cmov:(I,M,q)=>q?M:I,toBytes:(I)=>J?k$(I,z):_0(I,z),fromBytes:(I)=>{if(I.length!==z)throw new Error(`Fp.fromBytes: expected ${z}, got ${I.length}`);return J?B$(I):O0(I)}});return Object.freeze(G)}function lQ($){if(typeof $!=="bigint")throw new Error("field order must be bigint");let Q=$.toString(2).length;return Math.ceil(Q/8)}function U8($){let Q=lQ($);return Q+Math.ceil(Q/2)}function iQ($,Q,J=!1){let Y=$.length,X=lQ(Q),z=U8(Q);if(Y<16||Y<z||Y>1024)throw new Error(`expected ${z}-1024 bytes of input, got ${Y}`);let Z=J?O0($):B$($),G=a(Z,Q-d)+d;return J?k$(G,X):_0(G,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var mY=BigInt(0),O8=BigInt(1);function nQ($,Q){let J=(X,z)=>{let Z=z.negate();return X?Z:z},Y=(X)=>{let z=Math.ceil(Q/X)+1,Z=2**(X-1);return{windows:z,windowSize:Z}};return{constTimeNegate:J,unsafeLadder(X,z){let Z=$.ZERO,G=X;while(z>mY){if(z&O8)Z=Z.add(G);G=G.double(),z>>=O8}return Z},precomputeWindow(X,z){let{windows:Z,windowSize:G}=Y(z),I=[],M=X,q=M;for(let W=0;W<Z;W++){q=M,I.push(q);for(let j=1;j<G;j++)q=q.add(M),I.push(q);M=q.double()}return I},wNAF(X,z,Z){let{windows:G,windowSize:I}=Y(X),M=$.ZERO,q=$.BASE,W=BigInt(2**X-1),j=2**X,R=BigInt(X);for(let K=0;K<G;K++){let D=K*I,V=Number(Z&W);if(Z>>=R,V>I)V-=j,Z+=O8;let O=D,N=D+Math.abs(V)-1,E=K%2!==0,H=V<0;if(V===0)q=q.add(J(E,z[O]));else M=M.add(J(H,z[N]))}return{p:M,f:q}},wNAFCached(X,z,Z,G){let I=X._WINDOW_SIZE||1,M=z.get(X);if(!M){if(M=this.precomputeWindow(X,I),I!==1)z.set(X,G(M))}return this.wNAF(I,M,Z)}}}function N8($){return D8($.Fp),f0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...T8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function gY($){let Q=N8($);f0(Q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:J,Fp:Y,a:X}=Q;if(J){if(!Y.eql(X,Y.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Q})}var{bytesToNumberBE:cY,hexToBytes:hY}=W8,d0={Err:class $ extends Error{constructor(Q=""){super(Q)}},_parseInt($){let{Err:Q}=d0;if($.length<2||$[0]!==2)throw new Q("Invalid signature integer tag");let J=$[1],Y=$.subarray(2,J+2);if(!J||Y.length!==J)throw new Q("Invalid signature integer: wrong length");if(Y[0]&128)throw new Q("Invalid signature integer: negative");if(Y[0]===0&&!(Y[1]&128))throw new Q("Invalid signature integer: unnecessary leading zero");return{d:cY(Y),l:$.subarray(J+2)}},toSig($){let{Err:Q}=d0,J=typeof $==="string"?hY($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let Y=J.length;if(Y<2||J[0]!=48)throw new Q("Invalid signature tag");if(J[1]!==Y-2)throw new Q("Invalid signature: incorrect length");let{d:X,l:z}=d0._parseInt(J.subarray(2)),{d:Z,l:G}=d0._parseInt(z);if(G.length)throw new Q("Invalid signature: left bytes after parsing");return{r:X,s:Z}},hexFromSig($){let Q=(M)=>Number.parseInt(M[0],16)&8?"00"+M:M,J=(M)=>{let q=M.toString(16);return q.length&1?`0${q}`:q},Y=Q(J($.s)),X=Q(J($.r)),z=Y.length/2,Z=X.length/2,G=J(z),I=J(Z);return`30${J(Z+z+4)}02${I}${X}02${G}${Y}`}},N0=BigInt(0),Z0=BigInt(1),Xz=BigInt(2),oQ=BigInt(3),zz=BigInt(4);function dY($){let Q=gY($),{Fp:J}=Q,Y=Q.toBytes||((K,D,V)=>{let O=D.toAffine();return e0(Uint8Array.from([4]),J.toBytes(O.x),J.toBytes(O.y))}),X=Q.fromBytes||((K)=>{let D=K.subarray(1),V=J.fromBytes(D.subarray(0,J.BYTES)),O=J.fromBytes(D.subarray(J.BYTES,2*J.BYTES));return{x:V,y:O}});function z(K){let{a:D,b:V}=Q,O=J.sqr(K),N=J.mul(O,K);return J.add(J.add(N,J.mul(K,D)),V)}if(!J.eql(J.sqr(Q.Gy),z(Q.Gx)))throw new Error("bad generator point: equation left != right");function Z(K){return typeof K==="bigint"&&N0<K&&K<Q.n}function G(K){if(!Z(K))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function I(K){let{allowedPrivateKeyLengths:D,nByteLength:V,wrapPrivateKey:O,n:N}=Q;if(D&&typeof K!=="bigint"){if(K instanceof Uint8Array)K=g0(K);if(typeof K!=="string"||!D.includes(K.length))throw new Error("Invalid key");K=K.padStart(V*2,"0")}let E;try{E=typeof K==="bigint"?K:O0(Q0("private key",K,V))}catch(H){throw new Error(`private key must be ${V} bytes, hex or bigint, not ${typeof K}`)}if(O)E=a(E,N);return G(E),E}let M=new Map;function q(K){if(!(K instanceof W))throw new Error("ProjectivePoint expected")}class W{constructor(K,D,V){if(this.px=K,this.py=D,this.pz=V,K==null||!J.isValid(K))throw new Error("x required");if(D==null||!J.isValid(D))throw new Error("y required");if(V==null||!J.isValid(V))throw new Error("z required")}static fromAffine(K){let{x:D,y:V}=K||{};if(!K||!J.isValid(D)||!J.isValid(V))throw new Error("invalid affine point");if(K instanceof W)throw new Error("projective point not allowed");let O=(N)=>J.eql(N,J.ZERO);if(O(D)&&O(V))return W.ZERO;return new W(D,V,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(K){let D=J.invertBatch(K.map((V)=>V.pz));return K.map((V,O)=>V.toAffine(D[O])).map(W.fromAffine)}static fromHex(K){let D=W.fromAffine(X(Q0("pointHex",K)));return D.assertValidity(),D}static fromPrivateKey(K){return W.BASE.multiply(I(K))}_setWindowSize(K){this._WINDOW_SIZE=K,M.delete(this)}assertValidity(){if(this.is0()){if(Q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:K,y:D}=this.toAffine();if(!J.isValid(K)||!J.isValid(D))throw new Error("bad point: x or y not FE");let V=J.sqr(D),O=z(K);if(!J.eql(V,O))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:K}=this.toAffine();if(J.isOdd)return!J.isOdd(K);throw new Error("Field doesn't support isOdd")}equals(K){q(K);let{px:D,py:V,pz:O}=this,{px:N,py:E,pz:H}=K,w=J.eql(J.mul(D,H),J.mul(N,O)),P=J.eql(J.mul(V,H),J.mul(E,O));return w&&P}negate(){return new W(this.px,J.neg(this.py),this.pz)}double(){let{a:K,b:D}=Q,V=J.mul(D,oQ),{px:O,py:N,pz:E}=this,H=J.ZERO,w=J.ZERO,P=J.ZERO,C=J.mul(O,O),y=J.mul(N,N),_=J.mul(E,E),k=J.mul(O,N);return k=J.add(k,k),P=J.mul(O,E),P=J.add(P,P),H=J.mul(K,P),w=J.mul(V,_),w=J.add(H,w),H=J.sub(y,w),w=J.add(y,w),w=J.mul(H,w),H=J.mul(k,H),P=J.mul(V,P),_=J.mul(K,_),k=J.sub(C,_),k=J.mul(K,k),k=J.add(k,P),P=J.add(C,C),C=J.add(P,C),C=J.add(C,_),C=J.mul(C,k),w=J.add(w,C),_=J.mul(N,E),_=J.add(_,_),C=J.mul(_,k),H=J.sub(H,C),P=J.mul(_,y),P=J.add(P,P),P=J.add(P,P),new W(H,w,P)}add(K){q(K);let{px:D,py:V,pz:O}=this,{px:N,py:E,pz:H}=K,w=J.ZERO,P=J.ZERO,C=J.ZERO,y=Q.a,_=J.mul(Q.b,oQ),k=J.mul(D,N),u=J.mul(V,E),l=J.mul(O,H),e=J.add(D,V),g=J.add(N,E);e=J.mul(e,g),g=J.add(k,u),e=J.sub(e,g),g=J.add(D,O);let T=J.add(N,H);return g=J.mul(g,T),T=J.add(k,l),g=J.sub(g,T),T=J.add(V,O),w=J.add(E,H),T=J.mul(T,w),w=J.add(u,l),T=J.sub(T,w),C=J.mul(y,g),w=J.mul(_,l),C=J.add(w,C),w=J.sub(u,C),C=J.add(u,C),P=J.mul(w,C),u=J.add(k,k),u=J.add(u,k),l=J.mul(y,l),g=J.mul(_,g),u=J.add(u,l),l=J.sub(k,l),l=J.mul(y,l),g=J.add(g,l),k=J.mul(u,g),P=J.add(P,k),k=J.mul(T,g),w=J.mul(e,w),w=J.sub(w,k),k=J.mul(e,u),C=J.mul(T,C),C=J.add(C,k),new W(w,P,C)}subtract(K){return this.add(K.negate())}is0(){return this.equals(W.ZERO)}wNAF(K){return R.wNAFCached(this,M,K,(D)=>{let V=J.invertBatch(D.map((O)=>O.pz));return D.map((O,N)=>O.toAffine(V[N])).map(W.fromAffine)})}multiplyUnsafe(K){let D=W.ZERO;if(K===N0)return D;if(G(K),K===Z0)return this;let{endo:V}=Q;if(!V)return R.unsafeLadder(this,K);let{k1neg:O,k1:N,k2neg:E,k2:H}=V.splitScalar(K),w=D,P=D,C=this;while(N>N0||H>N0){if(N&Z0)w=w.add(C);if(H&Z0)P=P.add(C);C=C.double(),N>>=Z0,H>>=Z0}if(O)w=w.negate();if(E)P=P.negate();return P=new W(J.mul(P.px,V.beta),P.py,P.pz),w.add(P)}multiply(K){G(K);let D=K,V,O,{endo:N}=Q;if(N){let{k1neg:E,k1:H,k2neg:w,k2:P}=N.splitScalar(D),{p:C,f:y}=this.wNAF(H),{p:_,f:k}=this.wNAF(P);C=R.constTimeNegate(E,C),_=R.constTimeNegate(w,_),_=new W(J.mul(_.px,N.beta),_.py,_.pz),V=C.add(_),O=y.add(k)}else{let{p:E,f:H}=this.wNAF(D);V=E,O=H}return W.normalizeZ([V,O])[0]}multiplyAndAddUnsafe(K,D,V){let O=W.BASE,N=(H,w)=>w===N0||w===Z0||!H.equals(O)?H.multiplyUnsafe(w):H.multiply(w),E=N(this,D).add(N(K,V));return E.is0()?void 0:E}toAffine(K){let{px:D,py:V,pz:O}=this,N=this.is0();if(K==null)K=N?J.ONE:J.inv(O);let E=J.mul(D,K),H=J.mul(V,K),w=J.mul(O,K);if(N)return{x:J.ZERO,y:J.ZERO};if(!J.eql(w,J.ONE))throw new Error("invZ was invalid");return{x:E,y:H}}isTorsionFree(){let{h:K,isTorsionFree:D}=Q;if(K===Z0)return!0;if(D)return D(W,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:K,clearCofactor:D}=Q;if(K===Z0)return this;if(D)return D(W,this);return this.multiplyUnsafe(Q.h)}toRawBytes(K=!0){return this.assertValidity(),Y(W,this,K)}toHex(K=!0){return g0(this.toRawBytes(K))}}W.BASE=new W(Q.Gx,Q.Gy,J.ONE),W.ZERO=new W(J.ZERO,J.ONE,J.ZERO);let j=Q.nBitLength,R=nQ(W,Q.endo?Math.ceil(j/2):j);return{CURVE:Q,ProjectivePoint:W,normPrivateKeyToScalar:I,weierstrassEquation:z,isWithinCurveOrder:Z}}function uY($){let Q=N8($);return f0(Q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Q})}function rQ($){let Q=uY($),{Fp:J,n:Y}=Q,X=J.BYTES+1,z=2*J.BYTES+1;function Z(T){return N0<T&&T<J.ORDER}function G(T){return a(T,Y)}function I(T){return F$(T,Y)}let{ProjectivePoint:M,normPrivateKeyToScalar:q,weierstrassEquation:W,isWithinCurveOrder:j}=dY({...Q,toBytes(T,S,F){let b=S.toAffine(),x=J.toBytes(b.x),c=e0;if(F)return c(Uint8Array.from([S.hasEvenY()?2:3]),x);else return c(Uint8Array.from([4]),x,J.toBytes(b.y))},fromBytes(T){let S=T.length,F=T[0],b=T.subarray(1);if(S===X&&(F===2||F===3)){let x=O0(b);if(!Z(x))throw new Error("Point is not on curve");let c=W(x),$0=J.sqrt(c),t=($0&Z0)===Z0;if((F&1)===1!==t)$0=J.neg($0);return{x,y:$0}}else if(S===z&&F===4){let x=J.fromBytes(b.subarray(0,J.BYTES)),c=J.fromBytes(b.subarray(J.BYTES,2*J.BYTES));return{x,y:c}}else throw new Error(`Point of length ${S} was invalid. Expected ${X} compressed bytes or ${z} uncompressed bytes`)}}),R=(T)=>g0(_0(T,Q.nByteLength));function K(T){let S=Y>>Z0;return T>S}function D(T){return K(T)?G(-T):T}let V=(T,S,F)=>O0(T.slice(S,F));class O{constructor(T,S,F){this.r=T,this.s=S,this.recovery=F,this.assertValidity()}static fromCompact(T){let S=Q.nByteLength;return T=Q0("compactSignature",T,S*2),new O(V(T,0,S),V(T,S,2*S))}static fromDER(T){let{r:S,s:F}=d0.toSig(Q0("DER",T));return new O(S,F)}assertValidity(){if(!j(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!j(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(T){return new O(this.r,this.s,T)}recoverPublicKey(T){let{r:S,s:F,recovery:b}=this,x=C(Q0("msgHash",T));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");let c=b===2||b===3?S+Q.n:S;if(c>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");let $0=(b&1)===0?"02":"03",t=M.fromHex($0+R(c)),T0=I(c),y0=G(-x*T0),p0=G(F*T0),b0=M.BASE.multiplyAndAddUnsafe(t,y0,p0);if(!b0)throw new Error("point at infinify");return b0.assertValidity(),b0}hasHighS(){return K(this.s)}normalizeS(){return this.hasHighS()?new O(this.r,G(-this.s),this.recovery):this}toDERRawBytes(){return c0(this.toDERHex())}toDERHex(){return d0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return c0(this.toCompactHex())}toCompactHex(){return R(this.r)+R(this.s)}}let N={isValidPrivateKey(T){try{return q(T),!0}catch(S){return!1}},normPrivateKeyToScalar:q,randomPrivateKey:()=>{let T=U8(Q.n);return iQ(Q.randomBytes(T),Q.n)},precompute(T=8,S=M.BASE){return S._setWindowSize(T),S.multiply(BigInt(3)),S}};function E(T,S=!0){return M.fromPrivateKey(T).toRawBytes(S)}function H(T){let S=T instanceof Uint8Array,F=typeof T==="string",b=(S||F)&&T.length;if(S)return b===X||b===z;if(F)return b===2*X||b===2*z;if(T instanceof M)return!0;return!1}function w(T,S,F=!0){if(H(T))throw new Error("first arg must be private key");if(!H(S))throw new Error("second arg must be public key");return M.fromHex(S).multiply(q(T)).toRawBytes(F)}let P=Q.bits2int||function(T){let S=O0(T),F=T.length*8-Q.nBitLength;return F>0?S>>BigInt(F):S},C=Q.bits2int_modN||function(T){return G(P(T))},y=W$(Q.nBitLength);function _(T){if(typeof T!=="bigint")throw new Error("bigint expected");if(!(N0<=T&&T<y))throw new Error(`bigint expected < 2^${Q.nBitLength}`);return _0(T,Q.nByteLength)}function k(T,S,F=u){if(["recovered","canonical"].some((x0)=>(x0 in F)))throw new Error("sign() legacy options not supported");let{hash:b,randomBytes:x}=Q,{lowS:c,prehash:$0,extraEntropy:t}=F;if(c==null)c=!0;if(T=Q0("msgHash",T),$0)T=Q0("prehashed msgHash",b(T));let T0=C(T),y0=q(S),p0=[_(y0),_(T0)];if(t!=null){let x0=t===!0?x(J.BYTES):t;p0.push(Q0("extraEntropy",x0))}let b0=e0(...p0),T$=T0;function g$(x0){let l0=P(x0);if(!j(l0))return;let x8=I(l0),U0=M.BASE.multiply(l0).toAffine(),i0=G(U0.x);if(i0===N0)return;let U$=G(x8*G(T$+i0*y0));if(U$===N0)return;let v8=(U0.x===i0?0:2)|Number(U0.y&Z0),m8=U$;if(c&&K(U$))m8=D(U$),v8^=1;return new O(i0,m8,v8)}return{seed:b0,k2sig:g$}}let u={lowS:Q.lowS,prehash:!1},l={lowS:Q.lowS,prehash:!1};function e(T,S,F=u){let{seed:b,k2sig:x}=k(T,S,F),c=Q;return K8(c.hash.outputLen,c.nByteLength,c.hmac)(b,x)}M.BASE._setWindowSize(8);function g(T,S,F,b=l){let x=T;if(S=Q0("msgHash",S),F=Q0("publicKey",F),"strict"in b)throw new Error("options.strict was renamed to lowS");let{lowS:c,prehash:$0}=b,t=void 0,T0;try{if(typeof x==="string"||x instanceof Uint8Array)try{t=O.fromDER(x)}catch(U0){if(!(U0 instanceof d0.Err))throw U0;t=O.fromCompact(x)}else if(typeof x==="object"&&typeof x.r==="bigint"&&typeof x.s==="bigint"){let{r:U0,s:i0}=x;t=new O(U0,i0)}else throw new Error("PARSE");T0=M.fromHex(F)}catch(U0){if(U0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&t.hasHighS())return!1;if($0)S=Q.hash(S);let{r:y0,s:p0}=t,b0=C(S),T$=I(p0),g$=G(b0*T$),x0=G(y0*T$),l0=M.BASE.multiplyAndAddUnsafe(T0,g$,x0)?.toAffine();if(!l0)return!1;return G(l0.x)===y0}return{CURVE:Q,getPublicKey:E,getSharedSecret:w,sign:e,verify:g,ProjectivePoint:M,Signature:O,utils:N}}class j8 extends K${constructor($,Q){super();this.finished=!1,this.destroyed=!1,FQ($);let J=q$(Q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let Y=this.blockLen,X=new Uint8Array(Y);X.set(J.length>Y?$.create().update(J).digest():J);for(let z=0;z<X.length;z++)X[z]^=54;this.iHash.update(X),this.oHash=$.create();for(let z=0;z<X.length;z++)X[z]^=106;this.oHash.update(X),X.fill(0)}update($){return t0(this),this.iHash.update($),this}digestInto($){t0(this),G8($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){let $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));let{oHash:Q,iHash:J,finished:Y,destroyed:X,blockLen:z,outputLen:Z}=this;return $=$,$.finished=Y,$.destroyed=X,$.blockLen=z,$.outputLen=Z,$.oHash=Q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var R8=($,Q,J)=>new j8($,Q).update(J).digest();R8.create=($,Q)=>new j8($,Q);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pY($){return{hash:$,hmac:(Q,...J)=>R8($,Q,yQ(...J)),randomBytes:xQ}}function aQ($,Q){let J=(Y)=>rQ({...$,...pY(Y)});return Object.freeze({...J(Q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var eQ=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),sQ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),lY=BigInt(1),C8=BigInt(2),tQ=($,Q)=>($+Q/C8)/Q;function iY($){let Q=eQ,J=BigInt(3),Y=BigInt(6),X=BigInt(11),z=BigInt(22),Z=BigInt(23),G=BigInt(44),I=BigInt(88),M=$*$*$%Q,q=M*M*$%Q,W=J0(q,J,Q)*q%Q,j=J0(W,J,Q)*q%Q,R=J0(j,C8,Q)*M%Q,K=J0(R,X,Q)*R%Q,D=J0(K,z,Q)*K%Q,V=J0(D,G,Q)*D%Q,O=J0(V,I,Q)*V%Q,N=J0(O,G,Q)*D%Q,E=J0(N,J,Q)*q%Q,H=J0(E,Z,Q)*K%Q,w=J0(H,Y,Q)*M%Q,P=J0(w,C8,Q);if(!w8.eql(w8.sqr(P),$))throw new Error("Cannot find square root");return P}var w8=pQ(eQ,void 0,void 0,{sqrt:iY}),j0=aQ({a:BigInt(0),b:BigInt(7),Fp:w8,n:sQ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{let Q=sQ,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Y=-lY*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),z=J,Z=BigInt("0x100000000000000000000000000000000"),G=tQ(z*$,Q),I=tQ(-Y*$,Q),M=a($-G*J-I*X,Q),q=a(-G*Y-I*z,Q),W=M>Z,j=q>Z;if(W)M=Q-M;if(j)q=Q-q;if(M>Z||q>Z)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:W,k1:M,k2neg:j,k2:q}}}},mQ),Oz=BigInt(0);var Nz=j0.ProjectivePoint;var H8="0x0000000000000000000000000000000000000000";var _$="0x0000000000000000000000000000000000000000000000000000000000000000";var $J=BigInt(0),QJ=BigInt(1),JJ=BigInt(2),YJ=BigInt(27),XJ=BigInt(28),f$=BigInt(35),$$={};function zJ($){return H0(s($),32)}class i{#$;#J;#Y;#Q;get r(){return this.#$}set r($){U(w0($)===32,"invalid r","value",$),this.#$=L($)}get s(){return this.#J}set s($){U(w0($)===32,"invalid s","value",$);let Q=L($);U(parseInt(Q.substring(0,3))<8,"non-canonical s","value",Q),this.#J=Q}get v(){return this.#Y}set v($){let Q=X0($,"value");U(Q===27||Q===28,"invalid v","v",$),this.#Y=Q}get networkV(){return this.#Q}get legacyChainId(){let $=this.networkV;if($==null)return null;return i.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){let $=f(this.s);if(this.yParity)$[0]|=128;return L($)}get compactSerialized(){return M0([this.r,this.yParityAndS])}get serialized(){return M0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,Q,J,Y){r$($,$$,"Signature"),this.#$=Q,this.#J=J,this.#Y=Y,this.#Q=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){let $=new i($$,this.r,this.s,this.v);if(this.networkV)$.#Q=this.networkV;return $}toJSON(){let $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){let Q=h($,"v");if(Q==YJ||Q==XJ)return $J;return U(Q>=f$,"invalid EIP-155 v","v",$),(Q-f$)/JJ}static getChainIdV($,Q){return h($)*JJ+BigInt(35+Q-27)}static getNormalizedV($){let Q=h($);if(Q===$J||Q===YJ)return 27;if(Q===QJ||Q===XJ)return 28;return U(Q>=f$,"invalid v","v",$),Q&QJ?27:28}static from($){function Q(I,M){U(I,M,"signature",$)}if($==null)return new i($$,_$,_$,27);if(typeof $==="string"){let I=f($,"signature");if(I.length===64){let M=L(I.slice(0,32)),q=I.slice(32,64),W=q[0]&128?28:27;return q[0]&=127,new i($$,M,L(q),W)}if(I.length===65){let M=L(I.slice(0,32)),q=I.slice(32,64);Q((q[0]&128)===0,"non-canonical s");let W=i.getNormalizedV(I[64]);return new i($$,M,L(q),W)}Q(!1,"invalid raw signature length")}if($ instanceof i)return $.clone();let J=$.r;Q(J!=null,"missing r");let Y=zJ(J),X=function(I,M){if(I!=null)return zJ(I);if(M!=null){Q(Y0(M,32),"invalid yParityAndS");let q=f(M);return q[0]&=127,L(q)}Q(!1,"missing s")}($.s,$.yParityAndS);Q((f(X)[0]&128)==0,"non-canonical s");let{networkV:z,v:Z}=function(I,M,q){if(I!=null){let W=h(I);return{networkV:W>=f$?W:void 0,v:i.getNormalizedV(W)}}if(M!=null)return Q(Y0(M,32),"invalid yParityAndS"),{v:f(M)[0]&128?28:27};if(q!=null){switch(X0(q,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Q(!1,"invalid yParity")}Q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),G=new i($$,Y,X,Z);if(z)G.#Q=z;return Q($.yParity==null||X0($.yParity,"sig.yParity")===G.yParity,"yParity mismatch"),Q($.yParityAndS==null||$.yParityAndS===G.yParityAndS,"yParityAndS mismatch"),G}}class G0{#$;constructor($){U(w0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=L($)}get privateKey(){return this.#$}get publicKey(){return G0.computePublicKey(this.#$)}get compressedPublicKey(){return G0.computePublicKey(this.#$,!0)}sign($){U(w0($)===32,"invalid digest length","digest",$);let Q=j0.sign(m0($),m0(this.#$),{lowS:!0});return i.from({r:R$(Q.r,32),s:R$(Q.s,32),v:Q.recovery?28:27})}computeSharedSecret($){let Q=G0.computePublicKey($);return L(j0.getSharedSecret(m0(this.#$),f(Q),!1))}static computePublicKey($,Q){let J=f($,"key");if(J.length===32){let X=j0.getPublicKey(J,!!Q);return L(X)}if(J.length===64){let X=new Uint8Array(65);X[0]=4,X.set(J,1),J=X}let Y=j0.ProjectivePoint.fromHex(J);return L(Y.toRawBytes(Q))}static recoverPublicKey($,Q){U(w0($)===32,"invalid digest length","digest",$);let J=i.from(Q),Y=j0.Signature.fromCompact(m0(M0([J.r,J.s])));Y=Y.addRecoveryBit(J.yParity);let X=Y.recoverPublicKey(m0($));return U(X!=null,"invalid signautre for digest","signature",Q),"0x"+X.toHex(!1)}static addPoints($,Q,J){let Y=j0.ProjectivePoint.fromHex(G0.computePublicKey($).substring(2)),X=j0.ProjectivePoint.fromHex(G0.computePublicKey(Q).substring(2));return"0x"+Y.add(X).toHex(!!J)}}var nY=BigInt(0),oY=BigInt(36);function ZJ($){$=$.toLowerCase();let Q=$.substring(2).split(""),J=new Uint8Array(40);for(let X=0;X<40;X++)J[X]=Q[X].charCodeAt(0);let Y=f(z0(J));for(let X=0;X<40;X+=2){if(Y[X>>1]>>4>=8)Q[X]=Q[X].toUpperCase();if((Y[X>>1]&15)>=8)Q[X+1]=Q[X+1].toUpperCase()}return"0x"+Q.join("")}var P8={};for(let $=0;$<10;$++)P8[String($)]=String($);for(let $=0;$<26;$++)P8[String.fromCharCode(65+$)]=String(10+$);var GJ=15;function rY($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let Q=$.split("").map((Y)=>{return P8[Y]}).join("");while(Q.length>=GJ){let Y=Q.substring(0,GJ);Q=parseInt(Y,10)%97+Q.substring(Y.length)}let J=String(98-parseInt(Q,10)%97);while(J.length<2)J="0"+J;return J}var aY=function(){let $={};for(let Q=0;Q<36;Q++){let J="0123456789abcdefghijklmnopqrstuvwxyz"[Q];$[J]=BigInt(Q)}return $}();function sY($){$=$.toLowerCase();let Q=nY;for(let J=0;J<$.length;J++)Q=Q*oY+aY[$[J]];return Q}function W0($){if(U(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;let Q=ZJ($);return U(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Q===$,"bad address checksum","address",$),Q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){U($.substring(2,4)===rY($),"bad icap checksum","address",$);let Q=sY($.substring(4)).toString(16);while(Q.length<40)Q="0"+Q;return ZJ("0x"+Q)}U(!1,"invalid address","address",$)}function IJ($){return $&&typeof $.getAddress==="function"}async function S8($,Q){let J=await Q;if(J==null||J==="0x0000000000000000000000000000000000000000")A(typeof $!=="string","unconfigured name","UNCONFIGURED_NAME",{value:$}),U(!1,"invalid AddressLike value; did not resolve to a value address","target",$);return W0(J)}function y$($,Q){if(typeof $==="string"){if($.match(/^0x[0-9a-f]{40}$/i))return W0($);return A(Q!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),S8($,Q.resolveName($))}else if(IJ($))return S8($,$.getAddress());else if($&&typeof $.then==="function")return S8($,$);U(!1,"unsupported addressable value","target",$)}function E8($,Q){return{address:W0($),storageKeys:Q.map((J,Y)=>{return U(Y0(J,32),"invalid slot",`storageKeys[${Y}]`,J),J.toLowerCase()})}}function u0($){if(Array.isArray($))return $.map((J,Y)=>{if(Array.isArray(J))return U(J.length===2,"invalid slot set",`value[${Y}]`,J),E8(J[0],J[1]);return U(J!=null&&typeof J==="object","invalid address-slot set","value",$),E8(J.address,J.storageKeys)});U($!=null&&typeof $==="object","invalid access list","value",$);let Q=Object.keys($).map((J)=>{let Y=$[J].reduce((X,z)=>{return X[z]=!0,X},{});return E8(J,Object.keys(Y).sort())});return Q.sort((J,Y)=>J.address.localeCompare(Y.address)),Q}function tY($){let Q;if(typeof $==="string")Q=G0.computePublicKey($,!1);else Q=$.publicKey;return W0(z0("0x"+Q.substring(4)).substring(26))}function MJ($,Q){return tY(G0.recoverPublicKey($,Q))}var o=BigInt(0),eY=BigInt(2),$9=BigInt(27),Q9=BigInt(28),J9=BigInt(35),Y9=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),L8=131072;function qJ($,Q){let J=$.toString(16);while(J.length<2)J="0"+J;return J+=B0(Q).substring(4),"0x"+J}function b$($){if($==="0x")return null;return W0($)}function A8($,Q){try{return u0($)}catch(J){U(!1,J.message,Q,$)}}function V$($,Q){if($==="0x")return 0;return X0($,Q)}function p($,Q){if($==="0x")return o;let J=h($,Q);return U(J<=Y9,"value exceeds uint size",Q,J),J}function v($,Q){let J=h($,"value"),Y=s(J);return U(Y.length<=32,"value too large",`tx.${Q}`,J),Y}function B8($){return u0($).map((Q)=>[Q.address,Q.storageKeys])}function X9($,Q){U(Array.isArray($),`invalid ${Q}`,"value",$);for(let J=0;J<$.length;J++)U(Y0($[J],32),"invalid ${ param } hash",`value[${J}]`,$[J]);return $}function z9($){let Q=r0($);U(Array.isArray(Q)&&(Q.length===9||Q.length===6),"invalid field count for legacy transaction","data",$);let J={type:0,nonce:V$(Q[0],"nonce"),gasPrice:p(Q[1],"gasPrice"),gasLimit:p(Q[2],"gasLimit"),to:b$(Q[3]),value:p(Q[4],"value"),data:L(Q[5]),chainId:o};if(Q.length===6)return J;let Y=p(Q[6],"v"),X=p(Q[7],"r"),z=p(Q[8],"s");if(X===o&&z===o)J.chainId=Y;else{let Z=(Y-J9)/eY;if(Z<o)Z=o;J.chainId=Z,U(Z!==o||(Y===$9||Y===Q9),"non-canonical legacy v","v",Q[6]),J.signature=i.from({r:H0(Q[7],32),s:H0(Q[8],32),v:Y})}return J}function Z9($,Q){let J=[v($.nonce,"nonce"),v($.gasPrice||0,"gasPrice"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data],Y=o;if($.chainId!=o)Y=h($.chainId,"tx.chainId"),U(!Q||Q.networkV==null||Q.legacyChainId===Y,"tx.chainId/sig.v mismatch","sig",Q);else if($.signature){let z=$.signature.legacyChainId;if(z!=null)Y=z}if(!Q){if(Y!==o)J.push(s(Y)),J.push("0x"),J.push("0x");return P0(J)}let X=BigInt(27+Q.yParity);if(Y!==o)X=i.getChainIdV(Y,Q.v);else if(BigInt(Q.v)!==X)U(!1,"tx.chainId/sig.v mismatch","sig",Q);return J.push(s(X)),J.push(s(Q.r)),J.push(s(Q.s)),P0(J)}function k8($,Q){let J;try{if(J=V$(Q[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(Z){U(!1,"invalid yParity","yParity",Q[0])}let Y=H0(Q[1],32),X=H0(Q[2],32),z=i.from({r:Y,s:X,yParity:J});$.signature=z}function G9($){let Q=r0(f($).slice(1));U(Array.isArray(Q)&&(Q.length===9||Q.length===12),"invalid field count for transaction type: 2","data",L($));let J={type:2,chainId:p(Q[0],"chainId"),nonce:V$(Q[1],"nonce"),maxPriorityFeePerGas:p(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:p(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:p(Q[4],"gasLimit"),to:b$(Q[5]),value:p(Q[6],"value"),data:L(Q[7]),accessList:A8(Q[8],"accessList")};if(Q.length===9)return J;return k8(J,Q.slice(9)),J}function I9($,Q){let J=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),v($.maxFeePerGas||0,"maxFeePerGas"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data,B8($.accessList||[])];if(Q)J.push(v(Q.yParity,"yParity")),J.push(s(Q.r)),J.push(s(Q.s));return M0(["0x02",P0(J)])}function M9($){let Q=r0(f($).slice(1));U(Array.isArray(Q)&&(Q.length===8||Q.length===11),"invalid field count for transaction type: 1","data",L($));let J={type:1,chainId:p(Q[0],"chainId"),nonce:V$(Q[1],"nonce"),gasPrice:p(Q[2],"gasPrice"),gasLimit:p(Q[3],"gasLimit"),to:b$(Q[4]),value:p(Q[5],"value"),data:L(Q[6]),accessList:A8(Q[7],"accessList")};if(Q.length===8)return J;return k8(J,Q.slice(8)),J}function q9($,Q){let J=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.gasPrice||0,"gasPrice"),v($.gasLimit,"gasLimit"),$.to||"0x",v($.value,"value"),$.data,B8($.accessList||[])];if(Q)J.push(v(Q.yParity,"recoveryParam")),J.push(s(Q.r)),J.push(s(Q.s));return M0(["0x01",P0(J)])}function K9($){let Q=r0(f($).slice(1)),J="3",Y=null;if(Q.length===4&&Array.isArray(Q[0])){J="3 (network format)";let z=Q[1],Z=Q[2],G=Q[3];U(Array.isArray(z),"invalid network format: blobs not an array","fields[1]",z),U(Array.isArray(Z),"invalid network format: commitments not an array","fields[2]",Z),U(Array.isArray(G),"invalid network format: proofs not an array","fields[3]",G),U(z.length===Z.length,"invalid network format: blobs/commitments length mismatch","fields",Q),U(z.length===G.length,"invalid network format: blobs/proofs length mismatch","fields",Q),Y=[];for(let I=0;I<Q[1].length;I++)Y.push({data:z[I],commitment:Z[I],proof:G[I]});Q=Q[0]}U(Array.isArray(Q)&&(Q.length===11||Q.length===14),`invalid field count for transaction type: ${J}`,"data",L($));let X={type:3,chainId:p(Q[0],"chainId"),nonce:V$(Q[1],"nonce"),maxPriorityFeePerGas:p(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:p(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:p(Q[4],"gasLimit"),to:b$(Q[5]),value:p(Q[6],"value"),data:L(Q[7]),accessList:A8(Q[8],"accessList"),maxFeePerBlobGas:p(Q[9],"maxFeePerBlobGas"),blobVersionedHashes:Q[10]};if(Y)X.blobs=Y;U(X.to!=null,`invalid address for transaction type: ${J}`,"data",$),U(Array.isArray(X.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",$);for(let z=0;z<X.blobVersionedHashes.length;z++)U(Y0(X.blobVersionedHashes[z],32),`invalid blobVersionedHash at index ${z}: must be length 32`,"data",$);if(Q.length===11)return X;return k8(X,Q.slice(11)),X}function W9($,Q,J){let Y=[v($.chainId,"chainId"),v($.nonce,"nonce"),v($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),v($.maxFeePerGas||0,"maxFeePerGas"),v($.gasLimit,"gasLimit"),$.to||H8,v($.value,"value"),$.data,B8($.accessList||[]),v($.maxFeePerBlobGas||0,"maxFeePerBlobGas"),X9($.blobVersionedHashes||[],"blobVersionedHashes")];if(Q){if(Y.push(v(Q.yParity,"yParity")),Y.push(s(Q.r)),Y.push(s(Q.s)),J)return M0(["0x03",P0([Y,J.map((X)=>X.data),J.map((X)=>X.commitment),J.map((X)=>X.proof)])])}return M0(["0x03",P0(Y)])}class V0{#$;#J;#Y;#Q;#I;#M;#q;#K;#W;#V;#D;#T;#G;#z;#X;#Z;get type(){return this.#$}set type($){switch($){case null:this.#$=null;break;case 0:case"legacy":this.#$=0;break;case 1:case"berlin":case"eip-2930":this.#$=1;break;case 2:case"london":case"eip-1559":this.#$=2;break;case 3:case"cancun":case"eip-4844":this.#$=3;break;default:U(!1,"unsupported transaction type","type",$)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844"}return null}get to(){let $=this.#J;if($==null&&this.type===3)return H8;return $}set to($){this.#J=$==null?null:W0($)}get nonce(){return this.#Q}set nonce($){this.#Q=X0($,"value")}get gasLimit(){return this.#I}set gasLimit($){this.#I=h($)}get gasPrice(){let $=this.#M;if($==null&&(this.type===0||this.type===1))return o;return $}set gasPrice($){this.#M=$==null?null:h($,"gasPrice")}get maxPriorityFeePerGas(){let $=this.#q;if($==null){if(this.type===2||this.type===3)return o;return null}return $}set maxPriorityFeePerGas($){this.#q=$==null?null:h($,"maxPriorityFeePerGas")}get maxFeePerGas(){let $=this.#K;if($==null){if(this.type===2||this.type===3)return o;return null}return $}set maxFeePerGas($){this.#K=$==null?null:h($,"maxFeePerGas")}get data(){return this.#Y}set data($){this.#Y=L($)}get value(){return this.#W}set value($){this.#W=h($,"value")}get chainId(){return this.#V}set chainId($){this.#V=h($)}get signature(){return this.#D||null}set signature($){this.#D=$==null?null:i.from($)}get accessList(){let $=this.#T||null;if($==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return $}set accessList($){this.#T=$==null?null:u0($)}get maxFeePerBlobGas(){let $=this.#G;if($==null&&this.type===3)return o;return $}set maxFeePerBlobGas($){this.#G=$==null?null:h($,"maxFeePerBlobGas")}get blobVersionedHashes(){let $=this.#z;if($==null&&this.type===3)return[];return $}set blobVersionedHashes($){if($!=null){U(Array.isArray($),"blobVersionedHashes must be an Array","value",$),$=$.slice();for(let Q=0;Q<$.length;Q++)U(Y0($[Q],32),"invalid blobVersionedHash",`value[${Q}]`,$[Q])}this.#z=$}get blobs(){if(this.#Z==null)return null;return this.#Z.map(($)=>Object.assign({},$))}set blobs($){if($==null){this.#Z=null;return}let Q=[],J=[];for(let Y=0;Y<$.length;Y++){let X=$[Y];if(z$(X)){A(this.#X,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let z=f(X);if(U(z.length<=L8,"blob is too large",`blobs[${Y}]`,X),z.length!==L8){let I=new Uint8Array(L8);I.set(z),z=I}let Z=this.#X.blobToKzgCommitment(z),G=L(this.#X.computeBlobKzgProof(z,Z));Q.push({data:L(z),commitment:L(Z),proof:G}),J.push(qJ(1,Z))}else{let z=L(X.commitment);Q.push({data:L(X.data),commitment:z,proof:L(X.proof)}),J.push(qJ(1,z))}}this.#Z=Q,this.#z=J}get kzg(){return this.#X}set kzg($){this.#X=$}constructor(){this.#$=null,this.#J=null,this.#Q=0,this.#I=o,this.#M=null,this.#q=null,this.#K=null,this.#Y="0x",this.#W=o,this.#V=o,this.#D=null,this.#T=null,this.#G=null,this.#z=null,this.#Z=null,this.#X=null}get hash(){if(this.signature==null)return null;return z0(this.#U(!0,!1))}get unsignedHash(){return z0(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return MJ(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return G0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#U($,Q){A(!$||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});let J=$?this.signature:null;switch(this.inferType()){case 0:return Z9(this,J);case 1:return q9(this,J);case 2:return I9(this,J);case 3:return W9(this,J,Q?this.blobs:null)}A(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#U(!0,!0)}get unsignedSerialized(){return this.#U(!1,!1)}inferType(){let $=this.inferTypes();if($.indexOf(2)>=0)return 2;return $.pop()}inferTypes(){let $=this.gasPrice!=null,Q=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,Y=this.#G!=null||this.#z;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)A(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});A(!Q||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),A(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});let X=[];if(this.type!=null)X.push(this.type);else if(Q)X.push(2);else if($){if(X.push(1),!J)X.push(0)}else if(J)X.push(1),X.push(2);else if(Y&&this.to)X.push(3);else X.push(0),X.push(1),X.push(2),X.push(3);return X.sort(),X}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return V0.from(this)}toJSON(){let $=(Q)=>{if(Q==null)return null;return Q.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:$(this.gasLimit),gasPrice:$(this.gasPrice),maxPriorityFeePerGas:$(this.maxPriorityFeePerGas),maxFeePerGas:$(this.maxFeePerGas),value:$(this.value),chainId:$(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from($){if($==null)return new V0;if(typeof $==="string"){let J=f($);if(J[0]>=127)return V0.from(z9(J));switch(J[0]){case 1:return V0.from(M9(J));case 2:return V0.from(G9(J));case 3:return V0.from(K9(J))}A(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}let Q=new V0;if($.type!=null)Q.type=$.type;if($.to!=null)Q.to=$.to;if($.nonce!=null)Q.nonce=$.nonce;if($.gasLimit!=null)Q.gasLimit=$.gasLimit;if($.gasPrice!=null)Q.gasPrice=$.gasPrice;if($.maxPriorityFeePerGas!=null)Q.maxPriorityFeePerGas=$.maxPriorityFeePerGas;if($.maxFeePerGas!=null)Q.maxFeePerGas=$.maxFeePerGas;if($.maxFeePerBlobGas!=null)Q.maxFeePerBlobGas=$.maxFeePerBlobGas;if($.data!=null)Q.data=$.data;if($.value!=null)Q.value=$.value;if($.chainId!=null)Q.chainId=$.chainId;if($.signature!=null)Q.signature=i.from($.signature);if($.accessList!=null)Q.accessList=$.accessList;if($.blobVersionedHashes!=null)Q.blobVersionedHashes=$.blobVersionedHashes;if($.kzg!=null)Q.kzg=$.kzg;if($.blobs!=null)Q.blobs=$.blobs;if($.hash!=null)U(Q.isSigned(),"unsigned transaction cannot define '.hash'","tx",$),U(Q.hash===$.hash,"hash mismatch","tx",$);if($.from!=null)U(Q.isSigned(),"unsigned transaction cannot define '.from'","tx",$),U(Q.from.toLowerCase()===($.from||"").toLowerCase(),"from mismatch","tx",$);return Q}}var KJ=BigInt(0);function F8($){if($==null)return null;return $}function r($){if($==null)return null;return $.toString()}function _8($){let Q={};if($.to)Q.to=$.to;if($.from)Q.from=$.from;if($.data)Q.data=L($.data);let J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let X of J){if(!(X in $)||$[X]==null)continue;Q[X]=h($[X],`request.${X}`)}let Y="type,nonce".split(/,/);for(let X of Y){if(!(X in $)||$[X]==null)continue;Q[X]=X0($[X],`request.${X}`)}if($.accessList)Q.accessList=u0($.accessList);if("blockTag"in $)Q.blockTag=$.blockTag;if("enableCcipRead"in $)Q.enableCcipRead=!!$.enableCcipRead;if("customData"in $)Q.customData=$.customData;if("blobVersionedHashes"in $&&$.blobVersionedHashes)Q.blobVersionedHashes=$.blobVersionedHashes.slice();if("kzg"in $)Q.kzg=$.kzg;if("blobs"in $&&$.blobs)Q.blobs=$.blobs.map((X)=>{if(z$(X))return L(X);return Object.assign({},X)});return Q}class WJ{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#$;constructor($,Q){this.#$=$.transactions.map((J)=>{if(typeof J!=="string")return new x$(J,Q);return J}),I0(this,{provider:Q,hash:F8($.hash),number:$.number,timestamp:$.timestamp,parentHash:$.parentHash,parentBeaconBlockRoot:$.parentBeaconBlockRoot,nonce:$.nonce,difficulty:$.difficulty,gasLimit:$.gasLimit,gasUsed:$.gasUsed,blobGasUsed:$.blobGasUsed,excessBlobGas:$.excessBlobGas,miner:$.miner,prevRandao:F8($.prevRandao),extraData:$.extraData,baseFeePerGas:F8($.baseFeePerGas),stateRoot:$.stateRoot,receiptsRoot:$.receiptsRoot})}get transactions(){return this.#$.map(($)=>{if(typeof $==="string")return $;return $.hash})}get prefetchedTransactions(){let $=this.#$.slice();if($.length===0)return[];return A(typeof $[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),$}toJSON(){let{baseFeePerGas:$,difficulty:Q,extraData:J,gasLimit:Y,gasUsed:X,hash:z,miner:Z,prevRandao:G,nonce:I,number:M,parentHash:q,parentBeaconBlockRoot:W,stateRoot:j,receiptsRoot:R,timestamp:K,transactions:D}=this;return{_type:"Block",baseFeePerGas:r($),difficulty:r(Q),extraData:J,gasLimit:r(Y),gasUsed:r(X),blobGasUsed:r(this.blobGasUsed),excessBlobGas:r(this.excessBlobGas),hash:z,miner:Z,prevRandao:G,nonce:I,number:M,parentHash:q,timestamp:K,parentBeaconBlockRoot:W,stateRoot:j,receiptsRoot:R,transactions:D}}[Symbol.iterator](){let $=0,Q=this.transactions;return{next:()=>{if($<this.length)return{value:Q[$++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#$.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction($){let Q=void 0;if(typeof $==="number")Q=this.#$[$];else{let J=$.toLowerCase();for(let Y of this.#$)if(typeof Y==="string"){if(Y!==J)continue;Q=Y;break}else{if(Y.hash!==J)continue;Q=Y;break}}if(Q==null)throw new Error("no such tx");if(typeof Q==="string")return await this.provider.getTransaction(Q);else return Q}getPrefetchedTransaction($){let Q=this.prefetchedTransactions;if(typeof $==="number")return Q[$];$=$.toLowerCase();for(let J of Q)if(J.hash===$)return J;U(!1,"no matching transaction","indexOrHash",$)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return V9(this)}}class f8{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor($,Q){this.provider=Q;let J=Object.freeze($.topics.slice());I0(this,{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,removed:$.removed,address:$.address,data:$.data,topics:J,index:$.index,transactionIndex:$.transactionIndex})}toJSON(){let{address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:I}=this;return{_type:"log",address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:I}}async getBlock(){let $=await this.provider.getBlock(this.blockHash);return A(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransaction(){let $=await this.provider.getTransaction(this.transactionHash);return A(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransactionReceipt(){let $=await this.provider.getTransactionReceipt(this.transactionHash);return A(!!$,"failed to find transaction receipt","UNKNOWN_ERROR",{}),$}removedEvent(){return D9(this)}}class VJ{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#$;constructor($,Q){this.#$=Object.freeze($.logs.map((Y)=>{return new f8(Y,Q)}));let J=KJ;if($.effectiveGasPrice!=null)J=$.effectiveGasPrice;else if($.gasPrice!=null)J=$.gasPrice;I0(this,{provider:Q,to:$.to,from:$.from,contractAddress:$.contractAddress,hash:$.hash,index:$.index,blockHash:$.blockHash,blockNumber:$.blockNumber,logsBloom:$.logsBloom,gasUsed:$.gasUsed,cumulativeGasUsed:$.cumulativeGasUsed,blobGasUsed:$.blobGasUsed,gasPrice:J,blobGasPrice:$.blobGasPrice,type:$.type,status:$.status,root:$.root})}get logs(){return this.#$}toJSON(){let{to:$,from:Q,contractAddress:J,hash:Y,index:X,blockHash:z,blockNumber:Z,logsBloom:G,logs:I,status:M,root:q}=this;return{_type:"TransactionReceipt",blockHash:z,blockNumber:Z,contractAddress:J,cumulativeGasUsed:r(this.cumulativeGasUsed),from:Q,gasPrice:r(this.gasPrice),blobGasUsed:r(this.blobGasUsed),blobGasPrice:r(this.blobGasPrice),gasUsed:r(this.gasUsed),hash:Y,index:X,logs:I,logsBloom:G,root:q,status:M,to:$}}get length(){return this.logs.length}[Symbol.iterator](){let $=0;return{next:()=>{if($<this.length)return{value:this.logs[$++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){let $=await this.provider.getBlock(this.blockHash);if($==null)throw new Error("TODO");return $}async getTransaction(){let $=await this.provider.getTransaction(this.hash);if($==null)throw new Error("TODO");return $}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return TJ(this)}reorderedEvent($){return A(!$||$.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),DJ(this,$)}}class x${provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;#$;constructor($,Q){this.provider=Q,this.blockNumber=$.blockNumber!=null?$.blockNumber:null,this.blockHash=$.blockHash!=null?$.blockHash:null,this.hash=$.hash,this.index=$.index,this.type=$.type,this.from=$.from,this.to=$.to||null,this.gasLimit=$.gasLimit,this.nonce=$.nonce,this.data=$.data,this.value=$.value,this.gasPrice=$.gasPrice,this.maxPriorityFeePerGas=$.maxPriorityFeePerGas!=null?$.maxPriorityFeePerGas:null,this.maxFeePerGas=$.maxFeePerGas!=null?$.maxFeePerGas:null,this.maxFeePerBlobGas=$.maxFeePerBlobGas!=null?$.maxFeePerBlobGas:null,this.chainId=$.chainId,this.signature=$.signature,this.accessList=$.accessList!=null?$.accessList:null,this.blobVersionedHashes=$.blobVersionedHashes!=null?$.blobVersionedHashes:null,this.#$=-1}toJSON(){let{blockNumber:$,blockHash:Q,index:J,hash:Y,type:X,to:z,from:Z,nonce:G,data:I,signature:M,accessList:q,blobVersionedHashes:W}=this;return{_type:"TransactionResponse",accessList:q,blockNumber:$,blockHash:Q,blobVersionedHashes:W,chainId:r(this.chainId),data:I,from:Z,gasLimit:r(this.gasLimit),gasPrice:r(this.gasPrice),hash:Y,maxFeePerGas:r(this.maxFeePerGas),maxPriorityFeePerGas:r(this.maxPriorityFeePerGas),maxFeePerBlobGas:r(this.maxFeePerBlobGas),nonce:G,signature:M,to:z,index:J,type:X,value:r(this.value)}}async getBlock(){let $=this.blockNumber;if($==null){let J=await this.getTransaction();if(J)$=J.blockNumber}if($==null)return null;let Q=this.provider.getBlock($);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){let{tx:Q,blockNumber:J}=await v0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Q==null||Q.blockNumber==null)return 0;return J-Q.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait($,Q){let J=$==null?1:$,Y=Q==null?0:Q,X=this.#$,z=-1,Z=X===-1?!0:!1,G=async()=>{if(Z)return null;let{blockNumber:W,nonce:j}=await v0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(j<this.nonce){X=W;return}if(Z)return null;let R=await this.getTransaction();if(R&&R.blockNumber!=null)return;if(z===-1){if(z=X-3,z<this.#$)z=this.#$}while(z<=W){if(Z)return null;let K=await this.provider.getBlock(z,!0);if(K==null)return;for(let D of K)if(D===this.hash)return;for(let D=0;D<K.length;D++){let V=await K.getTransaction(D);if(V.from===this.from&&V.nonce===this.nonce){if(Z)return null;let O=await this.provider.getTransactionReceipt(V.hash);if(O==null)return;if(W-O.blockNumber+1<J)return;let N="replaced";if(V.data===this.data&&V.to===this.to&&V.value===this.value)N="repriced";else if(V.data==="0x"&&V.from===V.to&&V.value===KJ)N="cancelled";A(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:N==="replaced"||N==="cancelled",reason:N,replacement:V.replaceableTransaction(X),hash:V.hash,receipt:O})}}z++}return},I=(W)=>{if(W==null||W.status!==0)return W;A(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:W.to,from:W.from,data:""},receipt:W})},M=await this.provider.getTransactionReceipt(this.hash);if(J===0)return I(M);if(M){if(await M.confirmations()>=J)return I(M)}else if(await G(),J===0)return null;return await new Promise((W,j)=>{let R=[],K=()=>{R.forEach((V)=>V())};if(R.push(()=>{Z=!0}),Y>0){let V=setTimeout(()=>{K(),j(j$("wait for transaction timeout","TIMEOUT"))},Y);R.push(()=>{clearTimeout(V)})}let D=async(V)=>{if(await V.confirmations()>=J){K();try{W(I(V))}catch(O){j(O)}}};if(R.push(()=>{this.provider.off(this.hash,D)}),this.provider.on(this.hash,D),X>=0){let V=async()=>{try{await G()}catch(O){if(o$(O,"TRANSACTION_REPLACED")){K(),j(O);return}}if(!Z)this.provider.once("block",V)};R.push(()=>{this.provider.off("block",V)}),this.provider.once("block",V)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return A(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),TJ(this)}reorderedEvent($){return A(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),A(!$||$.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),DJ(this,$)}replaceableTransaction($){U(Number.isInteger($)&&$>=0,"invalid startBlock","startBlock",$);let Q=new x$(this,this.provider);return Q.#$=$,Q}}function V9($){return{orphan:"drop-block",hash:$.hash,number:$.number}}function DJ($,Q){return{orphan:"reorder-transaction",tx:$,other:Q}}function TJ($){return{orphan:"drop-transaction",tx:$}}function D9($){return{orphan:"drop-log",log:{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,address:$.address,data:$.data,topics:Object.freeze($.topics.slice()),index:$.index}}}function Q$($,Q){if($.provider)return $.provider;A(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Q})}async function UJ($,Q){let J=_8(Q);if(J.to!=null)J.to=y$(J.to,$);if(J.from!=null){let Y=J.from;J.from=Promise.all([$.getAddress(),y$(Y,$)]).then(([X,z])=>{return U(X.toLowerCase()===z.toLowerCase(),"transaction from mismatch","tx.from",z),X})}else J.from=$.getAddress();return await v0(J)}class J${provider;constructor($){I0(this,{provider:$||null})}async getNonce($){return Q$(this,"getTransactionCount").getTransactionCount(await this.getAddress(),$)}async populateCall($){return await UJ(this,$)}async populateTransaction($){let Q=Q$(this,"populateTransaction"),J=await UJ(this,$);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);let Y=await this.provider.getNetwork();if(J.chainId!=null){let z=h(J.chainId);U(z===Y.chainId,"transaction chainId mismatch","tx.chainId",$.chainId)}else J.chainId=Y.chainId;let X=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||X))U(!1,"eip-1559 transaction do not support gasPrice","tx",$);else if((J.type===0||J.type===1)&&X)U(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",$);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){let z=await Q.getFeeData();if(A(z.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=z.gasPrice}else{let z=await Q.getFeeData();if(J.type==null)if(z.maxFeePerGas!=null&&z.maxPriorityFeePerGas!=null)if(J.type=2,J.gasPrice!=null){let Z=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=Z,J.maxPriorityFeePerGas=Z}else{if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}else if(z.gasPrice!=null){if(A(!X,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=z.gasPrice;J.type=0}else A(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3){if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}}return await v0(J)}async estimateGas($){return Q$(this,"estimateGas").estimateGas(await this.populateCall($))}async call($){return Q$(this,"call").call(await this.populateCall($))}async resolveName($){return await Q$(this,"resolveName").resolveName($)}async sendTransaction($){let Q=Q$(this,"sendTransaction"),J=await this.populateTransaction($);delete J.from;let Y=V0.from(J);return await Q.broadcastTransaction(await this.signTransaction(Y))}}class v$ extends J${address;constructor($,Q){super(Q);I0(this,{address:$})}async getAddress(){return this.address}connect($){return new v$(this.address,$)}#$($,Q){A(!1,`VoidSigner cannot sign ${$}`,"UNSUPPORTED_OPERATION",{operation:Q})}async signTransaction($){this.#$("transactions","signTransaction")}async signMessage($){this.#$("messages","signMessage")}async signTypedData($,Q,J){this.#$("typed-data","signTypedData")}}import{Chain as D0}from"@swapkit/helpers";var m$=($,Q)=>{return(Q.find((X)=>X.startsWith(Y$($)))||"")?.split(":")?.[2]||""},Y$=($)=>{switch($){case D0.Avalanche:return d8;case D0.Base:return r8;case D0.BinanceSmartChain:return h8;case D0.Ethereum:return c8;case D0.THORChain:return X$;case D0.Arbitrum:return i8;case D0.Optimism:return n8;case D0.Polygon:return o8;case D0.Maya:return l8;case D0.Cosmos:return u8;case D0.Kujira:return p8;default:return""}};class y8 extends J${address;chain;walletconnect;provider;constructor({chain:$,provider:Q,walletconnect:J}){super(Q);this.chain=$,this.walletconnect=J,this.provider=Q,this.address=""}getAddress=async()=>{if(!this.walletconnect)throw new OJ("wallet_walletconnect_connection_not_established");if(!this.address)this.address=m$(this.chain,this.walletconnect.accounts);return this.address};signMessage=async($)=>{let Q=await this.walletconnect?.client.request({chainId:Y$(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sign",params:[$]}});return Q.startsWith("0x")?Q:`0x${Q}`};signTransaction=()=>{throw new Error("Not implemented: signTransaction")};signTypedData=()=>{throw new Error("Not implemented: signTypedData")};sendTransaction=async({from:$,to:Q,value:J,data:Y})=>{let{toHexString:X}=await import("@swapkit/toolbox-evm"),z={from:$,to:Q,value:X(BigInt(J||0)),data:Y};return await this.walletconnect?.client.request({chainId:Y$(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sendTransaction",params:[z]}})};connect=($)=>{if(!$)throw new OJ({errorKey:"wallet_provider_not_found",info:{wallet:T9.WALLETCONNECT,chain:this.chain}});return new y8({chain:this.chain,walletconnect:this.walletconnect,provider:$})}}var NJ=async({chain:$,walletconnect:Q,provider:J})=>new y8({chain:$,walletconnect:Q,provider:J});import{SwapKitError as jJ}from"@swapkit/helpers";var U9=($)=>{let Q=[];for(let J of $){let[Y]=J.split(":");if(Y&&!Q.includes(Y))Q.push(Y)}return Q},O9=($)=>{switch($){case"eip155":return Object.values(O$);case"cosmos":return Object.values(N$);case"solana":return Object.values(d$);case"polkadot":return Object.values(p$);case"near":return Object.values(i$);default:throw new jJ({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:$}})}},N9=($)=>{switch($){case"eip155":return Object.values(h$);case"cosmos":return[];case"solana":return Object.values(u$);case"polkadot":return Object.values(l$);case"near":return Object.values(n$);default:throw new jJ({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:$}})}},RJ=($)=>{let Q=U9($);return Object.fromEntries(Q.map((J)=>[J,{methods:O9(J),chains:$.filter((Y)=>Y.startsWith(J)),events:N9(J)}]))};var CJ=[m.Arbitrum,m.Avalanche,m.Base,m.BinanceSmartChain,m.Cosmos,m.Ethereum,m.Kujira,m.Maya,m.Optimism,m.Polygon,m.THORChain];async function P9({apis:$,chain:Q,walletconnect:J,address:Y,session:X,ethplorerApiKey:z,covalentApiKey:Z}){switch(Q){case m.Arbitrum:case m.Avalanche:case m.Base:case m.BinanceSmartChain:case m.Ethereum:case m.Optimism:case m.Polygon:{let{getProvider:G,getToolboxByChain:I}=await import("@swapkit/toolbox-evm"),M=$?.[Q],q=w9({chain:Q,ethApiKey:z,nonEthApiKey:Z}),W=G(Q),j=await NJ({walletconnect:J,chain:Q,provider:W});return I(Q)({api:M,apiKey:q,provider:W,signer:j})}case m.THORChain:{let{SignMode:G}=await import("cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"),{TxRaw:I}=await import("cosmjs-types/cosmos/tx/v1beta1/tx.js"),{encodePubkey:M,makeAuthInfoBytes:q}=await import("@cosmjs/proto-signing"),{makeSignDoc:W}=await import("@cosmjs/amino"),{ThorchainToolbox:j,buildAminoMsg:R,buildEncodedTxBody:K,createStargateClient:D,fromBase64:V,getDefaultChainFee:O,parseAminoMessageForDirectSigning:N}=await import("@swapkit/toolbox-cosmos"),E=j({stagenet:!1}),H=O(Q),w=(C)=>J?.client.request({chainId:X$,topic:X.topic,request:{method:"cosmos_signAmino",params:{signerAddress:Y,signDoc:C}}});async function P({assetValue:C,memo:y,..._}){let k=await E.getAccount(Y);if(!k)throw new D$({errorKey:"wallet_missing_params",info:{account:k}});if(!k.pubkey)throw new D$({errorKey:"wallet_missing_params",info:{account:k,pubkey:k?.pubkey}});let{accountNumber:u,sequence:l=0}=k,e=[R({chain:m.THORChain,assetValue:C,memo:y,from:Y,..._})],g=j9.THORChain,T=W(e,H,g,y,u?.toString(),l?.toString()||"0"),S=await w(T),F=K({chain:m.THORChain,msgs:e.map(N),memo:y||""}),b=M(k.pubkey),x=q([{pubkey:b,sequence:l}],H.amount,Number.parseInt(H.gas),void 0,void 0,G.SIGN_MODE_LEGACY_AMINO_JSON),c=I.fromPartial({bodyBytes:F,authInfoBytes:x,signatures:[V(typeof S.signature==="string"?S.signature:S.signature.signature)]}),$0=I.encode(c).finish();return(await(await D(C9(m.THORChain))).broadcastTx($0)).transactionHash}return{...E,transfer:(C)=>P(C),deposit:(C)=>P(C)}}default:throw new D$({errorKey:"wallet_chain_not_supported",info:{chain:Q,wallet:b8.WALLETCONNECT}})}}async function S9($,Q,J){let Y;try{if(!Q)throw new D$("wallet_walletconnect_project_id_not_specified");let X=RJ($.map(Y$)),{WalletConnectModalSign:z}=await import("@walletconnect/modal-sign-html"),Z=new z({logger:a8,relayUrl:g8,projectId:Q,metadata:J?.metadata||s8,...J?.core}),G=await Z.getSession();if(G)await Z.disconnect({topic:G.topic,reason:{code:0,message:"Resetting session"}});let I=await Z.connect({requiredNamespaces:X}),M=Object.values(I.namespaces).flatMap((W)=>W.accounts);return{session:I,accounts:M,client:Z,disconnect:async()=>{await Z.disconnect({topic:I.topic,reason:{code:0,message:"User disconnected"}})}}}catch(X){console.error(X)}finally{if(Y)Y.closeModal()}return}function E9({addChain:$,apis:Q,config:{thorswapApiKey:J,ethplorerApiKey:Y,walletConnectProjectId:X,covalentApiKey:z,stagenet:Z=!1}}){return async function G(I,M){let q=R9(I,CJ,b8.WALLETCONNECT);H9({apiKey:J});let W=q.filter((V)=>CJ.includes(V)),j=await S9(W,X,M);if(!j)throw new D$("wallet_walletconnect_connection_not_established");let{session:R,accounts:K}=j,D=W.map(async(V)=>{let O=m$(V,K),N=await P9({apis:Q,session:R,address:O,chain:V,walletconnect:j,ethplorerApiKey:Y,covalentApiKey:z,stagenet:Z});async function E(H){let w=await N.getAccount(H),[{address:P,algo:C,pubkey:y}]=await j?.client.request({chainId:X$,topic:R.topic,request:{method:"cosmos_getAccounts",params:{}}});return{...w,address:P,pubkey:{type:C,value:y}}}$({...N,disconnect:j.disconnect,address:O,balance:[],chain:V,walletType:b8.WALLETCONNECT,getAccount:V===m.THORChain?E:N.getAccount})});return await Promise.all(D),!0}}var jG={connectWalletconnect:E9};export{jG as walletconnectWallet,CJ as WC_SUPPORTED_CHAINS,X$ as THORCHAIN_MAINNET_ID,o8 as POLYGON_MAINNET_ID,n8 as OPTIMISM_MAINNET_ID,l8 as MAYACHAIN_MAINNET_ID,p8 as KUJIRA_MAINNET_ID,c8 as ETHEREUM_MAINNET_ID,d$ as DEFAULT_SOLANA_METHODS,u$ as DEFAULT_SOLANA_EVENTS,g8 as DEFAULT_RELAY_URL,p$ as DEFAULT_POLKADOT_METHODS,l$ as DEFAULT_POLKADOT_EVENTS,i$ as DEFAULT_NEAR_METHODS,n$ as DEFAULT_NEAR_EVENTS,a8 as DEFAULT_LOGGER,h$ as DEFAULT_EIP_155_EVENTS,O$ as DEFAULT_EIP155_METHODS,N$ as DEFAULT_COSMOS_METHODS,LJ as DEFAULT_COSMOS_EVENTS,s8 as DEFAULT_APP_METADATA,u8 as COSMOS_HUB_MAINNET_ID,h8 as BSC_MAINNET_ID,r8 as BASE_MAINNET_ID,d8 as AVALACHE_MAINNET_ID,i8 as ARBITRUM_ONE_MAINNET_ID};

//# debugId=9914A7CE2E5A940064756E2164756E21
