{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import { PublicKey, SystemProgram, Transaction } from \"@solana/web3.js\";\nimport {\n  type AssetValue,\n  Chain,\n  type ChainApis,\n  type ConnectWalletParams,\n  SwapKitError,\n  WalletOption,\n  type WalletTxParams,\n  filterSupportedChains,\n  pickEvmApiKey,\n  setRequestClientConfig,\n} from \"@swapkit/helpers\";\nimport type { SolanaProvider } from \"@swapkit/toolbox-solana\";\n\nexport const PHANTOM_SUPPORTED_CHAINS = [Chain.Bitcoin, Chain.Ethereum, Chain.Solana] as const;\nexport type PhantomSupportedChains = (typeof PHANTOM_SUPPORTED_CHAINS)[number];\n\ndeclare global {\n  interface Window {\n    phantom: {\n      solana: SolanaProvider;\n    };\n  }\n}\n\nasync function getWalletMethods({\n  apis,\n  chain,\n  rpcUrl,\n  covalentApiKey,\n  ethplorerApiKey,\n}: {\n  apis?: ChainApis;\n  rpcUrl?: string;\n  chain: (typeof PHANTOM_SUPPORTED_CHAINS)[number];\n  covalentApiKey?: string;\n  ethplorerApiKey?: string;\n}) {\n  const phantom: any = window?.phantom;\n\n  switch (chain) {\n    case Chain.Bitcoin: {\n      const provider = phantom?.bitcoin;\n      if (!provider?.isPhantom) {\n        throw new SwapKitError(\"wallet_phantom_not_found\");\n      }\n      const [{ address }] = await provider.requestAccounts();\n\n      const { getToolboxByChain } = await import(\"@swapkit/toolbox-utxo\");\n      const toolbox = getToolboxByChain(chain);\n\n      return { ...toolbox({ rpcUrl }), address };\n    }\n\n    case Chain.Ethereum: {\n      const { getToolboxByChain } = await import(\"@swapkit/toolbox-evm\");\n      const { BrowserProvider } = await import(\"ethers\");\n\n      const api = apis?.[chain];\n\n      const provider = new BrowserProvider(phantom?.ethereum, \"any\");\n      const [address] = await provider.send(\"eth_requestAccounts\", []);\n\n      const apiKey = pickEvmApiKey({\n        chain,\n        nonEthApiKey: covalentApiKey,\n        ethApiKey: ethplorerApiKey,\n      });\n      const signer = await provider.getSigner();\n\n      const toolbox = getToolboxByChain(chain)({ api, apiKey, signer, provider });\n\n      return { ...toolbox, address };\n    }\n\n    case Chain.Solana: {\n      const { createSolanaTokenTransaction, SOLToolbox } = await import(\"@swapkit/toolbox-solana\");\n      const provider = phantom?.solana;\n      if (!provider?.isPhantom) {\n        throw new SwapKitError(\"wallet_phantom_not_found\");\n      }\n\n      const providerConnection = await provider.connect();\n      const address: string = providerConnection.publicKey.toString();\n\n      const toolbox = SOLToolbox({ rpcUrl });\n\n      const transfer = async ({\n        recipient,\n        assetValue,\n        isProgramDerivedAddress,\n      }: WalletTxParams & { assetValue: AssetValue; isProgramDerivedAddress?: boolean }) => {\n        if (!(isProgramDerivedAddress || toolbox.validateAddress(recipient))) {\n          throw new SwapKitError(\"core_transaction_invalid_recipient_address\");\n        }\n\n        const fromPubkey = new PublicKey(address);\n\n        const amount = assetValue.getBaseValue(\"number\");\n\n        const transaction = assetValue.isGasAsset\n          ? new Transaction().add(\n              SystemProgram.transfer({\n                fromPubkey,\n                lamports: amount,\n                toPubkey: new PublicKey(recipient),\n              }),\n            )\n          : assetValue.address\n            ? await createSolanaTokenTransaction({\n                amount,\n                connection: toolbox.connection,\n                decimals: assetValue.decimal as number,\n                from: fromPubkey,\n                recipient,\n                tokenAddress: assetValue.address,\n              })\n            : undefined;\n\n        if (!transaction) {\n          throw new SwapKitError(\"core_transaction_invalid_sender_address\");\n        }\n\n        const blockHash = await toolbox.connection.getLatestBlockhash();\n        transaction.recentBlockhash = blockHash.blockhash;\n        transaction.feePayer = fromPubkey;\n\n        const signedTransaction = await provider.signTransaction(transaction);\n\n        const txid = await toolbox.connection.sendRawTransaction(signedTransaction.serialize());\n\n        return txid;\n      };\n\n      return { ...toolbox, transfer, address };\n    }\n\n    default: {\n      throw new SwapKitError(\"wallet_chain_not_supported\", {\n        wallet: WalletOption.PHANTOM,\n        chain,\n      });\n    }\n  }\n}\n\nfunction connectPhantom({\n  addChain,\n  config: { covalentApiKey, ethplorerApiKey, thorswapApiKey },\n  rpcUrls,\n}: ConnectWalletParams) {\n  return async function connectPhantom(chains: Chain[]) {\n    setRequestClientConfig({ apiKey: thorswapApiKey });\n\n    const supportedChains = filterSupportedChains(\n      chains,\n      PHANTOM_SUPPORTED_CHAINS,\n      WalletOption.PHANTOM,\n    );\n\n    async function connectChain(chain: PhantomSupportedChains) {\n      const rpcUrl = rpcUrls[chain];\n      const { address, ...methods } = await getWalletMethods({\n        chain,\n        covalentApiKey,\n        ethplorerApiKey,\n        rpcUrl,\n      });\n\n      addChain({\n        ...methods,\n        chain,\n        address,\n        walletType: WalletOption.PHANTOM,\n        balance: [],\n      });\n    }\n\n    try {\n      for (const chain of supportedChains) {\n        await connectChain(chain);\n      }\n\n      return true;\n    } catch (error) {\n      if (error instanceof SwapKitError) throw error;\n\n      throw new SwapKitError(\"wallet_connection_rejected_by_user\");\n    }\n  };\n}\n\nexport const phantomWallet = { connectPhantom } as const;\n"
  ],
  "mappings": "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",
  "debugId": "9B3249FA5313418164756E2164756E21",
  "names": []
}