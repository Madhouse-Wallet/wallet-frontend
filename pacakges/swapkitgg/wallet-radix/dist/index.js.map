{
  "version": 3,
  "sources": ["../src/radixWallet.ts"],
  "sourcesContent": [
    "import {\n  type FungibleResourcesCollectionItem,\n  GatewayApiClient,\n  type StateEntityDetailsVaultResponseItem,\n  type StateEntityFungiblesPageRequest,\n  type StateEntityFungiblesPageResponse,\n} from \"@radixdlt/babylon-gateway-api-sdk\";\nimport { DataRequestBuilder, RadixDappToolkit } from \"@radixdlt/radix-dapp-toolkit\";\nimport {\n  AssetValue,\n  Chain,\n  type ConnectWalletParams,\n  WalletOption,\n  setRequestClientConfig,\n} from \"@swapkit/helpers\";\n\nconst RadixMainnet = {\n  networkId: 1,\n  networkName: \"mainnet\",\n  dashboardBase: \"https://dashboard.radixdlt.com\",\n};\n\ntype RadixDappConfig = {\n  dAppDefinitionAddress: string;\n  network: typeof RadixMainnet;\n  applicationName: string;\n  applicationVersion: string;\n};\n\nasync function fetchFungibleResources({\n  address,\n  networkApi,\n}: any): Promise<FungibleResourcesCollectionItem[]> {\n  let hasNextPage = true;\n  let nextCursor = undefined;\n  let fungibleResources: FungibleResourcesCollectionItem[] = [];\n  const stateVersion = await currentStateVersion(networkApi);\n  while (hasNextPage) {\n    const stateEntityFungiblesPageRequest: StateEntityFungiblesPageRequest = {\n      address: address,\n      limit_per_page: 100,\n      cursor: nextCursor,\n      at_ledger_state: {\n        state_version: stateVersion,\n      },\n    };\n\n    const stateEntityFungiblesPageResponse: StateEntityFungiblesPageResponse =\n      await networkApi.state.innerClient.entityFungiblesPage({\n        stateEntityFungiblesPageRequest: stateEntityFungiblesPageRequest,\n      });\n\n    fungibleResources = fungibleResources.concat(stateEntityFungiblesPageResponse.items);\n    if (stateEntityFungiblesPageResponse.next_cursor) {\n      nextCursor = stateEntityFungiblesPageResponse.next_cursor;\n    } else {\n      hasNextPage = false;\n    }\n  }\n  return fungibleResources;\n}\n\nasync function currentStateVersion(networkApi: GatewayApiClient) {\n  return networkApi.status.getCurrent().then((status) => status.ledger_state.state_version);\n}\n\nfunction getBalance({ networkApi }: { networkApi: GatewayApiClient }) {\n  return async function getBalance(address: string) {\n    const fungibleResources = await fetchFungibleResources({ address, networkApi });\n    const fungibleBalances = convertResourcesToBalances({\n      resources: fungibleResources,\n      networkApi,\n    });\n    return fungibleBalances;\n  };\n}\n\n// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: <explanation>\nasync function convertResourcesToBalances({\n  resources,\n  networkApi,\n}: {\n  resources: FungibleResourcesCollectionItem[]; //| NonFungibleResourcesCollectionItem[];\n  networkApi: GatewayApiClient;\n}): Promise<AssetValue[]> {\n  const balances: AssetValue[] = [];\n  const BATCH_SIZE = 50;\n\n  // Split resources into batches of up to 50 items\n  const resourceBatches = [];\n  for (let i = 0; i < resources.length; i += BATCH_SIZE) {\n    resourceBatches.push(resources.slice(i, i + BATCH_SIZE));\n  }\n\n  for (const batch of resourceBatches) {\n    const addresses = batch.map((item) => item.resource_address);\n    const response: StateEntityDetailsVaultResponseItem[] =\n      await networkApi.state.getEntityDetailsVaultAggregated(addresses);\n\n    const divisibilities = new Map<string, { decimals: number; symbol: string }>();\n\n    for (const result of response) {\n      if (result.details !== undefined) {\n        const metaDataSymbol = result.metadata?.items.find((item) => item.key === \"symbol\");\n        const symbol =\n          metaDataSymbol?.value.typed.type === \"String\" ? metaDataSymbol.value.typed.value : \"?\";\n\n        if (result.details.type === \"FungibleResource\") {\n          divisibilities.set(result.address, {\n            decimals: result.details.divisibility,\n            symbol,\n          });\n        }\n      }\n    }\n\n    for (const item of batch) {\n      if (item.aggregation_level === \"Global\") {\n        const assetInfo = divisibilities.get(item.resource_address) || { decimals: 0, symbol: \"?\" };\n\n        const balance = AssetValue.from({\n          asset:\n            assetInfo.symbol !== Chain.Radix\n              ? `${Chain.Radix}.${assetInfo.symbol}-${item.resource_address}`\n              : \"XRD.XRD\",\n          value: item.amount,\n        });\n        balances.push(balance);\n      }\n    }\n  }\n  // Iterate through resources\n  return balances;\n}\n\nconst getWalletMethods = async (dappConfig: RadixDappConfig) => {\n  const rdt = RadixDappToolkit({ ...dappConfig, networkId: dappConfig.network.networkId });\n\n  function delay(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  await delay(400);\n\n  const getAddress = () => {\n    const existingWalletData = rdt.walletApi.getWalletData();\n    const account = existingWalletData?.accounts?.[0];\n\n    return account?.address;\n  };\n\n  const getNewAddress = async () => {\n    rdt.walletApi.setRequestData(DataRequestBuilder.accounts().exactly(1));\n    const res = await rdt.walletApi.sendRequest();\n\n    if (!res) {\n      throw new Error(\"wallet_radix_no_account\");\n    }\n\n    const newAddress = res.unwrapOr(null)?.accounts[0]?.address;\n\n    if (!newAddress) {\n      throw new Error(\"wallet_radix_no_account\");\n    }\n\n    return newAddress;\n  };\n\n  const connectIfNoAddress = async () => (await getAddress()) || (await getNewAddress());\n\n  const address = await connectIfNoAddress();\n\n  const networkApi = GatewayApiClient.initialize({\n    networkId: RadixMainnet.networkId,\n    applicationName: dappConfig.applicationName,\n  });\n\n  return {\n    radixDappToolkit: rdt,\n    address,\n    getBalance: () => getBalance({ networkApi })(address),\n    transfer: (_params: { assetValue: AssetValue; recipient: string; from: string }) => {\n      throw new Error(\"Not implemented\");\n    },\n    signAndBroadcast: async ({ manifest, message }: { manifest: string; message: string }) => {\n      const txResult = (\n        await rdt.walletApi.sendTransaction({\n          transactionManifest: manifest,\n          message,\n        })\n      ).unwrapOr(null)?.transactionIntentHash;\n\n      if (!txResult) {\n        throw new Error(\"wallet_radix_transaction_failed\");\n      }\n\n      return txResult;\n    },\n    getAddress: getAddress,\n  };\n};\n\nfunction connectRadixWallet({\n  addChain,\n  config: {\n    thorswapApiKey,\n    radixDappConfig = {\n      network: RadixMainnet,\n      dAppDefinitionAddress: \"account_rdx128r289p58222hcvev7frs6kue76pl7pdcnw8725aw658v0zggkh9ws\",\n      applicationName: \"Swapkit Playground\",\n      applicationVersion: \"0.0.1\",\n    },\n  },\n}: ConnectWalletParams & {\n  radixDappConfig?: RadixDappConfig;\n}) {\n  return async function connectRadixWallet(_chains: Chain[]) {\n    setRequestClientConfig({ apiKey: thorswapApiKey });\n\n    const walletMethods = await getWalletMethods({\n      ...radixDappConfig,\n    });\n\n    addChain({\n      chain: Chain.Radix,\n      balance: [],\n      walletType: WalletOption.RADIX_WALLET,\n      ...walletMethods,\n    });\n\n    return true;\n  };\n}\n\nexport const radixWallet = { connectRadixWallet } as const;\n"
  ],
  "mappings": "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",
  "debugId": "8BD76760ED2300F864756E2164756E21",
  "names": []
}