import{networks as YB,Psbt as IB,Transaction as FB}from"bitcoinjs-lib";import{Chain as W,RequestClient as i}from"@swapkit/helpers";var A=(_)=>`https://api.blockchair.com/${l_(_)}`,k_=(_)=>{switch(_){case W.Bitcoin:return 5;case W.Dogecoin:return 1e4;case W.Litecoin:return 1;default:return 2}},l_=(_)=>{switch(_){case W.BitcoinCash:return"bitcoin-cash";case W.Litecoin:return"litecoin";case W.Dash:return"dash";case W.Dogecoin:return"dogecoin";case W.Polkadot:return"polkadot";default:return"bitcoin"}},m_=async(_)=>{try{let{feePerKb:g}=await i.get(`https://app.bitgo.com/api/v2/${_.toLowerCase()}/tx/fee`),B=g/1000;return Math.max(B,k_(_))}catch(g){return k_(_)}},V=async(_,g)=>{try{let B=await i.get(_);if(!B||B.context.code!==200)throw new Error(`failed to query ${_}`);return B.data}catch(B){if(!g)throw B;let b=await i.get(`${_}${g?`&key=${g}`:""}`);if(!b||b.context.code!==200)throw new Error(`failed to query ${_}`);return b.data}},O_={utxo:[],address:{balance:0,transaction_count:0}},D_=async({address:_,chain:g,apiKey:B})=>{if(!_)throw new Error("address is required");try{return(await V(`${A(g)}/dashboards/address/${_}?transaction_details=true`,B))[_]}catch(b){return O_}},x_=async({address:_,chain:g,apiKey:B})=>{return(await D_({address:_,chain:g,apiKey:B}))?.address.balance},A_=async({chain:_,address:g,apiKey:B})=>{if(!g)throw new Error("address is required");try{return(await V(`${A(_)}/addresses/balances?addresses=${g}`,B))[g]||0}catch(b){return 0}},G_=async({chain:_,apiKey:g,txHash:B})=>{if(!B)throw new Error("txHash is required");try{return(await V(`${A(_)}/raw/transaction/${B}`,g))?.[B]?.raw_transaction}catch(b){return console.error(b),""}},V_=async({chain:_,address:g,apiKey:B,offset:b=0,limit:n=100})=>{return(await V(`${A(_)}/outputs?q=is_spent(false),recipient(${g})&limit=${n}&offset=${b}`,B)).filter(({is_spent:D})=>!D).map(({script_hex:D,block_id:Q,transaction_hash:v,index:$,value:Z,spending_signature_hex:G})=>({hash:v,index:$,value:Z,txHex:G,script_hex:D,is_confirmed:Q!==-1}))},v_=async({chain:_,address:g,apiKey:B,offset:b=0,limit:n=100})=>{if(!g)throw new Error("address is required");try{let X=await V_({chain:_,address:g,apiKey:B,offset:b,limit:n});if(X.length<=n)return X;let k=await v_({chain:_,address:g,apiKey:B,offset:b+n,limit:n});return[...X,...k]}catch(X){return console.error(X),[]}},N_=async({address:_,chain:g,apiKey:B,fetchTxHex:b=!0})=>{let n=await v_({chain:g,address:_,apiKey:B}),X=[];for(let{hash:k,index:D,script_hex:Q,value:v}of n){let $;if(b)$=await G_({txHash:k,chain:g,apiKey:B});X.push({address:_,hash:k,index:D,txHex:$,value:v,witnessUtxo:{value:v,script:Buffer.from(Q,"hex")}})}return X},N=({apiKey:_,chain:g})=>({getConfirmedBalance:(B)=>A_({chain:g,address:B,apiKey:_}),getRawTx:(B)=>G_({txHash:B,chain:g,apiKey:_}),getSuggestedTxFee:()=>m_(g),getBalance:(B)=>x_({address:B,chain:g,apiKey:_}),getAddressData:(B)=>D_({address:B,chain:g,apiKey:_}),scanUTXOs:(B)=>N_({...B,chain:g,apiKey:_})});import{Chain as j,ChainToRPC as Mg}from"@swapkit/helpers";import{RequestClient as o_}from"@swapkit/helpers";import{Chain as I,FeeOption as t}from"@swapkit/helpers";import{networks as C_}from"bitcoinjs-lib";import F from"coininfo";var P_=typeof process!=="undefined"&&process.pid?process.pid.toString(36):"",U=(_)=>{switch(_){case I.Bitcoin:return C_.bitcoin;case I.BitcoinCash:return F.bitcoincash.main.toBitcoinJS();case I.Dash:return F.dash.main.toBitcoinJS();case I.Litecoin:return F.litecoin.main.toBitcoinJS();case I.Dogecoin:{let g={private:70615956,public:70617039},B=F.dogecoin.test;return B.versions.bip32=g,F.dogecoin.main.toBitcoinJS()}default:throw new Error("Invalid chain")}},$_=(_)=>({[t.Average]:_,[t.Fast]:_*1.5,[t.Fastest]:_*2}),d=0,f_=()=>{let _=Date.now(),g=d||_;return d=g,_>d?_:g+1},J_=()=>P_+f_().toString(36);var C=async({txHash:_,rpcUrl:g})=>{let B=JSON.stringify({jsonrpc:"2.0",method:"sendrawtransaction",params:[_],id:J_()}),b=await o_.post(g,{headers:{"Content-Type":"application/json"},body:B});if(b.error)throw new Error(`failed to broadcast a transaction: ${b.error?.message}`);if(b.result.includes('"code":-26'))throw new Error("Invalid transaction: the transaction amount was too low");return b.result};import*as Xg from"@bitcoinerlab/secp256k1";import{HDNode as kg,Transaction as Dg,TransactionBuilder as Gg,address as vg}from"@psf/bitcoincashjs-lib";import{mnemonicToSeedSync as $g}from"@scure/bip39";import{Chain as Y_,DerivationPath as Jg,FeeOption as rg,getRPCUrl as Qg}from"@swapkit/helpers";import{Psbt as Zg}from"bitcoinjs-lib";import{ECPairFactory as qg}from"ecpair";import Q_ from"bs58check";import Z_ from"cashaddrjs";var q_;((B)=>{B.Mainnet="mainnet";B.Testnet="testnet"})(q_||={});var r={["legacy"]:{["mainnet"]:{["p2pkh"]:0,["p2sh"]:5},["testnet"]:{["p2pkh"]:111,["p2sh"]:196}},["bitpay"]:{["mainnet"]:{["p2pkh"]:28,["p2sh"]:40},["testnet"]:{["p2pkh"]:111,["p2sh"]:196}}};function L_(_){try{return f(_),!0}catch(g){return!1}}function U_(_){return f(_)?.network}function l(_){let g=f(_);if(g?.format==="legacy")return _;return E_(g)}function P(_){let g=f(_);return R_(g)}function f(_){try{return K_(_)}catch(g){}try{return S_(_)}catch(g){}throw Error("Received an invalid Bitcoin Cash address as input.")}function K_(_){try{let g=Q_.decode(_);if(g.length!==21)throw Error("Received an invalid Bitcoin Cash address as input.");let B=g[0],b=Array.prototype.slice.call(g,1);switch(B){case r.legacy.mainnet.p2pkh:return{hash:b,format:"legacy",network:"mainnet",type:"p2pkh"};case r.legacy.mainnet.p2sh:return{hash:b,format:"legacy",network:"mainnet",type:"p2sh"};case r.legacy.testnet.p2pkh:return{hash:b,format:"legacy",network:"testnet",type:"p2pkh"};case r.legacy.testnet.p2sh:return{hash:b,format:"legacy",network:"testnet",type:"p2sh"};case r.bitpay.mainnet.p2pkh:return{hash:b,format:"bitpay",network:"mainnet",type:"p2pkh"};case r.bitpay.mainnet.p2sh:return{hash:b,format:"bitpay",network:"mainnet",type:"p2sh"};default:throw Error("Received an invalid Bitcoin Cash address as input.")}}catch(g){throw Error("Received an invalid Bitcoin Cash address as input.")}}function S_(_){if(_.indexOf(":")!==-1)try{return r_(_)}catch(g){}else{let g=["bitcoincash","bchtest","bchreg"];for(let B of g)try{return r_(`${B}:${_}`)}catch(b){}}throw Error("Received an invalid Bitcoin Cash address as input.")}function r_(_){try{let{hash:g,prefix:B,type:b}=Z_.decode(_);return{format:"cashaddr",hash:Array.prototype.slice.call(g,0),network:B==="bitcoincash"?"mainnet":"testnet",type:b==="P2PKH"?"p2pkh":"p2sh"}}catch(g){throw Error("Received an invalid Bitcoin Cash address as input.")}}function E_(_){let g=r.legacy[_.network][_.type],B=Buffer.alloc(1+_.hash.length);return B[0]=g,B.set(_.hash,1),Q_.encode(B)}function R_(_){let g=_.network==="mainnet"?"bitcoincash":"bchtest",B=_.type==="p2pkh"?"P2PKH":"P2SH",b=new Uint8Array(_.hash);return Z_.encode(g,B,b)}import{Chain as w}from"@swapkit/helpers";var s=(_)=>{switch(_){case w.Bitcoin:case w.BitcoinCash:return 550;case w.Dash:case w.Litecoin:return 5500;case w.Dogecoin:return 1e5;default:throw new Error("Invalid Chain")}},z=({inputs:_,outputs:g,feeRate:B=1,chain:b=w.Bitcoin})=>{let n=Math.ceil(B),X=_[0]&&"address"in _[0]&&_[0].address?K(_[0].address):"P2PKH",k=_.filter((G)=>T(G)*n<=G.value),D=a+g.reduce((G,J)=>G+o(J,X),0),Q=g.reduce((G,J)=>G+J.value,0),v=D*n,$=0,Z=[];for(let G of k){let J=T(G),q=n*J;v+=q,$+=G.value,Z.push(G);let L=v+Q;if($<L)continue;let H=$-L,b_=n*o({address:"",value:0},X);if(H>b_){let n_=b_+v,X_=$-(Q+n_);if(X_>Math.max(T({})*n,s(b)))return{inputs:Z,outputs:g.concat({value:X_,address:""}),fee:n_}}return{inputs:Z,outputs:g,fee:v}}return{fee:n*m({inputs:_,outputs:g,feeRate:n})}};import{opcodes as c_,script as u_}from"bitcoinjs-lib";var Eg=1000,a=10,h_=10,p_=41,i_=107,y=(_)=>{let g=Buffer.from(_,"utf8");return u_.compile([c_.OP_RETURN,g])},e;((B)=>{B.P2PKH="P2PKH";B.P2WPKH="P2WPKH"})(e||={});var __={["P2PKH"]:148,["P2WPKH"]:68},S={["P2PKH"]:34,["P2WPKH"]:31},K=(_)=>{if(_.startsWith("bc1")||_.startsWith("ltc1"))return"P2WPKH";if(_.startsWith("1")||_.startsWith("3")||_.startsWith("L")||_.startsWith("M")||_.startsWith("X")||_.startsWith("D")||_.startsWith("bitcoincash:q")||_.startsWith("q"))return"P2PKH";throw new Error("Invalid address")},m=({inputs:_,outputs:g,feeRate:B})=>{let b=_[0]&&"address"in _[0]&&_[0].address?K(_[0].address):"P2PKH",n=_.filter((k)=>k.value>=__["type"in k?k.type:"P2PKH"]*Math.ceil(B)).reduce((k,D)=>k+T(D),0),X=g?.reduce((k,D)=>k+o(D),0)||S[b];return a+n+X},T=(_)=>{if("type"in _)return __[_.type];if("address"in _&&_.address)return __[K(_.address)];return p_+i_},o=(_,g)=>{if(_?.script)return h_+_.script.length+(_.script.length>=74?2:1);if(g)return S[g];return S.P2PKH};import*as g_ from"@bitcoinerlab/secp256k1";import{HDKey as t_}from"@scure/bip32";import{mnemonicToSeedSync as d_}from"@scure/bip39";import{AssetValue as E,BaseDecimal as s_,Chain as R,FeeOption as B_,SwapKitNumber as T_}from"@swapkit/helpers";import{Psbt as a_,address as e_,initEccLib as z_,payments as j_}from"bitcoinjs-lib";import{ECPairFactory as _g}from"ecpair";var c=[R.Dash,R.Dogecoin],W_=({phrase:_,wif:g,derivationPath:B,chain:b})=>{if(!(g||_))throw new Error("Either phrase or wif must be provided");let n=_g(g_),X=U(b);if(g)return n.fromWIF(g,X);let k=d_(_),D=t_.fromMasterSeed(k,X).derive(B);if(!D.privateKey)throw new Error("Could not get private key from phrase");return n.fromPrivateKey(Buffer.from(D.privateKey),{network:X})},y_=({address:_,chain:g})=>{try{return z_(g_),e_.toOutputScript(_,U(g)),!0}catch(B){return!1}},gg=({keys:_,chain:g})=>{if(!_)throw new Error("Keys must be provided");let B=c.includes(g)?j_.p2pkh:j_.p2wpkh,{address:b}=B({pubkey:_.publicKey,network:U(g)});if(!b)throw new Error("Address not defined");return b},Bg=async({signTransaction:_,from:g,memo:B,recipient:b,chain:n,apiClient:X,feeOptionKey:k,broadcastTx:D,feeRate:Q,assetValue:v})=>{if(!g)throw new Error("From address must be provided");if(!b)throw new Error("Recipient address must be provided");let $=Q||(await u(X))[k||B_.Fast],{psbt:Z}=await w_({recipient:b,feeRate:$,sender:g,fetchTxHex:c.includes(n),chain:n,apiClient:X,assetValue:v,memo:B}),G=await _(Z);return G.finalizeAllInputs(),D(G.extractTransaction().toHex())},bg=async({address:_,chain:g,apiClient:B})=>{let b=await B.getBalance(_)||0,n=T_.fromBigInt(BigInt(b),s_[g]).getValue("string");return[await E.from({asset:`${g}.${g}`,value:n})]},u=async(_)=>$_(await _.getSuggestedTxFee()),H_=async({assetValue:_,recipient:g,memo:B,sender:b,fetchTxHex:n=!1,apiClient:X})=>{return{inputs:await X.scanUTXOs({address:b,fetchTxHex:n}),outputs:[{address:g,value:Number(_.bigIntValue)},...B?[{address:"",script:y(B),value:0}]:[]]}},w_=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,fetchTxHex:X=!1,apiClient:k,chain:D})=>{let Q=B?y(B):null,v=await H_({assetValue:_,recipient:g,memo:B,sender:n,fetchTxHex:X,apiClient:k}),{inputs:$,outputs:Z}=z({...v,feeRate:b,chain:D});if(!($&&Z))throw new Error("Insufficient Balance for transaction");let G=new a_({network:U(D)});if(D===R.Dogecoin)G.setMaximumFeeRate(650000000);for(let J of $)G.addInput({hash:J.hash,index:J.index,...!!J.witnessUtxo&&!c.includes(D)&&{witnessUtxo:J.witnessUtxo},...c.includes(D)&&{nonWitnessUtxo:J.txHex?Buffer.from(J.txHex,"hex"):void 0}});for(let J of Z){let q="address"in J&&J.address?J.address:n,L=J.script?Q?{script:Q,value:0}:void 0:{address:q,value:J.value};if(L)z_(g_),G.addOutput(L)}return{psbt:G,utxos:v.inputs,inputs:$}},M_=async({assetValue:_,apiClient:g,chain:B,feeOptionKey:b=B_.Fast,feeRate:n,fetchTxHex:X=!1,memo:k,recipient:D,from:Q})=>{let v=await H_({assetValue:_,recipient:D,memo:k,sender:Q,fetchTxHex:X,apiClient:g}),$=n?Math.floor(n):(await u(g))[b];return z({...v,feeRate:$,chain:B})},ng=async({from:_,memo:g,feeRate:B,feeOptionKey:b=B_.Fast,recipients:n=1,chain:X,apiClient:k})=>{let D=await k.getAddressData(_),Q=B?Math.ceil(B):(await u(k))[b],v=D?.utxo.map((q)=>({...q,type:"P2PKH",hash:""})).filter((q)=>q.value>Math.max(s(X),T(q)*Q));if(!v?.length)return E.from({chain:X});let $=E.from({chain:X,value:v.reduce((q,L)=>q+L.value,0)}),Z=typeof n==="number"?Array.from({length:n},()=>({address:_,value:0})):n;if(g){let q=y(g);Z.push({address:_,script:q,value:0})}let J=m({inputs:v,outputs:Z,feeRate:Q})*Q;return $.sub(J)},h=(_)=>({accumulative:z,apiClient:_.apiClient,broadcastTx:_.broadcastTx,calculateTxSize:m,buildTx:(g)=>w_({...g,..._}),getAddressFromKeys:(g)=>gg({keys:g,..._}),validateAddress:(g)=>y_({address:g,..._}),createKeysForPath:(g)=>W_({...g,..._}),getPrivateKeyFromMnemonic:async(g)=>W_({..._,...g}).toWIF(),getBalance:async(g,B)=>bg({address:g,..._}),getFeeRates:()=>u(_.apiClient),transfer:(g)=>Bg({...g,..._}),getInputsOutputsFee:(g)=>M_({...g,..._}),estimateTransactionFee:async(g)=>{return E.from({chain:_.chain,value:T_.fromBigInt(BigInt((await M_({...g,..._})).fee),8).getValue("string")})},estimateMaxSendableAmount:async(g)=>ng({...g,..._})}),gB=({chain:_,address:g})=>_===R.BitcoinCash?Y(g):y_({address:g,chain:_});var M=Y_.BitcoinCash,x=(_)=>O(P(_)),I_=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,apiClient:X})=>{if(!Y(g))throw new Error("Invalid address");let k=await X.scanUTXOs({address:x(n),fetchTxHex:!0}),D=B?y(B):null,Q=[];Q.push({address:g,value:_.getBaseValue("number")});let{inputs:v,outputs:$}=z({inputs:k,outputs:Q,feeRate:b,chain:M});if(!(v&&$))throw new Error("Balance insufficient for transaction");let Z=new Gg(U(M));await Promise.all(v.map(async(G)=>{let J=await X.getRawTx(G.hash);Z.addInput(Dg.fromBuffer(Buffer.from(J,"hex")),G.index)}));for(let G of $){let J="address"in G&&G.address?G.address:l(n),q=vg.toOutputScript(l(J),U(M));Z.addOutput(q,G.value)}if(D)Z.addOutput(D,0);return{builder:Z,utxos:v}},Lg=async({signTransaction:_,from:g,recipient:B,assetValue:b,apiClient:n,broadcastTx:X,getFeeRates:k,...D})=>{if(!g)throw new Error("From address must be provided");if(!B)throw new Error("Recipient address must be provided");if(!_)throw new Error("signTransaction must be provided");let Q=D.feeRate||(await k())[rg.Fast],{builder:v,utxos:$}=await I_({...D,assetValue:b,feeRate:Q,recipient:B,sender:g,apiClient:n}),G=_({builder:v,utxos:$}).toHex();return X(G)},Ug=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,apiClient:X})=>{let k=P(g);if(!Y(k))throw new Error("Invalid address");let D=await X.scanUTXOs({address:x(n),fetchTxHex:!0}),Q=Number(b.toFixed(0)),v=B?y(B):null,$=[];if($.push({address:l(g),value:_.getBaseValue("number")}),v)$.push({script:v,value:0});let{inputs:Z,outputs:G}=z({inputs:D,outputs:$,feeRate:Q,chain:M});if(!(Z&&G))throw new Error("Balance insufficient for transaction");let J=new Zg({network:U(M)});for(let{hash:q,index:L,witnessUtxo:H}of Z)J.addInput({hash:q,index:L,witnessUtxo:H});for(let q of G){let L="address"in q&&q.address?q.address:l(n),H=q.script?v?{script:v,value:0}:void 0:{address:L,value:q.value};if(H)J.addOutput(H)}return{psbt:J,utxos:D,inputs:Z}},O=(_)=>_.replace(/(bchtest:|bitcoincash:)/,""),Y=(_)=>{let g=O(_);return L_(g)&&U_(g)==="mainnet"},jg=({phrase:_,derivationPath:g=`${Jg.BCH}/0`,wif:B})=>{let b=U(M);if(B)return qg(Xg).fromWIF(B,b);if(!_)throw new Error("No phrase provided");return kg.fromSeedBuffer(Buffer.from($g(_)),b).derivePath(g).keyPair},Wg=(_)=>{let g=_.getAddress(0);return x(g)},F_=({apiKey:_,rpcUrl:g=Qg(Y_.BitcoinCash),apiClient:B})=>{let b=B||N({apiKey:_,chain:M}),{getBalance:n,...X}=h({chain:M,apiClient:b,broadcastTx:(k)=>C({txHash:k,rpcUrl:g})});return{...X,stripPrefix:O,stripToCashAddress:x,validateAddress:Y,createKeysForPath:jg,getAddressFromKeys:Wg,buildBCHTx:(k)=>I_({...k,apiClient:b}),getBalance:(k,D)=>n(O(P(k))),buildTx:(k)=>Ug({...k,apiClient:b}),transfer:(k)=>Lg({...k,getFeeRates:X.getFeeRates,broadcastTx:X.broadcastTx,apiClient:b})}};var p=(_)=>({apiKey:g,rpcUrl:B=Mg[_],apiClient:b})=>{return h({chain:_,broadcastTx:(n)=>C({txHash:n,rpcUrl:B}),apiClient:b||N({apiKey:g,chain:_})})},Tg=F_,zg=p(j.Bitcoin),yg=p(j.Dash),Hg=p(j.Dogecoin),wg=p(j.Litecoin),WB=(_)=>{switch(_){case j.BitcoinCash:return Tg;case j.Bitcoin:return zg;case j.Dogecoin:return Hg;case j.Litecoin:return wg;case j.Dash:return yg;default:throw new Error(`Chain ${_} is not supported`)}};export{Y as validateAddress,gB as utxoValidateAddress,J_ as uniqid,l as toLegacyAddress,P as toCashAddress,x as stripToCashAddress,O as stripPrefix,$_ as standardFeeRates,c as nonSegwitChains,YB as networks,L_ as isValidAddress,WB as getToolboxByChain,K as getScriptTypeForAddress,o as getOutputSize,U as getNetwork,T as getInputSize,s as getDustThreshold,ng as estimateMaxSendableAmount,U_ as detectAddressNetwork,y as compileMemo,m as calculateTxSize,w_ as buildTx,N as blockchairApi,z as accumulative,e as UTXOScriptType,FB as Transaction,a as TX_OVERHEAD,IB as Psbt,S as OutputSizes,h_ as OP_RETURN_OVERHEAD,q_ as Network,Eg as MIN_TX_FEE,wg as LTCToolbox,__ as InputSizes,Hg as DOGEToolbox,yg as DASHToolbox,h as BaseUTXOToolbox,zg as BTCToolbox,Tg as BCHToolbox};

//# debugId=1F586F2A0DFA4A7664756E2164756E21
