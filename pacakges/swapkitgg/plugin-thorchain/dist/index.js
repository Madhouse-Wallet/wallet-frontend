var Y1=Object.create;var{getPrototypeOf:_1,defineProperty:l,getOwnPropertyNames:j1}=Object;var G1=Object.prototype.hasOwnProperty;var i=(Z,k,Y)=>{Y=Z!=null?Y1(_1(Z)):{};let R=k||!Z||!Z.__esModule?l(Y,"default",{value:Z,enumerable:!0}):Y;for(let I of j1(Z))if(!G1.call(R,I))l(R,I,{get:()=>Z[I],enumerable:!0});return R};var r=((Z)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(Z,{get:(k,Y)=>(typeof require!=="undefined"?require:k)[Y]}):Z)(function(Z){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+Z+'" is not supported')});import{AssetValue as p,Chain as v,MemoType as z1,ProviderName as H1,SwapKitError as S,TCAvalancheDepositABI as F1,TCBaseDepositABI as v1,TCBscDepositABI as D1,TCEthereumVaultAbi as E1,getMemoForLoan as K1}from"@swapkit/helpers";import{SwapKitApi as e}from"@swapkit/api";import{ApproveMode as t,AssetValue as s,Chain as d,EVMChains as U1,FeeOption as A,MemoType as a,SwapKitError as F,getMemoForDeposit as w,getMemoForLeaveAndBond as R1,getMemoForNamePreferredAssetRegister as N1,getMemoForNameRegister as k1,getMemoForSaverDeposit as O1,getMemoForSaverWithdraw as q1,getMemoForUnbond as L1,getMemoForWithdraw as x1,getMinAmountByChain as m,wrapWithThrow as c}from"@swapkit/helpers";var I1={[A.Average]:1.2,[A.Fast]:1.5,[A.Fastest]:2};function f1(Z){return async function k(Y){if(Z.type==="thorchain"&&Y===d.THORChain||Z.type==="mayachain"&&Y===d.Maya)return{gas_rate:"0",router:"",address:"",halted:!1,chain:Y};let I=(await e.getInboundAddresses(Z)).find((D)=>D.chain===Y);if(!I)throw new F("core_inbound_data_not_found");if(I?.halted)throw new F("core_chain_halted");return I}}function h({stagenet:Z,deposit:k,pluginChain:Y,getWallet:R}){let I=Y===d.Maya?"mayachain":"thorchain",D=f1({stagenet:Z,type:I});async function W({assetValue:z,type:H="checkOnly"}){let $=(await D(z.chain)).router,J=z.chain,Q=U1.includes(J);if(Q&&z.isGasAsset||!Q||z.isSynthetic)return Promise.resolve(H==="checkOnly"?!0:"approved");let G=R(J);if(!G)throw new F("core_wallet_connection_not_found");let O=H==="checkOnly"?G.isApproved:G.approve;if(!(z.address&&G.address))throw new F("core_approve_asset_address_or_from_not_found");return O({amount:z.getBaseValue("bigint"),assetAddress:z.address,from:G.address,spenderAddress:$})}async function E({memo:z,assetValue:H}){let $=await e.getMimirInfo({stagenet:Z,type:I});if($.HALTCHAINGLOBAL>=1||$.HALTTHORCHAIN>=1)throw new F("thorchain_chain_halted");return k({assetValue:H,recipient:"",memo:z})}async function f({assetValue:z,memo:H,feeOptionKey:$=A.Fast}){let{gas_rate:J="0",router:Q,address:_}=await D(z.chain);return k({assetValue:z,recipient:_,memo:H,router:Q,feeRate:Number.parseInt(J)*I1[$]})}function C(z){return W({...z,type:t.Approve})}function b(z){return W({...z,type:t.CheckOnly})}function q({assetValue:z,...H}){return E({assetValue:z,memo:k1(H)})}function L({assetValue:z,payoutAddress:H,name:$,ownerAddress:J}){let Q=H||R(z.chain)?.address;if(!Q)throw new F("thorchain_preferred_asset_payout_required");return E({assetValue:s.from({chain:Y}),memo:N1({asset:z.toString(),chain:z.chain,name:$,owner:J,payout:Q})})}function X({type:z,assetValue:H,address:$}){let J=z===a.UNBOND?L1({address:$,unbondAmount:H.getBaseValue("number")}):R1({type:z,address:$}),Q=z===a.BOND?H:m(Y);return E({memo:J,assetValue:Q})}async function U({baseAssetValue:z,assetValue:H}){if(z.lte(0)||H.lte(0))throw new F("core_transaction_create_liquidity_invalid_params");let $=R(H.chain).address,J=R(Y).address,Q=await c(()=>{return f({assetValue:z,memo:w({...H,address:$})})},"core_transaction_create_liquidity_base_error"),_=await c(()=>{return f({assetValue:H,memo:w({...H,address:J})})},"core_transaction_create_liquidity_asset_error");return{baseAssetTx:Q,assetTx:_}}function j({assetValue:z,poolAddress:H,address:$,symmetric:J}){if(J&&!$)throw new F("core_transaction_add_liquidity_invalid_params");let Q=w({chain:H.split(".")[0],symbol:H.split(".")[1],address:J?$:""});return f({assetValue:z,memo:Q})}async function B({baseAssetValue:z,assetValue:H,baseAssetAddr:$,assetAddr:J,isPendingSymmAsset:Q,mode:_="sym"}){let{chain:G,symbol:O}=H,K=_==="sym",M=z?.gt(0)&&(K||_==="baseAsset"),V=H?.gt(0)&&(K||_==="asset"),u=Q||M,Q1=R(Y).address,o=u?$||Q1:"",X1=K||_==="asset"?J||R(G).address:"";if(!(M||V))throw new F("core_transaction_add_liquidity_invalid_params");if(u&&!o)throw new F("core_transaction_add_liquidity_base_address");let Z1=M&&z?await c(()=>{return f({assetValue:z,memo:w({chain:G,symbol:O,address:X1})})},"core_transaction_add_liquidity_base_error"):void 0,$1=V&&H?await c(()=>{return f({assetValue:H,memo:w({chain:G,symbol:O,address:o})})},"core_transaction_add_liquidity_asset_error"):void 0;return{baseAssetTx:Z1,assetTx:$1}}function N({assetValue:z,memo:H,percent:$,type:J}){let{chain:Q,symbol:_}=z,G=J==="add",O=G?O1({symbol:_,chain:Q}):q1({basisPoints:Math.min(1e4,Math.round($*100)),symbol:_,chain:Q});return f({memo:H||O,assetValue:G?z:m(Q)})}function x({memo:z,assetValue:H,percent:$,from:J,to:Q}){let _=Q==="baseAsset"&&J!=="baseAsset"?s.from({chain:Y}):J==="sym"&&Q==="sym"||J==="baseAsset"||J==="asset"?void 0:H,G=m(J==="asset"?H.chain:Y),O=z||x1({symbol:H.symbol,chain:H.chain,ticker:H.ticker,basisPoints:Math.min(1e4,Math.round($*100)),targetAsset:_?.toString()});return f({assetValue:G,memo:O})}return{addLiquidity:B,addLiquidityPart:j,approveAssetValue:C,createLiquidity:U,depositToPool:f,getInboundDataByChain:D,isAssetValueApproved:b,nodeAction:X,register:q,registerPreferredAsset:L,savings:N,withdraw:x}}import{Chain as B1}from"@swapkit/helpers";var P=({chain:Z,address:k})=>{if(!k)return!1;switch(Z){case B1.Bitcoin:return!k.startsWith("bc1p");default:return!0}};function g({assetValue:Z,from:k,memo:Y="",...R}){return{...R,memo:Y,from:k,assetValue:Z}}function P1({getWallet:Z,stagenet:k=!1}){let{getInboundDataByChain:Y,register:R,depositToPool:I,addLiquidity:D,createLiquidity:W,...E}=h({getWallet:Z,pluginChain:v.THORChain,stagenet:k,deposit:f});async function f({assetValue:X,recipient:U,router:j,...B}){let{chain:N,symbol:x,ticker:z}=X,H=Z(N);if(!H)throw new S("core_wallet_connection_not_found");if(!P({address:H.address,chain:N}))throw new S("core_transaction_invalid_sender_address");let J=g({from:H.address,assetValue:X,recipient:U,router:j,...B});try{switch(N){case v.THORChain:{let Q=Z(N);return U===""?Q.deposit(J):Q.transfer(J)}case v.Ethereum:case v.BinanceSmartChain:case v.Base:case v.Avalanche:{let Q=Z(N),{getChecksumAddressFromAsset:_}=await import("@swapkit/toolbox-evm"),O={[v.Avalanche]:F1,[v.Base]:v1,[v.BinanceSmartChain]:D1,[v.Ethereum]:E1}[N];return Q.call({abi:O,contractAddress:j||(await Y(N)).router,funcName:"depositWithExpiry",funcParams:[U,_({chain:N,symbol:x,ticker:z},N),X.getBaseValue("string"),J.memo,B.expiration||Number.parseInt(`${(new Date().getTime()+900000)/1000}`)],txOverrides:{from:J.from,value:X.isGasAsset?X.getBaseValue("bigint"):void 0}})}default:{if(H)return H.transfer(J);throw new S("core_wallet_connection_not_found")}}}catch(Q){let _=typeof Q==="string"?Q.toLowerCase():Q?.message.toLowerCase(),G=_?.includes("insufficient funds"),O=_?.includes("gas"),K=_?.includes("server"),M=_?.includes("user rejected");throw new S(G?"core_transaction_deposit_insufficient_funds_error":O?"core_transaction_deposit_gas_error":K?"core_transaction_deposit_server_error":M?"core_transaction_user_rejected":"core_transaction_deposit_error",Q)}}function C({assetValue:X,memo:U,minAmount:j,type:B}){return I({assetValue:X,memo:U||K1(B==="open"?z1.OPEN_LOAN:z1.CLOSE_LOAN,{asset:X.toString(),minAmount:j.toString(),address:Z(X.chain).address})})}async function b({route:X,feeOptionKey:U}){if(!X)throw new S("core_swap_invalid_params");let{memo:j,expiration:B,targetAddress:N}=X,x=await p.from({asset:X.sellAsset,value:X.sellAmount,asyncTokenLookup:!0});if(!x)throw new S("core_swap_asset_not_recognized");if(!P({address:X.destinationAddress,chain:p.from({asset:X.buyAsset}).chain}))throw new S("core_transaction_invalid_recipient_address");let{address:H}=await Y(x.chain);return f({expiration:Number(B),assetValue:x,memo:j,feeOptionKey:U,router:N,recipient:H})}async function q(X){let{baseAssetTx:U,assetTx:j}=await D(X);return{runeTx:U,baseAssetTx:U,assetTx:j}}async function L(X){let{baseAssetTx:U,assetTx:j}=await W(X);return{runeTx:U,baseAssetTx:U,assetTx:j}}return{...E,addLiquidity:q,createLiquidity:L,deposit:f,getInboundDataByChain:Y,loan:C,registerTHORName:R,swap:b,supportedSwapkitProviders:[H1.THORCHAIN,H1.THORCHAIN_STREAMING],registerThorname:R}}var S1={thorchain:{plugin:P1}},m1=S1;import{AssetValue as n,Chain as y,MayaArbitrumVaultAbi as W1,MayaEthereumVaultAbi as M1,ProviderName as J1,SwapKitError as T}from"@swapkit/helpers";function T1({getWallet:Z,stagenet:k=!1}){let{getInboundDataByChain:Y,register:R,addLiquidity:I,createLiquidity:D,...W}=h({deposit:E,pluginChain:y.Maya,stagenet:k,getWallet:Z});async function E({assetValue:q,recipient:L,router:X,...U}){let{chain:j,symbol:B,ticker:N}=q,x=Z(j);if(!x)throw new T("core_wallet_connection_not_found");let z=x.address;if(!P({address:x.address,chain:j}))throw new T("core_transaction_invalid_sender_address");let $=g({from:z,assetValue:q,recipient:L,router:X,...U});try{switch(j){case y.Maya:{let J=Z(j);return L===""?J.deposit($):J.transfer($)}case y.Arbitrum:case y.Ethereum:{let{getChecksumAddressFromAsset:J}=await import("@swapkit/toolbox-evm"),Q=Z(j),_=j===y.Arbitrum?W1:M1,G=[L,J({chain:j,symbol:B,ticker:N},j),q.getBaseValue("string"),$.memo,U.expiration||Number.parseInt(`${(new Date().getTime()+900000)/1000}`)],O={from:$.from,value:q.isGasAsset?q.getBaseValue("bigint"):void 0};return await Q.call({abi:_,funcName:"depositWithExpiry",funcParams:G,txOverrides:O,contractAddress:X||(await Y(j)).router})}default:{if(x)return x.transfer($);throw new T("core_wallet_connection_not_found")}}}catch(J){let Q=typeof J==="string"?J.toLowerCase():J?.message.toLowerCase(),_=Q?.includes("insufficient funds"),G=Q?.includes("gas"),O=Q?.includes("server"),K=Q?.includes("user rejected");throw new T(_?"core_transaction_deposit_insufficient_funds_error":G?"core_transaction_deposit_gas_error":O?"core_transaction_deposit_server_error":K?"core_transaction_user_rejected":"core_transaction_deposit_error",J)}}async function f(q){let{feeOptionKey:L,route:X}=q,{memo:U,expiration:j,targetAddress:B}=X,N=await n.from({asset:X.sellAsset,value:X.sellAmount,asyncTokenLookup:!0}),x=N.chain;if(!N)throw new T("core_swap_asset_not_recognized");if(!P({address:X.destinationAddress,chain:n.from({asset:X.buyAsset}).chain}))throw new T("core_transaction_invalid_recipient_address");let{address:H}=await Y(x);return E({expiration:Number(j),assetValue:N,memo:U,feeOptionKey:L,router:B,recipient:H})}async function C(q){let{baseAssetTx:L,assetTx:X}=await I(q);return{cacaoTx:L,baseAssetTx:L,assetTx:X}}async function b(q){let{baseAssetTx:L,assetTx:X}=await D(q);return{cacaoTx:L,baseAssetTx:L,assetTx:X}}return{...W,addLiquidity:C,createLiquidity:b,getInboundDataByChain:Y,deposit:E,registerMAYAName:R,swap:f,supportedSwapkitProviders:[J1.MAYACHAIN,J1.MAYACHAIN_STREAMING],registerMayaname:R}}var o1={mayachain:{plugin:T1}};export{P as validateAddressType,m1 as ThorchainProvider,S1 as ThorchainPlugin,o1 as MayachainPlugin};

//# debugId=6122E0F8E99385FB64756E2164756E21
