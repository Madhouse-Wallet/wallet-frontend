{
  "version": 3,
  "sources": ["../src/tcPlugin.ts", "../src/basePlugin.ts", "../src/shared.ts", "../src/mayaPlugin.ts"],
  "sourcesContent": [
    "import type { QuoteResponseRoute } from \"@swapkit/api\";\nimport {\n  AssetValue,\n  Chain,\n  type EVMChain,\n  type ErrorKeys,\n  MemoType,\n  ProviderName,\n  SwapKitError,\n  type SwapKitPluginParams,\n  type SwapParams,\n  TCAvalancheDepositABI,\n  TCBaseDepositABI,\n  TCBscDepositABI,\n  TCEthereumVaultAbi,\n  type UTXOChain,\n  getMemoForLoan,\n} from \"@swapkit/helpers\";\n\nimport { basePlugin } from \"./basePlugin\";\nimport { prepareTxParams, validateAddressType } from \"./shared\";\nimport type { AddLiquidityParams, CoreTxParams, CreateLiquidityParams, LoanParams } from \"./types\";\n\ntype SupportedChain = EVMChain | Chain.THORChain | UTXOChain | Chain.Cosmos;\n\nfunction plugin({ getWallet, stagenet = false }: SwapKitPluginParams) {\n  const {\n    getInboundDataByChain,\n    register,\n    depositToPool,\n    addLiquidity: pluginAddLiquidity,\n    createLiquidity: pluginCreateLiquidity,\n    ...pluginMethods\n  } = basePlugin({\n    getWallet,\n    pluginChain: Chain.THORChain,\n    stagenet,\n    deposit,\n  });\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO refactor\n  async function deposit({\n    assetValue,\n    recipient,\n    router,\n    ...rest\n  }: CoreTxParams & { router?: string }) {\n    const { chain, symbol, ticker } = assetValue;\n\n    const wallet = getWallet(chain as SupportedChain);\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const isAddressValidated = validateAddressType({ address: wallet.address, chain });\n\n    if (!isAddressValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_sender_address\");\n    }\n\n    const params = prepareTxParams({\n      from: wallet.address,\n      assetValue,\n      recipient,\n      router,\n      ...rest,\n    });\n\n    try {\n      switch (chain) {\n        case Chain.THORChain: {\n          const wallet = getWallet(chain);\n          return recipient === \"\" ? wallet.deposit(params) : wallet.transfer(params);\n        }\n\n        case Chain.Ethereum:\n        case Chain.BinanceSmartChain:\n        case Chain.Base:\n        case Chain.Avalanche: {\n          const wallet = getWallet(chain);\n          const { getChecksumAddressFromAsset } = await import(\"@swapkit/toolbox-evm\");\n\n          const ChainSpecificAbi = {\n            [Chain.Avalanche]: TCAvalancheDepositABI,\n            [Chain.Base]: TCBaseDepositABI,\n            [Chain.BinanceSmartChain]: TCBscDepositABI,\n            [Chain.Ethereum]: TCEthereumVaultAbi,\n          };\n\n          const abi = ChainSpecificAbi[chain];\n\n          return wallet.call<string>({\n            abi,\n            contractAddress:\n              router || ((await getInboundDataByChain(chain as EVMChain)).router as string),\n            funcName: \"depositWithExpiry\",\n            funcParams: [\n              recipient,\n              getChecksumAddressFromAsset({ chain, symbol, ticker }, chain),\n              assetValue.getBaseValue(\"string\"),\n              params.memo,\n              rest.expiration ||\n                Number.parseInt(`${(new Date().getTime() + 15 * 60 * 1000) / 1000}`),\n            ],\n            txOverrides: {\n              from: params.from,\n              value: assetValue.isGasAsset ? assetValue.getBaseValue(\"bigint\") : undefined,\n            },\n          });\n        }\n\n        default: {\n          if (wallet) {\n            return wallet.transfer(params);\n          }\n\n          throw new SwapKitError(\"core_wallet_connection_not_found\");\n        }\n      }\n    } catch (error) {\n      const errorMessage =\n        // @ts-expect-error Fine to use error as string\n        typeof error === \"string\" ? error.toLowerCase() : error?.message.toLowerCase();\n      const isInsufficientFunds = errorMessage?.includes(\"insufficient funds\");\n      const isGas = errorMessage?.includes(\"gas\");\n      const isServer = errorMessage?.includes(\"server\");\n      const isUserRejected = errorMessage?.includes(\"user rejected\");\n      const errorKey: ErrorKeys = isInsufficientFunds\n        ? \"core_transaction_deposit_insufficient_funds_error\"\n        : isGas\n          ? \"core_transaction_deposit_gas_error\"\n          : isServer\n            ? \"core_transaction_deposit_server_error\"\n            : isUserRejected\n              ? \"core_transaction_user_rejected\"\n              : \"core_transaction_deposit_error\";\n\n      throw new SwapKitError(errorKey, error);\n    }\n  }\n\n  function loan({ assetValue, memo, minAmount, type }: LoanParams) {\n    return depositToPool({\n      assetValue,\n      memo:\n        memo ||\n        getMemoForLoan(type === \"open\" ? MemoType.OPEN_LOAN : MemoType.CLOSE_LOAN, {\n          asset: assetValue.toString(),\n          minAmount: minAmount.toString(),\n          address: getWallet(assetValue.chain as SupportedChain).address,\n        }),\n    });\n  }\n\n  async function swap({ route, feeOptionKey }: SwapParams<\"thorchain\", QuoteResponseRoute>) {\n    if (!route) throw new SwapKitError(\"core_swap_invalid_params\");\n\n    const { memo, expiration, targetAddress } = route;\n\n    const assetValue = await AssetValue.from({\n      asset: route.sellAsset,\n      value: route.sellAmount,\n      asyncTokenLookup: true,\n    });\n\n    if (!assetValue) {\n      throw new SwapKitError(\"core_swap_asset_not_recognized\");\n    }\n\n    const isRecipientValidated = validateAddressType({\n      address: route.destinationAddress,\n      chain: AssetValue.from({ asset: route.buyAsset }).chain,\n    });\n\n    if (!isRecipientValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_recipient_address\");\n    }\n\n    const { address: recipient } = await getInboundDataByChain(assetValue.chain);\n\n    return deposit({\n      expiration: Number(expiration),\n      assetValue,\n      memo,\n      feeOptionKey,\n      router: targetAddress,\n      recipient,\n    });\n  }\n\n  async function addLiquidity(params: AddLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginAddLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      runeTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  async function createLiquidity(params: CreateLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginCreateLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      runeTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  return {\n    ...pluginMethods,\n    addLiquidity,\n    createLiquidity,\n    deposit,\n    getInboundDataByChain,\n    loan,\n    registerTHORName: register,\n    swap,\n    supportedSwapkitProviders: [ProviderName.THORCHAIN, ProviderName.THORCHAIN_STREAMING],\n    /**\n     * @deprecated Use registerTHORName instead\n     */\n    registerThorname: register,\n  };\n}\n\nexport const ThorchainPlugin = { thorchain: { plugin } } as const;\n\n/**\n * @deprecated Use import { ThorchainPlugin } from \"@swapkit/plugin-thorchain\" instead\n */\nexport const ThorchainProvider = ThorchainPlugin;\n",
    "import { SwapKitApi, type ThornodeEndpointParams } from \"@swapkit/api\";\nimport {\n  ApproveMode,\n  type ApproveReturnType,\n  AssetValue,\n  Chain,\n  type EVMChain,\n  EVMChains,\n  FeeOption,\n  type FullWallet,\n  MemoType,\n  SwapKitError,\n  getMemoForDeposit,\n  getMemoForLeaveAndBond,\n  getMemoForNamePreferredAssetRegister,\n  getMemoForNameRegister,\n  getMemoForSaverDeposit,\n  getMemoForSaverWithdraw,\n  getMemoForUnbond,\n  getMemoForWithdraw,\n  getMinAmountByChain,\n  wrapWithThrow,\n} from \"@swapkit/helpers\";\n\nimport type {\n  AddLiquidityParams,\n  AddLiquidityPartParams,\n  ApproveParams,\n  CoreTxParams,\n  CreateLiquidityParams,\n  NodeActionParams,\n  RegisterThornameParams,\n  SavingsParams,\n  SupportedChain,\n  WithdrawParams,\n} from \"./types\";\n\nconst gasFeeMultiplier: Record<FeeOption, number> = {\n  [FeeOption.Average]: 1.2,\n  [FeeOption.Fast]: 1.5,\n  [FeeOption.Fastest]: 2,\n};\n\nfunction getInboundDataFunction(params: ThornodeEndpointParams) {\n  return async function getInboundDataByChain<T extends Chain>(chain: T) {\n    if (\n      (params.type === \"thorchain\" && chain === Chain.THORChain) ||\n      (params.type === \"mayachain\" && chain === Chain.Maya)\n    ) {\n      return { gas_rate: \"0\", router: \"\", address: \"\", halted: false, chain };\n    }\n\n    const inboundData = await SwapKitApi.getInboundAddresses(params);\n    const chainAddressData = inboundData.find((item) => item.chain === chain);\n\n    if (!chainAddressData) throw new SwapKitError(\"core_inbound_data_not_found\");\n    if (chainAddressData?.halted) throw new SwapKitError(\"core_chain_halted\");\n\n    return chainAddressData;\n  };\n}\n\nexport function basePlugin({\n  stagenet,\n  deposit,\n  pluginChain,\n  getWallet,\n}: {\n  deposit: (params: CoreTxParams & { router?: string }) => Promise<string>;\n  pluginChain: Chain.Maya | Chain.THORChain;\n  stagenet: boolean;\n  getWallet: <T extends SupportedChain>(chain: T) => FullWallet[T];\n}) {\n  const type = pluginChain === Chain.Maya ? \"mayachain\" : \"thorchain\";\n  const getInboundDataByChain = getInboundDataFunction({ stagenet, type });\n\n  async function approve<T extends ApproveMode>({\n    assetValue,\n    type = \"checkOnly\" as T,\n  }: { type: T; assetValue: AssetValue }) {\n    const router = (await getInboundDataByChain(assetValue.chain)).router as string;\n\n    const chain = assetValue.chain as EVMChain;\n\n    const isEVMChain = EVMChains.includes(chain as EVMChain);\n    const isNativeEVM = isEVMChain && assetValue.isGasAsset;\n\n    if (isNativeEVM || !isEVMChain || assetValue.isSynthetic) {\n      return Promise.resolve(type === \"checkOnly\" ? true : \"approved\") as ApproveReturnType<T>;\n    }\n\n    const wallet = getWallet(chain);\n\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const walletAction = type === \"checkOnly\" ? wallet.isApproved : wallet.approve;\n\n    if (!(assetValue.address && wallet.address)) {\n      throw new SwapKitError(\"core_approve_asset_address_or_from_not_found\");\n    }\n\n    return walletAction({\n      amount: assetValue.getBaseValue(\"bigint\"),\n      assetAddress: assetValue.address,\n      from: wallet.address,\n      spenderAddress: router,\n    });\n  }\n\n  async function depositToProtocol({ memo, assetValue }: { assetValue: AssetValue; memo: string }) {\n    const mimir = await SwapKitApi.getMimirInfo({ stagenet, type });\n\n    // check if trading is halted or not\n    if (mimir.HALTCHAINGLOBAL >= 1 || mimir.HALTTHORCHAIN >= 1) {\n      throw new SwapKitError(\"thorchain_chain_halted\");\n    }\n\n    return deposit({ assetValue, recipient: \"\", memo });\n  }\n\n  async function depositToPool({\n    assetValue,\n    memo,\n    feeOptionKey = FeeOption.Fast,\n  }: { assetValue: AssetValue; memo: string; feeOptionKey?: FeeOption }) {\n    const {\n      gas_rate = \"0\",\n      router,\n      address: poolAddress,\n    } = await getInboundDataByChain(assetValue.chain);\n\n    return deposit({\n      assetValue,\n      recipient: poolAddress,\n      memo,\n      router,\n      feeRate: Number.parseInt(gas_rate) * gasFeeMultiplier[feeOptionKey],\n    });\n  }\n\n  function approveAssetValue(params: ApproveParams) {\n    return approve({ ...params, type: ApproveMode.Approve });\n  }\n\n  function isAssetValueApproved(params: ApproveParams) {\n    return approve({ ...params, type: ApproveMode.CheckOnly });\n  }\n\n  function register({ assetValue, ...params }: RegisterThornameParams) {\n    return depositToProtocol({ assetValue, memo: getMemoForNameRegister(params) });\n  }\n\n  function registerPreferredAsset({\n    assetValue,\n    payoutAddress,\n    name,\n    ownerAddress,\n  }: {\n    assetValue: AssetValue;\n    payoutAddress?: string;\n    name: string;\n    ownerAddress: string;\n  }) {\n    const payout = payoutAddress || getWallet(assetValue.chain as SupportedChain)?.address;\n\n    if (!payout) {\n      throw new SwapKitError(\"thorchain_preferred_asset_payout_required\");\n    }\n\n    return depositToProtocol({\n      assetValue: AssetValue.from({ chain: pluginChain }),\n      memo: getMemoForNamePreferredAssetRegister({\n        asset: assetValue.toString(),\n        chain: assetValue.chain,\n        name,\n        owner: ownerAddress,\n        payout,\n      }),\n    });\n  }\n\n  function nodeAction({ type, assetValue, address }: NodeActionParams) {\n    const memo =\n      type === MemoType.UNBOND\n        ? getMemoForUnbond({ address, unbondAmount: assetValue.getBaseValue(\"number\") })\n        : getMemoForLeaveAndBond({ type, address });\n\n    const assetToTransfer = type === MemoType.BOND ? assetValue : getMinAmountByChain(pluginChain);\n    return depositToProtocol({ memo, assetValue: assetToTransfer });\n  }\n\n  async function createLiquidity({ baseAssetValue, assetValue }: CreateLiquidityParams) {\n    if (baseAssetValue.lte(0) || assetValue.lte(0)) {\n      throw new SwapKitError(\"core_transaction_create_liquidity_invalid_params\");\n    }\n\n    const assetAddress = getWallet(assetValue.chain as SupportedChain).address;\n    const baseAssetAddress = getWallet(pluginChain).address;\n\n    const baseAssetTx = await wrapWithThrow(() => {\n      return depositToPool({\n        assetValue: baseAssetValue,\n        memo: getMemoForDeposit({ ...assetValue, address: assetAddress }),\n      });\n    }, \"core_transaction_create_liquidity_base_error\");\n\n    const assetTx = await wrapWithThrow(() => {\n      return depositToPool({\n        assetValue,\n        memo: getMemoForDeposit({ ...assetValue, address: baseAssetAddress }),\n      });\n    }, \"core_transaction_create_liquidity_asset_error\");\n\n    return { baseAssetTx, assetTx };\n  }\n\n  function addLiquidityPart({\n    assetValue,\n    poolAddress,\n    address,\n    symmetric,\n  }: AddLiquidityPartParams) {\n    if (symmetric && !address) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_invalid_params\");\n    }\n    const memo = getMemoForDeposit({\n      chain: poolAddress.split(\".\")[0] as Chain,\n      symbol: poolAddress.split(\".\")[1] as string,\n      address: symmetric ? address : \"\",\n    });\n\n    return depositToPool({ assetValue, memo });\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO: Refactor\n  async function addLiquidity({\n    baseAssetValue,\n    assetValue,\n    baseAssetAddr,\n    assetAddr,\n    isPendingSymmAsset,\n    mode = \"sym\",\n  }: AddLiquidityParams) {\n    const { chain, symbol } = assetValue;\n    const isSym = mode === \"sym\";\n    const baseTransfer = baseAssetValue?.gt(0) && (isSym || mode === \"baseAsset\");\n    const assetTransfer = assetValue?.gt(0) && (isSym || mode === \"asset\");\n    const includeBaseAddress = isPendingSymmAsset || baseTransfer;\n    const baseAssetWalletAddress = getWallet(pluginChain).address;\n\n    const baseAddress = includeBaseAddress ? baseAssetAddr || baseAssetWalletAddress : \"\";\n    const assetAddress =\n      isSym || mode === \"asset\" ? assetAddr || getWallet(chain as SupportedChain).address : \"\";\n\n    if (!(baseTransfer || assetTransfer)) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_invalid_params\");\n    }\n    if (includeBaseAddress && !baseAddress) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_base_address\");\n    }\n\n    const baseAssetTx =\n      baseTransfer && baseAssetValue\n        ? await wrapWithThrow(() => {\n            return depositToPool({\n              assetValue: baseAssetValue,\n              memo: getMemoForDeposit({ chain, symbol, address: assetAddress }),\n            });\n          }, \"core_transaction_add_liquidity_base_error\")\n        : undefined;\n\n    const assetTx =\n      assetTransfer && assetValue\n        ? await wrapWithThrow(() => {\n            return depositToPool({\n              assetValue,\n              memo: getMemoForDeposit({ chain, symbol, address: baseAddress }),\n            });\n          }, \"core_transaction_add_liquidity_asset_error\")\n        : undefined;\n\n    return { baseAssetTx, assetTx };\n  }\n\n  function savings({ assetValue, memo, percent, type }: SavingsParams) {\n    const { chain, symbol } = assetValue;\n    const isDeposit = type === \"add\";\n    const memoString = isDeposit\n      ? getMemoForSaverDeposit({ symbol, chain })\n      : getMemoForSaverWithdraw({\n          basisPoints: Math.min(10000, Math.round(percent * 100)),\n          symbol,\n          chain,\n        });\n\n    return depositToPool({\n      memo: memo || memoString,\n      assetValue: isDeposit ? assetValue : getMinAmountByChain(chain),\n    });\n  }\n\n  function withdraw({ memo, assetValue, percent, from, to }: WithdrawParams) {\n    const targetAsset =\n      to === \"baseAsset\" && from !== \"baseAsset\"\n        ? AssetValue.from({ chain: pluginChain })\n        : (from === \"sym\" && to === \"sym\") || from === \"baseAsset\" || from === \"asset\"\n          ? undefined\n          : assetValue;\n\n    const value = getMinAmountByChain(from === \"asset\" ? assetValue.chain : pluginChain);\n    const memoString =\n      memo ||\n      getMemoForWithdraw({\n        symbol: assetValue.symbol,\n        chain: assetValue.chain,\n        ticker: assetValue.ticker,\n        basisPoints: Math.min(10000, Math.round(percent * 100)),\n        targetAsset: targetAsset?.toString(),\n      });\n\n    return depositToPool({ assetValue: value, memo: memoString });\n  }\n\n  return {\n    addLiquidity,\n    addLiquidityPart,\n    approveAssetValue,\n    createLiquidity,\n    depositToPool,\n    getInboundDataByChain,\n    isAssetValueApproved,\n    nodeAction,\n    register,\n    registerPreferredAsset,\n    savings,\n    withdraw,\n  };\n}\n",
    "import { Chain } from \"@swapkit/helpers\";\nimport type { CoreTxParams } from \"./types\";\n\nexport const validateAddressType = ({\n  chain,\n  address,\n}: {\n  chain?: Chain;\n  address?: string;\n}) => {\n  if (!address) return false;\n\n  switch (chain) {\n    case Chain.Bitcoin:\n      // filter out taproot addresses\n      return !address.startsWith(\"bc1p\");\n    default:\n      return true;\n  }\n};\n\nexport function prepareTxParams({\n  assetValue,\n  from,\n  memo = \"\",\n  ...restTxParams\n}: CoreTxParams & { from: string; router?: string }) {\n  return {\n    ...restTxParams,\n    memo,\n    from,\n    assetValue,\n  };\n}\n",
    "import type { QuoteResponseRoute } from \"@swapkit/api\";\nimport {\n  AssetValue,\n  Chain,\n  type CosmosChain,\n  type EVMChain,\n  type ErrorKeys,\n  MayaArbitrumVaultAbi,\n  MayaEthereumVaultAbi,\n  ProviderName,\n  SwapKitError,\n  type SwapKitPluginParams,\n  type SwapParams,\n  type UTXOChain,\n} from \"@swapkit/helpers\";\nimport { basePlugin } from \"./basePlugin\";\nimport { prepareTxParams, validateAddressType } from \"./shared\";\nimport type { AddLiquidityParams, CoreTxParams, CreateLiquidityParams } from \"./types\";\n\ntype SupportedChain = EVMChain | CosmosChain | UTXOChain;\n\nfunction plugin({ getWallet, stagenet = false }: SwapKitPluginParams) {\n  const {\n    getInboundDataByChain,\n    register,\n    addLiquidity: pluginAddLiquidity,\n    createLiquidity: pluginCreateLiquidity,\n    ...pluginMethods\n  } = basePlugin({\n    deposit,\n    pluginChain: Chain.Maya,\n    stagenet,\n    getWallet,\n  });\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO refactor\n  async function deposit({\n    assetValue,\n    recipient,\n    router,\n    ...rest\n  }: CoreTxParams & { router?: string; destinationChain?: Chain }) {\n    const { chain, symbol, ticker } = assetValue;\n\n    const wallet = getWallet(chain as SupportedChain);\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const address = wallet.address;\n\n    const isAddressValidated = validateAddressType({ address: wallet.address, chain });\n\n    if (!isAddressValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_sender_address\");\n    }\n\n    const params = prepareTxParams({ from: address, assetValue, recipient, router, ...rest });\n\n    try {\n      switch (chain) {\n        case Chain.Maya: {\n          const wallet = getWallet(chain);\n          return recipient === \"\" ? wallet.deposit(params) : wallet.transfer(params);\n        }\n\n        case Chain.Arbitrum:\n        case Chain.Ethereum: {\n          const { getChecksumAddressFromAsset } = await import(\"@swapkit/toolbox-evm\");\n          const wallet = getWallet(chain);\n\n          const abi = chain === Chain.Arbitrum ? MayaArbitrumVaultAbi : MayaEthereumVaultAbi;\n          const funcParams = [\n            recipient,\n            getChecksumAddressFromAsset({ chain, symbol, ticker }, chain),\n            assetValue.getBaseValue(\"string\"),\n            params.memo,\n            rest.expiration || Number.parseInt(`${(new Date().getTime() + 15 * 60 * 1000) / 1000}`),\n          ];\n          const txOverrides = {\n            from: params.from,\n            value: assetValue.isGasAsset ? assetValue.getBaseValue(\"bigint\") : undefined,\n          };\n\n          const tx = await wallet.call<string>({\n            abi,\n            funcName: \"depositWithExpiry\",\n            funcParams,\n            txOverrides,\n            contractAddress:\n              router || ((await getInboundDataByChain(chain as EVMChain)).router as string),\n          });\n\n          return tx;\n        }\n\n        default: {\n          if (wallet) {\n            return wallet.transfer(params);\n          }\n\n          throw new SwapKitError(\"core_wallet_connection_not_found\");\n        }\n      }\n    } catch (error) {\n      const errorMessage =\n        // @ts-expect-error Fine to use error as string\n        typeof error === \"string\" ? error.toLowerCase() : error?.message.toLowerCase();\n      const isInsufficientFunds = errorMessage?.includes(\"insufficient funds\");\n      const isGas = errorMessage?.includes(\"gas\");\n      const isServer = errorMessage?.includes(\"server\");\n      const isUserRejected = errorMessage?.includes(\"user rejected\");\n      const errorKey: ErrorKeys = isInsufficientFunds\n        ? \"core_transaction_deposit_insufficient_funds_error\"\n        : isGas\n          ? \"core_transaction_deposit_gas_error\"\n          : isServer\n            ? \"core_transaction_deposit_server_error\"\n            : isUserRejected\n              ? \"core_transaction_user_rejected\"\n              : \"core_transaction_deposit_error\";\n\n      throw new SwapKitError(errorKey, error);\n    }\n  }\n\n  async function swap(swapParams: SwapParams<\"mayaprotocol\", QuoteResponseRoute>) {\n    const { feeOptionKey, route } = swapParams;\n\n    const { memo, expiration, targetAddress } = route;\n\n    const assetValue = await AssetValue.from({\n      asset: route.sellAsset,\n      value: route.sellAmount,\n      asyncTokenLookup: true,\n    });\n    const evmChain = assetValue.chain;\n\n    if (!assetValue) {\n      throw new SwapKitError(\"core_swap_asset_not_recognized\");\n    }\n\n    const isRecipientValidated = validateAddressType({\n      address: route.destinationAddress,\n      chain: AssetValue.from({ asset: route.buyAsset }).chain,\n    });\n\n    if (!isRecipientValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_recipient_address\");\n    }\n\n    const { address: recipient } = await getInboundDataByChain(evmChain);\n\n    return deposit({\n      expiration: Number(expiration),\n      assetValue,\n      memo,\n      feeOptionKey,\n      router: targetAddress,\n      recipient,\n    });\n  }\n\n  async function addLiquidity(params: AddLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginAddLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      cacaoTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  async function createLiquidity(params: CreateLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginCreateLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      cacaoTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  return {\n    ...pluginMethods,\n    addLiquidity,\n    createLiquidity,\n    getInboundDataByChain,\n    deposit,\n    registerMAYAName: register,\n    swap,\n    supportedSwapkitProviders: [ProviderName.MAYACHAIN, ProviderName.MAYACHAIN_STREAMING],\n    /**\n     * @deprecated use registerMAYAName instead\n     */\n    registerMayaname: register,\n  };\n}\n\nexport const MayachainPlugin = { mayachain: { plugin } } as const;\n"
  ],
  "mappings": "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",
  "debugId": "6122E0F8E99385FB64756E2164756E21",
  "names": []
}