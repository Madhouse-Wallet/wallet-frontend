{
  "version": 3,
  "sources": ["../src/types/index.ts", "../src/toolbox.ts"],
  "sourcesContent": [
    "import { Chain } from \"@swapkit/helpers\";\nimport type { RadixToolbox } from \"../index\";\n\nexport const RadixMainnet = {\n  networkId: 1,\n  networkName: \"mainnet\",\n  dashboardBase: \"https://dashboard.radixdlt.com\",\n};\n\nexport type RadixNetwork = typeof RadixMainnet;\n\nexport type RadixWallets = {\n  [Chain.Radix]: Awaited<ReturnType<typeof RadixToolbox>>;\n};\n",
    "import {\n  type FungibleResourcesCollectionItem,\n  GatewayApiClient,\n  type StateEntityDetailsVaultResponseItem,\n  type StateEntityFungiblesPageRequest,\n  type StateEntityFungiblesPageResponse,\n} from \"@radixdlt/babylon-gateway-api-sdk\";\nimport { RadixDappToolkit } from \"@radixdlt/radix-dapp-toolkit\";\n\n// import {\n//   Convert,\n//   type Instructions,\n//   type Intent,\n//   LTSRadixEngineToolkit,\n//   ManifestBuilder,\n//   type Message,\n//   type NotarizedTransaction,\n//   PrivateKey,\n//   type PublicKey,\n//   RadixEngineToolkit,\n//   type Signature,\n//   type SignatureWithPublicKey,\n//   TransactionBuilder,\n//   type TransactionManifest,\n//   address,\n//   bucket,\n//   decimal,\n//   enumeration,\n//   generateRandomNonce,\n// } from \"@radixdlt/radix-engine-toolkit\";\nimport { AssetValue, Chain } from \"@swapkit/helpers\";\nimport type { RadixNetwork } from \"./types\";\n\ntype RadixGetBalanceParams = {\n  address: string;\n  networkApi: GatewayApiClient;\n};\n// #endregion\n\n// async function fetchNFTBalances(address: string): Promise<Balance[]> {\n//   const nonFungibleResources = await this.fetchNonFungibleResources(address);\n//   const nonFungibleBalances = this.convertResourcesToBalances(nonFungibleResources);\n//   return nonFungibleBalances;\n// }\n\n// async function fetchNonFungibleResources(\n//   address: string,\n// ): Promise<NonFungibleResourcesCollectionItem[]> {\n//   let hasNextPage = true;\n//   let nextCursor = undefined;\n//   const stateVersion = await currentStateVersion();\n//   let nonFungibleResources: NonFungibleResourcesCollectionItem[] = [];\n\n//   while (hasNextPage) {\n//     const stateEntityNonFungiblesPageRequest: StateEntityNonFungiblesPageRequest = {\n//       address: address,\n//       limit_per_page: 5,\n//       cursor: nextCursor,\n//       at_ledger_state: {\n//         state_version: stateVersion,\n//       },\n//     };\n\n//     const stateEntityNonFungiblesPageResponse: StateEntityNonFungiblesPageResponse =\n//       await gatewayClient.state.innerClient.entityNonFungiblesPage({\n//         stateEntityNonFungiblesPageRequest: stateEntityNonFungiblesPageRequest,\n//       });\n//     nonFungibleResources = nonFungibleResources.concat(stateEntityNonFungiblesPageResponse.items);\n//     if (stateEntityNonFungiblesPageResponse.next_cursor) {\n//       nextCursor = stateEntityNonFungiblesPageResponse.next_cursor;\n//     } else {\n//       hasNextPage = false;\n//     }\n//   }\n//   return nonFungibleResources;\n// }\n\n// #endregion Public Methods\n\n// #region Private Methods\n// function createGatewayClient(network: number): GatewayApiClient {\n//   const applicationName = \"xchainjs\";\n//   return GatewayApiClient.initialize({\n//     networkId: network,\n//     applicationName,\n//   });\n// }\n\n// async function previewIntent({\n//   intent,\n//   network,\n//   networkApi,\n// }: {\n//   intent: Intent;\n//   network: RadixNetwork;\n//   networkApi: GatewayApiClient;\n// }): Promise<TransactionPreviewResponse> {\n//   // Translate the RET models to the gateway models for preview.\n//   const request: TransactionPreviewOperationRequest = {\n//     transactionPreviewRequest: {\n//       manifest: await RadixEngineToolkit.Instructions.convert(\n//         intent.manifest.instructions,\n//         network.networkId,\n//         \"String\",\n//       ).then((instructions) => instructions.value as string),\n//       blobs_hex: [],\n//       start_epoch_inclusive: intent.header.startEpochInclusive,\n//       end_epoch_exclusive: intent.header.endEpochExclusive,\n//       notary_public_key: retPublicKeyToGatewayPublicKey(intent.header.notaryPublicKey),\n//       notary_is_signatory: intent.header.notaryIsSignatory,\n//       tip_percentage: intent.header.tipPercentage,\n//       nonce: intent.header.nonce,\n//       signer_public_keys: [retPublicKeyToGatewayPublicKey(intent.header.notaryPublicKey)],\n//       // TODO: Add message\n//       flags: {\n//         assume_all_signature_proofs: false,\n//         skip_epoch_check: false,\n//         use_free_credit: false,\n//       },\n//     },\n//   };\n\n//   return networkApi.transaction.innerClient.transactionPreview(request);\n// }\n\n// function retPublicKeyToGatewayPublicKey(publicKey: PublicKey): GatewayPublicKey {\n//   switch (publicKey.curve) {\n//     case \"Secp256k1\":\n//       return {\n//         key_type: \"EcdsaSecp256k1\",\n//         key_hex: publicKey.hex(),\n//       };\n//     case \"Ed25519\":\n//       return {\n//         key_type: \"EddsaEd25519\",\n//         key_hex: publicKey.hex(),\n//       };\n//   }\n// }\n\n// export type RadixSigner = {\n//   getAddress?: () => Promise<string>;\n//   publicKey(): PublicKey;\n//   publicKeyBytes(): Uint8Array;\n//   publicKeyHex(): string;\n//   sign(messageHash: Uint8Array): Uint8Array;\n//   signToSignature(messageHash: Uint8Array): Signature;\n//   signToSignatureWithPublicKey(messageHash: Uint8Array): SignatureWithPublicKey;\n// };\n\n// export async function createPrivateKey(phrase: string) {\n//   const seed = await mnemonicToSeed(phrase);\n\n//   return new PrivateKey.Ed25519(seed.slice(0, 32));\n// }\n\n// function getAddress(signer: RadixSigner, network: RadixNetwork) {\n//   return LTSRadixEngineToolkit.Derive.virtualAccountAddress(signer.publicKey(), network.networkId);\n// }\n\n// Could not find anything sync in SDK, ask Radix team\nexport function validateAddress(address: string) {\n  return address.startsWith(\"account_rdx1\") && address.length === 66;\n}\n\nfunction getBalance({ networkApi }: { networkApi: GatewayApiClient }) {\n  return async function getBalance(address: string) {\n    const fungibleResources = await fetchFungibleResources({ address, networkApi });\n    const fungibleBalances = convertResourcesToBalances({\n      resources: fungibleResources,\n      networkApi,\n    });\n    return fungibleBalances;\n  };\n}\n\nasync function fetchFungibleResources({\n  address,\n  networkApi,\n}: RadixGetBalanceParams): Promise<FungibleResourcesCollectionItem[]> {\n  let hasNextPage = true;\n  let nextCursor = undefined;\n  let fungibleResources: FungibleResourcesCollectionItem[] = [];\n  const stateVersion = await currentStateVersion(networkApi);\n  while (hasNextPage) {\n    const stateEntityFungiblesPageRequest: StateEntityFungiblesPageRequest = {\n      address: address,\n      limit_per_page: 100,\n      cursor: nextCursor,\n      at_ledger_state: {\n        state_version: stateVersion,\n      },\n    };\n\n    const stateEntityFungiblesPageResponse: StateEntityFungiblesPageResponse =\n      await networkApi.state.innerClient.entityFungiblesPage({\n        stateEntityFungiblesPageRequest: stateEntityFungiblesPageRequest,\n      });\n\n    fungibleResources = fungibleResources.concat(stateEntityFungiblesPageResponse.items);\n    if (stateEntityFungiblesPageResponse.next_cursor) {\n      nextCursor = stateEntityFungiblesPageResponse.next_cursor;\n    } else {\n      hasNextPage = false;\n    }\n  }\n  return fungibleResources;\n}\n\n// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: <explanation>\nasync function convertResourcesToBalances({\n  resources,\n  networkApi,\n}: {\n  resources: FungibleResourcesCollectionItem[]; //| NonFungibleResourcesCollectionItem[];\n  networkApi: GatewayApiClient;\n}): Promise<AssetValue[]> {\n  const balances: AssetValue[] = [];\n  const BATCH_SIZE = 50;\n\n  // Split resources into batches of up to 50 items\n  const resourceBatches = [];\n  for (let i = 0; i < resources.length; i += BATCH_SIZE) {\n    resourceBatches.push(resources.slice(i, i + BATCH_SIZE));\n  }\n\n  for (const batch of resourceBatches) {\n    const addresses = batch.map((item) => item.resource_address);\n    const response: StateEntityDetailsVaultResponseItem[] =\n      await networkApi.state.getEntityDetailsVaultAggregated(addresses);\n\n    const divisibilities = new Map<string, { decimals: number; symbol: string }>();\n\n    for (const result of response) {\n      if (result.details !== undefined) {\n        const metaDataSymbol = result.metadata?.items.find((item) => item.key === \"symbol\");\n        const symbol =\n          metaDataSymbol?.value.typed.type === \"String\" ? metaDataSymbol.value.typed.value : \"?\";\n\n        if (result.details.type === \"FungibleResource\") {\n          divisibilities.set(result.address, {\n            decimals: result.details.divisibility,\n            symbol,\n          });\n        }\n      }\n    }\n\n    for (const item of batch) {\n      if (item.aggregation_level === \"Global\") {\n        const assetInfo = divisibilities.get(item.resource_address) || { decimals: 0, symbol: \"?\" };\n\n        const balance = AssetValue.from({\n          asset:\n            assetInfo.symbol !== Chain.Radix\n              ? `${Chain.Radix}.${assetInfo.symbol}-${item.resource_address}`\n              : \"XRD.XRD\",\n          value: item.amount,\n        });\n        balances.push(balance);\n      }\n    }\n  }\n  // Iterate through resources\n  return balances;\n}\n\n// function getCurrentEpoch(networkApi: GatewayApiClient) {\n//   return networkApi.status.getCurrent().then((status) => status.ledger_state.epoch);\n// }\n\nasync function currentStateVersion(networkApi: GatewayApiClient) {\n  return networkApi.status.getCurrent().then((status) => status.ledger_state.state_version);\n}\n\n// function constructSimpleTransferIntent({\n//   networkApi,\n//   network = RadixMainnet,\n// }: {\n//   networkApi: GatewayApiClient;\n//   network: RadixNetwork;\n// }) {\n//   // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: <explanation>\n//   return async function constructSimpleTransferIntent(\n//     params:\n//       | {\n//           from: string;\n//           recipient: string;\n//           assetValue: AssetValue;\n//           notaryPublicKey: PublicKey;\n//           memo: string;\n//         }\n//       | { manifest: string | TransactionManifest; notaryPublicKey: PublicKey },\n//   ): Promise<{ intent: Intent; fees: number }> {\n//     const nonce = generateRandomNonce();\n\n//     const { notaryPublicKey } = params;\n\n//     const from = \"from\" in params ? params.from : undefined;\n//     const recipient = \"recipient\" in params ? params.recipient : undefined;\n//     const assetValue = \"assetValue\" in params ? params.assetValue : undefined;\n//     const memo = \"memo\" in params ? params.memo : undefined;\n//     // Construct the intent with a random fee lock, say 5 XRD and then create a transaction intent\n//     // from it.\n\n//     const manifestWithHardcodedFee =\n//       \"manifest\" in params\n//         ? typeof params.manifest === \"string\"\n//           ? ({\n//               instructions: await convertManifestToInstructions({ network })(params.manifest),\n//               blobs: [],\n//             } as TransactionManifest)\n//           : params.manifest\n//         : from && recipient && assetValue\n//           ? simpleTransferManifest({\n//               from,\n//               recipient,\n//               assetValue,\n//               fees: AssetValue.from({\n//                 asset: \"XRD.XRD\",\n//                 value: \"5\",\n//               }),\n//             })\n//           : undefined;\n\n//     if (!manifestWithHardcodedFee) {\n//       throw new Error(\"Manifest is required\");\n//     }\n\n//     const intentWithHardcodedFee = await constructIntent({\n//       manifest: manifestWithHardcodedFee,\n//       message: memo\n//         ? {\n//             kind: \"PlainText\",\n//             value: { mimeType: \"text/plain\", message: { kind: \"String\", value: memo } },\n//           }\n//         : { kind: \"None\" },\n//       nonce,\n//       notaryPublicKey,\n//       networkApi,\n//       network,\n//     });\n\n//     const previewReceipt = await previewIntent({\n//       intent: intentWithHardcodedFee,\n//       network,\n//       networkApi,\n//     });\n//     // Ensure that the preview was successful.\n//     // @ts-expect-error\n//     if (previewReceipt.receipt.status !== \"Succeeded\") {\n//       throw new Error(\"Preview for fees was not successful\");\n//     }\n\n//     // Calculate the total fees\n//     const totalFees = [\n//       // @ts-expect-error\n//       previewReceipt.receipt.fee_summary.xrd_total_execution_cost,\n//       // @ts-expect-error\n//       previewReceipt.receipt.fee_summary.xrd_total_finalization_cost,\n//       // @ts-expect-error\n//       previewReceipt.receipt.fee_summary.xrd_total_royalty_cost,\n//       // @ts-expect-error\n//       previewReceipt.receipt.fee_summary.xrd_total_storage_cost,\n//       // @ts-expect-error\n//       previewReceipt.receipt.fee_summary.xrd_total_tipping_cost,\n//     ]\n//       .map(Number.parseFloat)\n//       .reduce((acc, item) => acc + item, 0);\n\n//     // We need to add another 10% to the fees as the preview response does not include everything needed\n//     // to actually submit the transaction, ie: signature validation\n\n//     // Construct a new intent with the calculated fees.\n//     const manifest =\n//       \"manifest\" in params\n//         ? typeof params.manifest === \"string\"\n//           ? ({\n//               instructions: await convertManifestToInstructions({ network })(params.manifest),\n//               blobs: [],\n//             } as TransactionManifest)\n//           : params.manifest\n//         : from && recipient && assetValue\n//           ? simpleTransferManifest({\n//               from,\n//               recipient,\n//               assetValue,\n//               fees: new SwapKitNumber(totalFees).mul(1.1),\n//             })\n//           : undefined;\n\n//     if (!manifest) {\n//       throw new Error(\"Manifest is required\");\n//     }\n\n//     const intent = await constructIntent({\n//       manifest,\n//       message: memo\n//         ? {\n//             kind: \"PlainText\",\n//             value: {\n//               mimeType: \"text/plain\",\n//               message: { kind: \"String\", value: memo },\n//             },\n//           }\n//         : { kind: \"None\" },\n//       nonce,\n//       notaryPublicKey,\n//       network,\n//       networkApi,\n//     });\n\n//     return {\n//       intent,\n//       fees: totalFees,\n//     };\n//   };\n// }\n\n// function simpleTransferManifest({\n//   from,\n//   recipient,\n//   assetValue,\n//   fees,\n// }: {\n//   from: string;\n//   recipient: string;\n//   assetValue: AssetValue;\n//   fees: SwapKitNumber;\n// }): TransactionManifest {\n//   if (assetValue.address === undefined) {\n//     throw new Error(\"Asset value must have an address\");\n//   }\n\n//   return new ManifestBuilder()\n//     .callMethod(from, \"lock_fee\", [decimal(fees.getValue(\"string\"))])\n//     .callMethod(from, \"withdraw\", [\n//       address(assetValue.address),\n//       decimal(assetValue.getValue(\"string\")),\n//     ])\n//     .takeFromWorktop(\n//       assetValue.address,\n//       decimal(assetValue.getValue(\"string\")).value,\n//       (builder, bucketId) => {\n//         return builder.callMethod(recipient, \"try_deposit_or_abort\", [\n//           bucket(bucketId),\n//           enumeration(0),\n//         ]);\n//       },\n//     )\n//     .build();\n// }\n\n// async function constructIntent({\n//   manifest,\n//   message,\n//   nonce,\n//   notaryPublicKey,\n//   networkApi,\n//   network,\n// }: {\n//   manifest: TransactionManifest;\n//   message: Message;\n//   nonce: number;\n//   notaryPublicKey: PublicKey;\n//   networkApi: GatewayApiClient;\n//   network: RadixNetwork;\n// }): Promise<Intent> {\n//   const epoch = await getCurrentEpoch(networkApi);\n//   return {\n//     header: {\n//       networkId: network.networkId,\n//       startEpochInclusive: epoch,\n//       endEpochExclusive: epoch + 10,\n//       nonce,\n//       notaryPublicKey,\n//       notaryIsSignatory: true,\n//       tipPercentage: 0,\n//     },\n//     manifest,\n//     message,\n//   };\n// }\n\n// function transfer({\n//   signer,\n//   networkApi,\n//   network = RadixMainnet,\n// }: {\n//   signer?: RadixSigner;\n//   networkApi: GatewayApiClient;\n//   network?: RadixNetwork;\n// }) {\n//   return async function transfer({\n//     assetValue: unsafeAssetValue,\n//     from,\n//     recipient,\n//     memo = \"\",\n//   }: { assetValue: AssetValue; from: string; recipient: string; memo?: string }) {\n//     if (!signer) throw new SwapKitError(\"toolbox_radix_signer_not_defined\");\n\n//     const assetValue =\n//       unsafeAssetValue.toString() === \"XRD.XRD\"\n//         ? AssetValue.from({\n//             asset: \"XRD.XRD-resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd\",\n//             value: unsafeAssetValue.getValue(\"string\"),\n//           })\n//         : unsafeAssetValue;\n\n//     if (!assetValue.address) throw new Error(\"Asset value must have an address\");\n\n//     const publicKey = signer.publicKey();\n//     const intent = (\n//       await constructSimpleTransferIntent({\n//         network,\n//         networkApi,\n//       })({ from, recipient, assetValue, memo, notaryPublicKey: publicKey })\n//     ).intent;\n\n//     const compiledIntent = await RadixEngineToolkit.Intent.compile(intent);\n\n//     const notarySignature = signer.signToSignature(compiledIntent);\n\n//     const notarizedTransaction = await TransactionBuilder.new().then((builder) => {\n//       return builder\n//         .header(intent.header)\n//         .message(intent.message)\n//         .manifest(intent.manifest)\n//         .notarize(notarySignature);\n//     });\n\n//     const notarizedTransactionBytes =\n//       await RadixEngineToolkit.NotarizedTransaction.compile(notarizedTransaction);\n//     const hash = await broadcastTransaction({\n//       networkApi,\n//     })(Convert.Uint8Array.toHexString(notarizedTransactionBytes));\n//     return hash;\n//   };\n\n//     const constructionMetadata = await net.LTS.getConstructionMetadata();\n//     const builder = await SimpleTransactionBuilder.new({\n//       networkId: network.networkId,\n//       validFromEpoch: constructionMetadata.current_epoch,\n//       fromAccount: from,\n//       signerPublicKey: signer.publicKey(),\n//     });\n\n//     const unsignedTransaction = builder\n//       .transferFungible({\n//         toAccount: recipient,\n//         resourceAddress: assetValue.address,\n//         amount: assetValue.getBaseValue(\"number\"),\n//       })\n//       .compileIntent();\n\n//     const intentHashTransactionId = notarizedTransaction.transactionId.id;\n\n//     try {\n//       await api.LTS.submitTransaction({\n//         notarized_transaction_hex: notarizedTransaction.toHex(),\n//       });\n//     } catch (error) {\n//       throw new Error(`Failed to submit transaction: ${error}`);\n//     }\n\n//     return intentHashTransactionId;\n//   };\n// }\n\n// function broadcastTransaction({\n//   networkApi,\n// }: {\n//   networkApi: GatewayApiClient;\n// }) {\n//   return async function broadcastTransaction(tx: NotarizedTransaction | string) {\n//     const txToBroadcast: NotarizedTransaction =\n//       typeof tx === \"string\"\n//         ? await RadixEngineToolkit.NotarizedTransaction.decompile(\n//             Convert.HexString.toUint8Array(tx),\n//           )\n//         : tx;\n//     const intentHash = await RadixEngineToolkit.NotarizedTransaction.intentHash(txToBroadcast);\n//     const transactionHex = await RadixEngineToolkit.NotarizedTransaction.compile(\n//       txToBroadcast,\n//     ).then(Convert.Uint8Array.toHexString);\n//     await networkApi.transaction.innerClient.transactionSubmit({\n//       transactionSubmitRequest: { notarized_transaction_hex: transactionHex },\n//     });\n\n//     return intentHash.id;\n//   };\n// }\n\n// export function convertManifestToInstructions({ network }: { network: RadixNetwork }) {\n//   return function convertManifestToInstructions(transactionManifest: string) {\n//     return RadixEngineToolkit.Instructions.convert(\n//       {\n//         kind: \"String\",\n//         value: transactionManifest,\n//       },\n//       network.networkId,\n//       \"Parsed\",\n//     );\n//   };\n// }\n\n// export function convertInstructionsToManifest({ network }: { network: RadixNetwork }) {\n//   return function convertInstructionsToManifest(transactionManifest: Instructions) {\n//     return RadixEngineToolkit.Instructions.convert(\n//       transactionManifest,\n//       network.networkId,\n//       \"String\",\n//     );\n//   };\n// }\n\n// function signAndBroadcast({\n//   signer,\n//   networkApi,\n//   network = RadixMainnet,\n// }: {\n//   signer?: RadixSigner;\n//   networkApi: GatewayApiClient;\n//   network?: RadixNetwork;\n// }) {\n//   return async function signAndBroadcast({ manifest }: { manifest: string | TransactionManifest }) {\n//     if (!signer) throw new SwapKitError(\"toolbox_radix_signer_not_defined\");\n//     const publicKey = signer.publicKey();\n//     const intent = (\n//       await constructSimpleTransferIntent({\n//         network,\n//         networkApi,\n//       })({ manifest, notaryPublicKey: publicKey })\n//     ).intent;\n\n//     const compiledIntent = await RadixEngineToolkit.Intent.compile(intent);\n\n//     const notarySignature = signer.signToSignature(compiledIntent);\n\n//     const notarizedTransaction = await TransactionBuilder.new().then((builder) => {\n//       return builder\n//         .header(intent.header)\n//         .message(intent.message)\n//         .manifest(intent.manifest)\n//         .notarize(notarySignature);\n//     });\n\n//     const notarizedTransactionBytes =\n//       await RadixEngineToolkit.NotarizedTransaction.compile(notarizedTransaction);\n//     const transactionId = await broadcastTransaction({\n//       networkApi,\n//     })(Convert.Uint8Array.toHexString(notarizedTransactionBytes));\n//     return transactionId;\n//   };\n// }\n\nexport const RadixToolbox = async ({\n  dappConfig,\n}: {\n  dappConfig: {\n    network?: RadixNetwork;\n    dAppDefinitionAddress: string;\n    applicationName: string;\n    applicationVersion: string;\n  };\n}) => {\n  const radixToolkit = RadixDappToolkit({\n    ...dappConfig,\n    networkId: dappConfig.network?.networkId || 1,\n  });\n\n  const networkApi = GatewayApiClient.initialize(radixToolkit.gatewayApi.clientConfig);\n\n  return {\n    networkApi,\n    getBalance: getBalance({ networkApi }),\n    getAddress: () => {\n      return \"\";\n    },\n    validateAddress,\n    signAndBroadcast: (() => {\n      throw new Error(\"Not implemented\");\n    }) as (params: any) => Promise<string>,\n  };\n};\n\n// function signMessage(_signer?: RadixSigner) {\n//   return function signMessage(_message: string) {\n//     throw new SwapKitError(\"not_implemented\", { method: \"signMessage\", toolbox: \"radix\" });\n\n//     // TODO: convert message to Uint8Array\n//     // return signer.signToSignatureWithPublicKey(message);\n//   };\n// }\n\n// function validateSignature(_signer?: RadixSigner) {\n//   return function validateSignature(_signature: SignatureWithPublicKey) {\n//     throw new SwapKitError(\"not_implemented\", { method: \"validateSignature\", toolbox: \"radix\" });\n\n//     // TODO: validate signature\n//     // return\n//   };\n// }\n"
  ],
  "mappings": "AAGO,IAAM,EAAe,CAC1B,UAAW,EACX,YAAa,UACb,cAAe,gCACjB,ECPA,2BAEE,0CAKF,2BAAS,qCAuBT,qBAAS,WAAY,yBAmId,SAAS,CAAe,CAAC,EAAiB,CAC/C,OAAO,EAAQ,WAAW,cAAc,GAAK,EAAQ,SAAW,GAGlE,SAAS,CAAU,EAAG,cAAgD,CACpE,OAAO,eAAe,CAAU,CAAC,EAAiB,CAChD,IAAM,EAAoB,MAAM,EAAuB,CAAE,UAAS,YAAW,CAAC,EAK9E,OAJyB,EAA2B,CAClD,UAAW,EACX,YACF,CAAC,GAKL,eAAe,CAAsB,EACnC,UACA,cACoE,CACpE,IAAI,EAAc,GACd,EAAa,OACb,EAAuD,CAAC,EACtD,EAAe,MAAM,EAAoB,CAAU,EACzD,MAAO,EAAa,CAClB,IAAM,EAAmE,CACvE,QAAS,EACT,eAAgB,IAChB,OAAQ,EACR,gBAAiB,CACf,cAAe,CACjB,CACF,EAEM,EACJ,MAAM,EAAW,MAAM,YAAY,oBAAoB,CACrD,gCAAiC,CACnC,CAAC,EAGH,GADA,EAAoB,EAAkB,OAAO,EAAiC,KAAK,EAC/E,EAAiC,YACnC,EAAa,EAAiC,gBAE9C,GAAc,GAGlB,OAAO,EAIT,eAAe,CAA0B,EACvC,YACA,cAIwB,CACxB,IAAM,EAAyB,CAAC,EAC1B,EAAa,GAGb,EAAkB,CAAC,EACzB,QAAS,EAAI,EAAG,EAAI,EAAU,OAAQ,GAJnB,GAKjB,EAAgB,KAAK,EAAU,MAAM,EAAG,EALvB,EAKqC,CAAC,EAGzD,QAAW,KAAS,EAAiB,CACnC,IAAM,EAAY,EAAM,IAAI,CAAC,IAAS,EAAK,gBAAgB,EACrD,EACJ,MAAM,EAAW,MAAM,gCAAgC,CAAS,EAE5D,EAAiB,IAAI,IAE3B,QAAW,KAAU,EACnB,GAAI,EAAO,UAAY,OAAW,CAChC,IAAM,EAAiB,EAAO,UAAU,MAAM,KAAK,CAAC,IAAS,EAAK,MAAQ,QAAQ,EAC5E,EACJ,GAAgB,MAAM,MAAM,OAAS,SAAW,EAAe,MAAM,MAAM,MAAQ,IAErF,GAAI,EAAO,QAAQ,OAAS,mBAC1B,EAAe,IAAI,EAAO,QAAS,CACjC,SAAU,EAAO,QAAQ,aACzB,QACF,CAAC,EAKP,QAAW,KAAQ,EACjB,GAAI,EAAK,oBAAsB,SAAU,CACvC,IAAM,EAAY,EAAe,IAAI,EAAK,gBAAgB,GAAK,CAAE,SAAU,EAAG,OAAQ,GAAI,EAEpF,EAAU,EAAW,KAAK,CAC9B,MACE,EAAU,SAAW,EAAM,MACvB,GAAG,EAAM,SAAS,EAAU,UAAU,EAAK,mBAC3C,UACN,MAAO,EAAK,MACd,CAAC,EACD,EAAS,KAAK,CAAO,GAK3B,OAAO,EAOT,eAAe,CAAmB,CAAC,EAA8B,CAC/D,OAAO,EAAW,OAAO,WAAW,EAAE,KAAK,CAAC,IAAW,EAAO,aAAa,aAAa,EAgYnF,IAAM,EAAe,OAC1B,gBAQI,CACJ,IAAM,EAAe,EAAiB,IACjC,EACH,UAAW,EAAW,SAAS,WAAa,CAC9C,CAAC,EAEK,EAAa,EAAiB,WAAW,EAAa,WAAW,YAAY,EAEnF,MAAO,CACL,aACA,WAAY,EAAW,CAAE,YAAW,CAAC,EACrC,WAAY,IAAM,CAChB,MAAO,IAET,kBACA,iBAAmB,IAAM,CACvB,MAAM,IAAI,MAAM,iBAAiB,EAErC",
  "debugId": "8DFC92C1B52E724E64756E2164756E21",
  "names": []
}