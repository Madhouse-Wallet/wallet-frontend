var pQ=Object.create;var{getPrototypeOf:lQ,defineProperty:_$,getOwnPropertyNames:iQ}=Object;var nQ=Object.prototype.hasOwnProperty;var oQ=($,Q,J)=>{J=$!=null?pQ(lQ($)):{};let Y=Q||!$||!$.__esModule?_$(J,"default",{value:$,enumerable:!0}):J;for(let X of iQ($))if(!nQ.call(Y,X))_$(Y,X,{get:()=>$[X],enumerable:!0});return Y};var rQ=($,Q)=>{for(var J in Q)_$($,J,{get:Q[J],enumerable:!0,configurable:!0,set:(Y)=>Q[J]=()=>Y})};var aQ=(($)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy($,{get:(Q,J)=>(typeof require!=="undefined"?require:Q)[J]}):$)(function($){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+$+'" is not supported')});import{filterSupportedChains as hY,setRequestClientConfig as dY}from"@swapkit/helpers";import{Chain as c0,WalletOption as uQ}from"@swapkit/helpers";import{CoinbaseWalletSDK as vY}from"@coinbase/wallet-sdk";import{Chain as $$,ChainToRPC as gY,pickEvmApiKey as cY}from"@swapkit/helpers";var S8="6.13.5";function sQ($,Q,J){let Y=Q.split("|").map((z)=>z.trim());for(let z=0;z<Y.length;z++)switch(Q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===Q)return}let X=new Error(`invalid value for type ${Q}`);throw X.code="INVALID_ARGUMENT",X.argument=`value.${J}`,X.value=$,X}async function y0($){let Q=Object.keys($);return(await Promise.all(Q.map((Y)=>Promise.resolve($[Y])))).reduce((Y,X,z)=>{return Y[Q[z]]=X,Y},{})}function Z0($,Q,J){for(let Y in Q){let X=Q[Y],z=J?J[Y]:null;if(z)sQ(X,z,Y);Object.defineProperty($,Y,{enumerable:!0,value:X,writable:!1})}}function p0($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(p0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let Y=0;Y<$.length;Y++)J+="0123456789abcdef"[$[Y]>>4],J+="0123456789abcdef"[$[Y]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return p0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{let Q=Object.keys($);return Q.sort(),"{ "+Q.map((J)=>`${p0(J)}: ${p0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function y$($,Q){return $&&$.code===Q}function I$($,Q,J){let Y=$;{let z=[];if(J){if("message"in J||"code"in J||"name"in J)throw new Error(`value will overwrite populated values: ${p0(J)}`);for(let Z in J){if(Z==="shortMessage")continue;let G=J[Z];z.push(Z+"="+p0(G))}}if(z.push(`code=${Q}`),z.push(`version=${S8}`),z.length)$+=" ("+z.join(", ")+")"}let X;switch(Q){case"INVALID_ARGUMENT":X=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":X=new RangeError($);break;default:X=new Error($)}if(Z0(X,{code:Q}),J)Object.assign(X,J);if(X.shortMessage==null)Z0(X,{shortMessage:Y});return X}function L($,Q,J,Y){if(!$)throw I$(Q,J,Y)}function O($,Q,J,Y){L($,Q,"INVALID_ARGUMENT",{argument:J,value:Y})}var aY=["NFD","NFC","NFKD","NFKC"].reduce(($,Q)=>{try{if("test".normalize(Q)!=="test")throw new Error("bad");if(Q==="NFD"){let J=String.fromCharCode(233).normalize("NFD"),Y=String.fromCharCode(101,769);if(J!==Y)throw new Error("broken")}$.push(Q)}catch(J){}return $},[]);function b$($,Q,J){if(J==null)J="";if($!==Q){let Y=J,X="new";if(J)Y+=".",X+=" "+J;L(!1,`private constructor; use ${Y}from* methods`,"UNSUPPORTED_OPERATION",{operation:X})}}function P8($,Q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){let Y=new Uint8Array(($.length-2)/2),X=2;for(let z=0;z<Y.length;z++)Y[z]=parseInt($.substring(X,X+2),16),X+=2;return Y}O(!1,"invalid BytesLike value",Q||"value",$)}function y($,Q){return P8($,Q,!1)}function b0($,Q){return P8($,Q,!0)}function $0($,Q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Q==="number"&&$.length!==2+2*Q)return!1;if(Q===!0&&$.length%2!==0)return!1;return!0}function Q$($){return $0($,!0)||$ instanceof Uint8Array}var H8="0123456789abcdef";function E($){let Q=y($),J="0x";for(let Y=0;Y<Q.length;Y++){let X=Q[Y];J+=H8[(X&240)>>4]+H8[X&15]}return J}function G0($){return"0x"+$.map((Q)=>E(Q).substring(2)).join("")}function N0($){if($0($,!0))return($.length-2)/2;return y($).length}function tQ($,Q,J){let Y=y($);L(Q>=Y.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(Y),length:Q,offset:Q+1});let X=new Uint8Array(Q);if(X.fill(0),J)X.set(Y,Q-Y.length);else X.set(Y,0);return E(X)}function w0($,Q){return tQ($,Q,!0)}var E8=BigInt(0),Q9=BigInt(1),l0=9007199254740991;function m($,Q){switch(typeof $){case"bigint":return $;case"number":return O(Number.isInteger($),"underflow",Q||"value",$),O($>=-l0&&$<=l0,"overflow",Q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){O(!1,`invalid BigNumberish string: ${J.message}`,Q||"value",$)}}O(!1,"invalid BigNumberish value",Q||"value",$)}function f$($,Q){let J=m($,Q);return L(J>=E8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function Q0($,Q){switch(typeof $){case"bigint":return O($>=-l0&&$<=l0,"overflow",Q||"value",$),Number($);case"number":return O(Number.isInteger($),"underflow",Q||"value",$),O($>=-l0&&$<=l0,"overflow",Q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return Q0(BigInt($),Q)}catch(J){O(!1,`invalid numeric string: ${J.message}`,Q||"value",$)}}O(!1,"invalid numeric value",Q||"value",$)}function D$($,Q){let Y=f$($,"value").toString(16);if(Q==null){if(Y.length%2)Y="0"+Y}else{let X=Q0(Q,"width");L(X*2>=Y.length,`value exceeds width (${X} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(Y.length<X*2)Y="0"+Y}return"0x"+Y}function a($){let Q=f$($,"value");if(Q===E8)return new Uint8Array([]);let J=Q.toString(16);if(J.length%2)J="0"+J;let Y=new Uint8Array(J.length/2);for(let X=0;X<Y.length;X++){let z=X*2;Y[X]=parseInt(J.substring(z,z+2),16)}return Y}function eQ($){let Q=$.toString(16);while(Q.length<2)Q="0"+Q;return"0x"+Q}function A8($,Q,J){let Y=0;for(let X=0;X<J;X++)Y=Y*256+$[Q+X];return Y}function L8($,Q,J,Y){let X=[];while(J<Q+1+Y){let z=B8($,J);X.push(z.result),J+=z.consumed,L(J<=Q+1+Y,"child data too short","BUFFER_OVERRUN",{buffer:$,length:Y,offset:Q})}return{consumed:1+Y,result:X}}function B8($,Q){L($.length!==0,"data too short","BUFFER_OVERRUN",{buffer:$,length:0,offset:1});let J=(Y)=>{L(Y<=$.length,"data short segment too short","BUFFER_OVERRUN",{buffer:$,length:$.length,offset:Y})};if($[Q]>=248){let Y=$[Q]-247;J(Q+1+Y);let X=A8($,Q+1,Y);return J(Q+1+Y+X),L8($,Q,Q+1+Y,Y+X)}else if($[Q]>=192){let Y=$[Q]-192;return J(Q+1+Y),L8($,Q,Q+1,Y)}else if($[Q]>=184){let Y=$[Q]-183;J(Q+1+Y);let X=A8($,Q+1,Y);J(Q+1+Y+X);let z=E($.slice(Q+1+Y,Q+1+Y+X));return{consumed:1+Y+X,result:z}}else if($[Q]>=128){let Y=$[Q]-128;J(Q+1+Y);let X=E($.slice(Q+1,Q+1+Y));return{consumed:1+Y,result:X}}return{consumed:1,result:eQ($[Q])}}function i0($){let Q=y($,"data"),J=B8(Q,0);return O(J.consumed===Q.length,"unexpected junk after rlp payload","data",$),J.result}function k8($){let Q=[];while($)Q.unshift($&255),$>>=8;return Q}function _8($){if(Array.isArray($)){let Y=[];if($.forEach(function(z){Y=Y.concat(_8(z))}),Y.length<=55)return Y.unshift(192+Y.length),Y;let X=k8(Y.length);return X.unshift(247+X.length),X.concat(Y)}let Q=Array.prototype.slice.call(y($,"object"));if(Q.length===1&&Q[0]<=127)return Q;else if(Q.length<=55)return Q.unshift(128+Q.length),Q;let J=k8(Q.length);return J.unshift(183+J.length),J.concat(Q)}var F8="0123456789abcdef";function C0($){let Q="0x";for(let J of _8($))Q+=F8[J>>4],Q+=F8[J&15];return Q}function x$($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function m$($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function n0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function T$($,Q){m$($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var $J=($)=>$ instanceof Uint8Array;var y8=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),V$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),M0=($,Q)=>$<<32-Q|$>>>Q,QJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!QJ)throw new Error("Non little-endian hardware is not supported");function JJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function J$($){if(typeof $==="string")$=JJ($);if(!$J($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}class Y${clone(){return this._cloneInto()}}var B9={}.toString;function o0($){let Q=(Y)=>$().update(J$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function YJ($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),M=Y?4:0,W=Y?0:4;$.setUint32(Q+M,Z,Y),$.setUint32(Q+W,G,Y)}class X$ extends Y${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=V$(this.buffer)}update($){n0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=J$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=V$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){n0(this),T$($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let K=z;K<Y;K++)Q[K]=0;YJ(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=V$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let M=G/4,W=this.get();if(M>W.length)throw new Error("_sha2: outputLen bigger than state");for(let K=0;K<M;K++)Z.setUint32(4*K,W[K],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var XJ=($,Q,J)=>$&Q^~$&J,zJ=($,Q,J)=>$&Q^$&J^Q&J,ZJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),R0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),j0=new Uint32Array(64);class b8 extends X${constructor(){super(64,32,8,!1);this.A=R0[0]|0,this.B=R0[1]|0,this.C=R0[2]|0,this.D=R0[3]|0,this.E=R0[4]|0,this.F=R0[5]|0,this.G=R0[6]|0,this.H=R0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let K=0;K<16;K++,Q+=4)j0[K]=$.getUint32(Q,!1);for(let K=16;K<64;K++){let I=j0[K-15],w=j0[K-2],C=M0(I,7)^M0(I,18)^I>>>3,q=M0(w,17)^M0(w,19)^w>>>10;j0[K]=q+j0[K-7]+C+j0[K-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:M,H:W}=this;for(let K=0;K<64;K++){let I=M0(Z,6)^M0(Z,11)^M0(Z,25),w=W+I+XJ(Z,G,M)+ZJ[K]+j0[K]|0,q=(M0(J,2)^M0(J,13)^M0(J,22))+zJ(J,Y,X)|0;W=M,M=G,G=Z,Z=z+w|0,z=X,X=Y,Y=J,J=w+q|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,M=M+this.G|0,W=W+this.H|0,this.set(J,Y,X,z,Z,G,M,W)}roundClean(){j0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var f8=o0(()=>new b8);var O$=BigInt(4294967295),v$=BigInt(32);function x8($,Q=!1){if(Q)return{h:Number($&O$),l:Number($>>v$&O$)};return{h:Number($>>v$&O$)|0,l:Number($&O$)|0}}function g$($,Q=!1){let J=new Uint32Array($.length),Y=new Uint32Array($.length);for(let X=0;X<$.length;X++){let{h:z,l:Z}=x8($[X],Q);[J[X],Y[X]]=[z,Z]}return[J,Y]}var GJ=($,Q)=>BigInt($>>>0)<<v$|BigInt(Q>>>0),MJ=($,Q,J)=>$>>>J,KJ=($,Q,J)=>$<<32-J|Q>>>J,WJ=($,Q,J)=>$>>>J|Q<<32-J,qJ=($,Q,J)=>$<<32-J|Q>>>J,IJ=($,Q,J)=>$<<64-J|Q>>>J-32,DJ=($,Q,J)=>$>>>J-32|Q<<64-J,TJ=($,Q)=>Q,VJ=($,Q)=>$,c$=($,Q,J)=>$<<J|Q>>>32-J,h$=($,Q,J)=>Q<<J|$>>>32-J,d$=($,Q,J)=>Q<<J-32|$>>>64-J,u$=($,Q,J)=>$<<J-32|Q>>>64-J;function OJ($,Q,J,Y){let X=(Q>>>0)+(Y>>>0);return{h:$+J+(X/4294967296|0)|0,l:X|0}}var UJ=($,Q,J)=>($>>>0)+(Q>>>0)+(J>>>0),NJ=($,Q,J,Y)=>Q+J+Y+($/4294967296|0)|0,wJ=($,Q,J,Y)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0),CJ=($,Q,J,Y,X)=>Q+J+Y+X+($/4294967296|0)|0,RJ=($,Q,J,Y,X)=>($>>>0)+(Q>>>0)+(J>>>0)+(Y>>>0)+(X>>>0),jJ=($,Q,J,Y,X,z)=>Q+J+Y+X+z+($/4294967296|0)|0;var SJ={fromBig:x8,split:g$,toBig:GJ,shrSH:MJ,shrSL:KJ,rotrSH:WJ,rotrSL:qJ,rotrBH:IJ,rotrBL:DJ,rotr32H:TJ,rotr32L:VJ,rotlSH:c$,rotlSL:h$,rotlBH:d$,rotlBL:u$,add:OJ,add3L:UJ,add3H:NJ,add4L:wJ,add4H:CJ,add5H:jJ,add5L:RJ},B=SJ;var[HJ,PJ]=(()=>B.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(($)=>BigInt($))))(),S0=new Uint32Array(80),H0=new Uint32Array(80);class m8 extends X${constructor(){super(128,64,16,!1);this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:$,Al:Q,Bh:J,Bl:Y,Ch:X,Cl:z,Dh:Z,Dl:G,Eh:M,El:W,Fh:K,Fl:I,Gh:w,Gl:C,Hh:q,Hl:D}=this;return[$,Q,J,Y,X,z,Z,G,M,W,K,I,w,C,q,D]}set($,Q,J,Y,X,z,Z,G,M,W,K,I,w,C,q,D){this.Ah=$|0,this.Al=Q|0,this.Bh=J|0,this.Bl=Y|0,this.Ch=X|0,this.Cl=z|0,this.Dh=Z|0,this.Dl=G|0,this.Eh=M|0,this.El=W|0,this.Fh=K|0,this.Fl=I|0,this.Gh=w|0,this.Gl=C|0,this.Hh=q|0,this.Hl=D|0}process($,Q){for(let N=0;N<16;N++,Q+=4)S0[N]=$.getUint32(Q),H0[N]=$.getUint32(Q+=4);for(let N=16;N<80;N++){let A=S0[N-15]|0,H=H0[N-15]|0,R=B.rotrSH(A,H,1)^B.rotrSH(A,H,8)^B.shrSH(A,H,7),P=B.rotrSL(A,H,1)^B.rotrSL(A,H,8)^B.shrSL(A,H,7),j=S0[N-2]|0,g=H0[N-2]|0,_=B.rotrSH(j,g,19)^B.rotrBH(j,g,61)^B.shrSH(j,g,6),k=B.rotrSL(j,g,19)^B.rotrBL(j,g,61)^B.shrSL(j,g,6),p=B.add4L(P,k,H0[N-7],H0[N-16]),o=B.add4H(p,R,_,S0[N-7],S0[N-16]);S0[N]=o|0,H0[N]=p|0}let{Ah:J,Al:Y,Bh:X,Bl:z,Ch:Z,Cl:G,Dh:M,Dl:W,Eh:K,El:I,Fh:w,Fl:C,Gh:q,Gl:D,Hh:T,Hl:U}=this;for(let N=0;N<80;N++){let A=B.rotrSH(K,I,14)^B.rotrSH(K,I,18)^B.rotrBH(K,I,41),H=B.rotrSL(K,I,14)^B.rotrSL(K,I,18)^B.rotrBL(K,I,41),R=K&w^~K&q,P=I&C^~I&D,j=B.add5L(U,H,P,PJ[N],H0[N]),g=B.add5H(j,T,A,R,HJ[N],S0[N]),_=j|0,k=B.rotrSH(J,Y,28)^B.rotrBH(J,Y,34)^B.rotrBH(J,Y,39),p=B.rotrSL(J,Y,28)^B.rotrBL(J,Y,34)^B.rotrBL(J,Y,39),o=J&X^J&Z^X&Z,I0=Y&z^Y&G^z&G;T=q|0,U=D|0,q=w|0,D=C|0,w=K|0,C=I|0,{h:K,l:I}=B.add(M|0,W|0,g|0,_|0),M=Z|0,W=G|0,Z=X|0,G=z|0,X=J|0,z=Y|0;let h=B.add3L(_,p,I0);J=B.add3H(h,g,k,o),Y=h|0}({h:J,l:Y}=B.add(this.Ah|0,this.Al|0,J|0,Y|0)),{h:X,l:z}=B.add(this.Bh|0,this.Bl|0,X|0,z|0),{h:Z,l:G}=B.add(this.Ch|0,this.Cl|0,Z|0,G|0),{h:M,l:W}=B.add(this.Dh|0,this.Dl|0,M|0,W|0),{h:K,l:I}=B.add(this.Eh|0,this.El|0,K|0,I|0),{h:w,l:C}=B.add(this.Fh|0,this.Fl|0,w|0,C|0),{h:q,l:D}=B.add(this.Gh|0,this.Gl|0,q|0,D|0),{h:T,l:U}=B.add(this.Hh|0,this.Hl|0,T|0,U|0),this.set(J,Y,X,z,Z,G,M,W,K,I,w,C,q,D,T,U)}roundClean(){S0.fill(0),H0.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var v8=o0(()=>new m8);function EJ(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw new Error("unable to locate global object")}var g8=EJ(),l9=g8.crypto||g8.msCrypto;function p$($){switch($){case"sha256":return f8.create();case"sha512":return v8.create()}O(!1,"invalid hashing algorithm name","algorithm",$)}var[d8,u8,p8]=[[],[],[]],AJ=BigInt(0),z$=BigInt(1),LJ=BigInt(2),BJ=BigInt(7),kJ=BigInt(256),FJ=BigInt(113);for(let $=0,Q=z$,J=1,Y=0;$<24;$++){[J,Y]=[Y,(2*J+3*Y)%5],d8.push(2*(5*Y+J)),u8.push(($+1)*($+2)/2%64);let X=AJ;for(let z=0;z<7;z++)if(Q=(Q<<z$^(Q>>BJ)*FJ)%kJ,Q&LJ)X^=z$<<(z$<<BigInt(z))-z$;p8.push(X)}var[_J,yJ]=g$(p8,!0),c8=($,Q,J)=>J>32?d$($,Q,J):c$($,Q,J),h8=($,Q,J)=>J>32?u$($,Q,J):h$($,Q,J);function bJ($,Q=24){let J=new Uint32Array(10);for(let Y=24-Q;Y<24;Y++){for(let Z=0;Z<10;Z++)J[Z]=$[Z]^$[Z+10]^$[Z+20]^$[Z+30]^$[Z+40];for(let Z=0;Z<10;Z+=2){let G=(Z+8)%10,M=(Z+2)%10,W=J[M],K=J[M+1],I=c8(W,K,1)^J[G],w=h8(W,K,1)^J[G+1];for(let C=0;C<50;C+=10)$[Z+C]^=I,$[Z+C+1]^=w}let X=$[2],z=$[3];for(let Z=0;Z<24;Z++){let G=u8[Z],M=c8(X,z,G),W=h8(X,z,G),K=d8[Z];X=$[K],z=$[K+1],$[K]=M,$[K+1]=W}for(let Z=0;Z<50;Z+=10){for(let G=0;G<10;G++)J[G]=$[Z+G];for(let G=0;G<10;G++)$[Z+G]^=~J[(G+2)%10]&J[(G+4)%10]}$[0]^=_J[Y],$[1]^=yJ[Y]}J.fill(0)}class l$ extends Y${constructor($,Q,J,Y=!1,X=24){super();if(this.blockLen=$,this.suffix=Q,this.outputLen=J,this.enableXOF=Y,this.rounds=X,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,x$(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=y8(this.state)}keccak(){bJ(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){n0(this);let{blockLen:Q,state:J}=this;$=J$($);let Y=$.length;for(let X=0;X<Y;){let z=Math.min(Q-this.pos,Y-X);for(let Z=0;Z<z;Z++)J[this.pos++]^=$[X++];if(this.pos===Q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:$,suffix:Q,pos:J,blockLen:Y}=this;if($[J]^=Q,(Q&128)!==0&&J===Y-1)this.keccak();$[Y-1]^=128,this.keccak()}writeInto($){n0(this,!1),m$($),this.finish();let Q=this.state,{blockLen:J}=this;for(let Y=0,X=$.length;Y<X;){if(this.posOut>=J)this.keccak();let z=Math.min(J-this.posOut,X-Y);$.set(Q.subarray(this.posOut,this.posOut+z),Y),this.posOut+=z,Y+=z}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return x$($),this.xofInto(new Uint8Array($))}digestInto($){if(T$($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){let{blockLen:Q,suffix:J,outputLen:Y,rounds:X,enableXOF:z}=this;return $||($=new l$(Q,J,Y,z,X)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=X,$.suffix=J,$.outputLen=Y,$.enableXOF=z,$.destroyed=this.destroyed,$}}var fJ=($,Q,J)=>o0(()=>new l$(Q,$,J));var l8=fJ(1,136,32);var i8=!1,n8=function($){return l8($)},o8=n8;function J0($){let Q=y($,"data");return E(o8(Q))}J0._=n8;J0.lock=function(){i8=!0};J0.register=function($){if(i8)throw new TypeError("keccak256 is locked");o8=$};Object.freeze(J0);var r8=function($){return p$("sha256").update($).digest()},a8=function($){return p$("sha512").update($).digest()},s8=r8,t8=a8,e8=!1,$Q=!1;function P0($){let Q=y($,"data");return E(s8(Q))}P0._=r8;P0.lock=function(){e8=!0};P0.register=function($){if(e8)throw new Error("sha256 is locked");s8=$};Object.freeze(P0);function U$($){let Q=y($,"data");return E(t8(Q))}U$._=a8;U$.lock=function(){$Q=!0};U$.register=function($){if($Q)throw new Error("sha512 is locked");t8=$};Object.freeze(P0);function QQ($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)}function i$($,...Q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Q.length>0&&!Q.includes($.length))throw new Error(`Expected Uint8Array of length ${Q}, not of length=${$.length}`)}function JQ($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");QQ($.outputLen),QQ($.blockLen)}function r0($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function YQ($,Q){i$($);let J=Q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)}var N$=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var XQ=($)=>$ instanceof Uint8Array;var w$=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),K0=($,Q)=>$<<32-Q|$>>>Q,xJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!xJ)throw new Error("Non little-endian hardware is not supported");function mJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function Z$($){if(typeof $==="string")$=mJ($);if(!XQ($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function zQ(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!XQ(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}class G${clone(){return this._cloneInto()}}var GX={}.toString;function ZQ($){let Q=(Y)=>$().update(Z$(Y)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function GQ($=32){if(N$&&typeof N$.getRandomValues==="function")return N$.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}function vJ($,Q,J,Y){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,Y);let X=BigInt(32),z=BigInt(4294967295),Z=Number(J>>X&z),G=Number(J&z),M=Y?4:0,W=Y?0:4;$.setUint32(Q+M,Z,Y),$.setUint32(Q+W,G,Y)}class n$ extends G${constructor($,Q,J,Y){super();this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=Y,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=w$(this.buffer)}update($){r0(this);let{view:Q,buffer:J,blockLen:Y}=this;$=Z$($);let X=$.length;for(let z=0;z<X;){let Z=Math.min(Y-this.pos,X-z);if(Z===Y){let G=w$($);for(;Y<=X-z;z+=Y)this.process(G,z);continue}if(J.set($.subarray(z,z+Z),this.pos),this.pos+=Z,z+=Z,this.pos===Y)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){r0(this),YQ($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:Y,isLE:X}=this,{pos:z}=this;if(Q[z++]=128,this.buffer.subarray(z).fill(0),this.padOffset>Y-z)this.process(J,0),z=0;for(let K=z;K<Y;K++)Q[K]=0;vJ(J,Y-8,BigInt(this.length*8),X),this.process(J,0);let Z=w$($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let M=G/4,W=this.get();if(M>W.length)throw new Error("_sha2: outputLen bigger than state");for(let K=0;K<M;K++)Z.setUint32(4*K,W[K],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:Y,finished:X,destroyed:z,pos:Z}=this;if($.length=Y,$.pos=Z,$.finished=X,$.destroyed=z,Y%Q)$.buffer.set(J);return $}}var gJ=($,Q,J)=>$&Q^~$&J,cJ=($,Q,J)=>$&Q^$&J^Q&J,hJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),E0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),A0=new Uint32Array(64);class MQ extends n${constructor(){super(64,32,8,!1);this.A=E0[0]|0,this.B=E0[1]|0,this.C=E0[2]|0,this.D=E0[3]|0,this.E=E0[4]|0,this.F=E0[5]|0,this.G=E0[6]|0,this.H=E0[7]|0}get(){let{A:$,B:Q,C:J,D:Y,E:X,F:z,G:Z,H:G}=this;return[$,Q,J,Y,X,z,Z,G]}set($,Q,J,Y,X,z,Z,G){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=Y|0,this.E=X|0,this.F=z|0,this.G=Z|0,this.H=G|0}process($,Q){for(let K=0;K<16;K++,Q+=4)A0[K]=$.getUint32(Q,!1);for(let K=16;K<64;K++){let I=A0[K-15],w=A0[K-2],C=K0(I,7)^K0(I,18)^I>>>3,q=K0(w,17)^K0(w,19)^w>>>10;A0[K]=q+A0[K-7]+C+A0[K-16]|0}let{A:J,B:Y,C:X,D:z,E:Z,F:G,G:M,H:W}=this;for(let K=0;K<64;K++){let I=K0(Z,6)^K0(Z,11)^K0(Z,25),w=W+I+gJ(Z,G,M)+hJ[K]+A0[K]|0,q=(K0(J,2)^K0(J,13)^K0(J,22))+cJ(J,Y,X)|0;W=M,M=G,G=Z,Z=z+w|0,z=X,X=Y,Y=J,J=w+q|0}J=J+this.A|0,Y=Y+this.B|0,X=X+this.C|0,z=z+this.D|0,Z=Z+this.E|0,G=G+this.F|0,M=M+this.G|0,W=W+this.H|0,this.set(J,Y,X,z,Z,G,M,W)}roundClean(){A0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var KQ=ZQ(()=>new MQ);var s$={};rQ(s$,{validateObject:()=>B0,utf8ToBytes:()=>iJ,numberToVarBytesBE:()=>pJ,numberToHexUnpadded:()=>IQ,numberToBytesLE:()=>S$,numberToBytesBE:()=>L0,hexToNumber:()=>r$,hexToBytes:()=>x0,equalBytes:()=>lJ,ensureBytes:()=>t,createHmacDrbg:()=>a$,concatBytes:()=>a0,bytesToNumberLE:()=>j$,bytesToNumberBE:()=>V0,bytesToHex:()=>f0,bitSet:()=>rJ,bitMask:()=>M$,bitLen:()=>nJ,bitGet:()=>oJ});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var qQ=BigInt(0),C$=BigInt(1),dJ=BigInt(2),R$=($)=>$ instanceof Uint8Array,uJ=Array.from({length:256},($,Q)=>Q.toString(16).padStart(2,"0"));function f0($){if(!R$($))throw new Error("Uint8Array expected");let Q="";for(let J=0;J<$.length;J++)Q+=uJ[$[J]];return Q}function IQ($){let Q=$.toString(16);return Q.length&1?`0${Q}`:Q}function r$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function x0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);let Q=$.length;if(Q%2)throw new Error("padded hex string expected, got unpadded hex of length "+Q);let J=new Uint8Array(Q/2);for(let Y=0;Y<J.length;Y++){let X=Y*2,z=$.slice(X,X+2),Z=Number.parseInt(z,16);if(Number.isNaN(Z)||Z<0)throw new Error("Invalid byte sequence");J[Y]=Z}return J}function V0($){return r$(f0($))}function j$($){if(!R$($))throw new Error("Uint8Array expected");return r$(f0(Uint8Array.from($).reverse()))}function L0($,Q){return x0($.toString(16).padStart(Q*2,"0"))}function S$($,Q){return L0($,Q).reverse()}function pJ($){return x0(IQ($))}function t($,Q,J){let Y;if(typeof Q==="string")try{Y=x0(Q)}catch(z){throw new Error(`${$} must be valid hex string, got "${Q}". Cause: ${z}`)}else if(R$(Q))Y=Uint8Array.from(Q);else throw new Error(`${$} must be hex string or Uint8Array`);let X=Y.length;if(typeof J==="number"&&X!==J)throw new Error(`${$} expected ${J} bytes, got ${X}`);return Y}function a0(...$){let Q=new Uint8Array($.reduce((Y,X)=>Y+X.length,0)),J=0;return $.forEach((Y)=>{if(!R$(Y))throw new Error("Uint8Array expected");Q.set(Y,J),J+=Y.length}),Q}function lJ($,Q){if($.length!==Q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Q[J])return!1;return!0}function iJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array(new TextEncoder().encode($))}function nJ($){let Q;for(Q=0;$>qQ;$>>=C$,Q+=1);return Q}function oJ($,Q){return $>>BigInt(Q)&C$}var rJ=($,Q,J)=>{return $|(J?C$:qQ)<<BigInt(Q)},M$=($)=>(dJ<<BigInt($-1))-C$,o$=($)=>new Uint8Array($),WQ=($)=>Uint8Array.from($);function a$($,Q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let Y=o$($),X=o$($),z=0,Z=()=>{Y.fill(1),X.fill(0),z=0},G=(...I)=>J(X,Y,...I),M=(I=o$())=>{if(X=G(WQ([0]),I),Y=G(),I.length===0)return;X=G(WQ([1]),I),Y=G()},W=()=>{if(z++>=1000)throw new Error("drbg: tried 1000 values");let I=0,w=[];while(I<Q){Y=G();let C=Y.slice();w.push(C),I+=Y.length}return a0(...w)};return(I,w)=>{Z(),M(I);let C=void 0;while(!(C=w(W())))M();return Z(),C}}var aJ={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,Q)=>Q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function B0($,Q,J={}){let Y=(X,z,Z)=>{let G=aJ[z];if(typeof G!=="function")throw new Error(`Invalid validator "${z}", expected function`);let M=$[X];if(Z&&M===void 0)return;if(!G(M,$))throw new Error(`Invalid param ${String(X)}=${M} (${typeof M}), expected ${z}`)};for(let[X,z]of Object.entries(Q))Y(X,z,!1);for(let[X,z]of Object.entries(J))Y(X,z,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var l=BigInt(0),v=BigInt(1),m0=BigInt(2),sJ=BigInt(3),t$=BigInt(4),DQ=BigInt(5),TQ=BigInt(8),tJ=BigInt(9),eJ=BigInt(16);function r($,Q){let J=$%Q;return J>=l?J:Q+J}function $Y($,Q,J){if(J<=l||Q<l)throw new Error("Expected power/modulo > 0");if(J===v)return l;let Y=v;while(Q>l){if(Q&v)Y=Y*$%J;$=$*$%J,Q>>=v}return Y}function e($,Q,J){let Y=$;while(Q-- >l)Y*=Y,Y%=J;return Y}function H$($,Q){if($===l||Q<=l)throw new Error(`invert: expected positive integers, got n=${$} mod=${Q}`);let J=r($,Q),Y=Q,X=l,z=v,Z=v,G=l;while(J!==l){let W=Y/J,K=Y%J,I=X-Z*W,w=z-G*W;Y=J,J=K,X=Z,z=G,Z=I,G=w}if(Y!==v)throw new Error("invert: does not exist");return r(X,Q)}function QY($){let Q=($-v)/m0,J,Y,X;for(J=$-v,Y=0;J%m0===l;J/=m0,Y++);for(X=m0;X<$&&$Y(X,Q,$)!==$-v;X++);if(Y===1){let Z=($+v)/t$;return function G(M,W){let K=M.pow(W,Z);if(!M.eql(M.sqr(K),W))throw new Error("Cannot find square root");return K}}let z=(J+v)/m0;return function Z(G,M){if(G.pow(M,Q)===G.neg(G.ONE))throw new Error("Cannot find square root");let W=Y,K=G.pow(G.mul(G.ONE,X),J),I=G.pow(M,z),w=G.pow(M,J);while(!G.eql(w,G.ONE)){if(G.eql(w,G.ZERO))return G.ZERO;let C=1;for(let D=G.sqr(w);C<W;C++){if(G.eql(D,G.ONE))break;D=G.sqr(D)}let q=G.pow(K,v<<BigInt(W-C-1));K=G.sqr(q),I=G.mul(I,q),w=G.mul(w,K),W=C}return I}}function JY($){if($%t$===sJ){let Q=($+v)/t$;return function J(Y,X){let z=Y.pow(X,Q);if(!Y.eql(Y.sqr(z),X))throw new Error("Cannot find square root");return z}}if($%TQ===DQ){let Q=($-DQ)/TQ;return function J(Y,X){let z=Y.mul(X,m0),Z=Y.pow(z,Q),G=Y.mul(X,Z),M=Y.mul(Y.mul(G,m0),Z),W=Y.mul(G,Y.sub(M,Y.ONE));if(!Y.eql(Y.sqr(W),X))throw new Error("Cannot find square root");return W}}if($%eJ===tJ);return QY($)}var YY=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function e$($){let Q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=YY.reduce((Y,X)=>{return Y[X]="function",Y},Q);return B0($,J)}function XY($,Q,J){if(J<l)throw new Error("Expected power > 0");if(J===l)return $.ONE;if(J===v)return Q;let Y=$.ONE,X=Q;while(J>l){if(J&v)Y=$.mul(Y,X);X=$.sqr(X),J>>=v}return Y}function zY($,Q){let J=new Array(Q.length),Y=Q.reduce((z,Z,G)=>{if($.is0(Z))return z;return J[G]=z,$.mul(z,Z)},$.ONE),X=$.inv(Y);return Q.reduceRight((z,Z,G)=>{if($.is0(Z))return z;return J[G]=$.mul(z,J[G]),$.mul(z,Z)},X),J}function $8($,Q){let J=Q!==void 0?Q:$.toString(2).length,Y=Math.ceil(J/8);return{nBitLength:J,nByteLength:Y}}function VQ($,Q,J=!1,Y={}){if($<=l)throw new Error(`Expected Field ORDER > 0, got ${$}`);let{nBitLength:X,nByteLength:z}=$8($,Q);if(z>2048)throw new Error("Field lengths over 2048 bytes are not supported");let Z=JY($),G=Object.freeze({ORDER:$,BITS:X,BYTES:z,MASK:M$(X),ZERO:l,ONE:v,create:(M)=>r(M,$),isValid:(M)=>{if(typeof M!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof M}`);return l<=M&&M<$},is0:(M)=>M===l,isOdd:(M)=>(M&v)===v,neg:(M)=>r(-M,$),eql:(M,W)=>M===W,sqr:(M)=>r(M*M,$),add:(M,W)=>r(M+W,$),sub:(M,W)=>r(M-W,$),mul:(M,W)=>r(M*W,$),pow:(M,W)=>XY(G,M,W),div:(M,W)=>r(M*H$(W,$),$),sqrN:(M)=>M*M,addN:(M,W)=>M+W,subN:(M,W)=>M-W,mulN:(M,W)=>M*W,inv:(M)=>H$(M,$),sqrt:Y.sqrt||((M)=>Z(G,M)),invertBatch:(M)=>zY(G,M),cmov:(M,W,K)=>K?W:M,toBytes:(M)=>J?S$(M,z):L0(M,z),fromBytes:(M)=>{if(M.length!==z)throw new Error(`Fp.fromBytes: expected ${z}, got ${M.length}`);return J?j$(M):V0(M)}});return Object.freeze(G)}function OQ($){if(typeof $!=="bigint")throw new Error("field order must be bigint");let Q=$.toString(2).length;return Math.ceil(Q/8)}function Q8($){let Q=OQ($);return Q+Math.ceil(Q/2)}function UQ($,Q,J=!1){let Y=$.length,X=OQ(Q),z=Q8(Q);if(Y<16||Y<z||Y>1024)throw new Error(`expected ${z}-1024 bytes of input, got ${Y}`);let Z=J?V0($):j$($),G=r(Z,Q-v)+v;return J?S$(G,X):L0(G,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var GY=BigInt(0),J8=BigInt(1);function NQ($,Q){let J=(X,z)=>{let Z=z.negate();return X?Z:z},Y=(X)=>{let z=Math.ceil(Q/X)+1,Z=2**(X-1);return{windows:z,windowSize:Z}};return{constTimeNegate:J,unsafeLadder(X,z){let Z=$.ZERO,G=X;while(z>GY){if(z&J8)Z=Z.add(G);G=G.double(),z>>=J8}return Z},precomputeWindow(X,z){let{windows:Z,windowSize:G}=Y(z),M=[],W=X,K=W;for(let I=0;I<Z;I++){K=W,M.push(K);for(let w=1;w<G;w++)K=K.add(W),M.push(K);W=K.double()}return M},wNAF(X,z,Z){let{windows:G,windowSize:M}=Y(X),W=$.ZERO,K=$.BASE,I=BigInt(2**X-1),w=2**X,C=BigInt(X);for(let q=0;q<G;q++){let D=q*M,T=Number(Z&I);if(Z>>=C,T>M)T-=w,Z+=J8;let U=D,N=D+Math.abs(T)-1,A=q%2!==0,H=T<0;if(T===0)K=K.add(J(A,z[U]));else W=W.add(J(H,z[N]))}return{p:W,f:K}},wNAFCached(X,z,Z,G){let M=X._WINDOW_SIZE||1,W=z.get(X);if(!W){if(W=this.precomputeWindow(X,M),M!==1)z.set(X,G(W))}return this.wNAF(M,W,Z)}}}function Y8($){return e$($.Fp),B0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...$8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function MY($){let Q=Y8($);B0(Q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:J,Fp:Y,a:X}=Q;if(J){if(!Y.eql(X,Y.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Q})}var{bytesToNumberBE:KY,hexToBytes:WY}=s$,v0={Err:class $ extends Error{constructor(Q=""){super(Q)}},_parseInt($){let{Err:Q}=v0;if($.length<2||$[0]!==2)throw new Q("Invalid signature integer tag");let J=$[1],Y=$.subarray(2,J+2);if(!J||Y.length!==J)throw new Q("Invalid signature integer: wrong length");if(Y[0]&128)throw new Q("Invalid signature integer: negative");if(Y[0]===0&&!(Y[1]&128))throw new Q("Invalid signature integer: unnecessary leading zero");return{d:KY(Y),l:$.subarray(J+2)}},toSig($){let{Err:Q}=v0,J=typeof $==="string"?WY($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let Y=J.length;if(Y<2||J[0]!=48)throw new Q("Invalid signature tag");if(J[1]!==Y-2)throw new Q("Invalid signature: incorrect length");let{d:X,l:z}=v0._parseInt(J.subarray(2)),{d:Z,l:G}=v0._parseInt(z);if(G.length)throw new Q("Invalid signature: left bytes after parsing");return{r:X,s:Z}},hexFromSig($){let Q=(W)=>Number.parseInt(W[0],16)&8?"00"+W:W,J=(W)=>{let K=W.toString(16);return K.length&1?`0${K}`:K},Y=Q(J($.s)),X=Q(J($.r)),z=Y.length/2,Z=X.length/2,G=J(z),M=J(Z);return`30${J(Z+z+4)}02${M}${X}02${G}${Y}`}},O0=BigInt(0),Y0=BigInt(1),RX=BigInt(2),wQ=BigInt(3),jX=BigInt(4);function qY($){let Q=MY($),{Fp:J}=Q,Y=Q.toBytes||((q,D,T)=>{let U=D.toAffine();return a0(Uint8Array.from([4]),J.toBytes(U.x),J.toBytes(U.y))}),X=Q.fromBytes||((q)=>{let D=q.subarray(1),T=J.fromBytes(D.subarray(0,J.BYTES)),U=J.fromBytes(D.subarray(J.BYTES,2*J.BYTES));return{x:T,y:U}});function z(q){let{a:D,b:T}=Q,U=J.sqr(q),N=J.mul(U,q);return J.add(J.add(N,J.mul(q,D)),T)}if(!J.eql(J.sqr(Q.Gy),z(Q.Gx)))throw new Error("bad generator point: equation left != right");function Z(q){return typeof q==="bigint"&&O0<q&&q<Q.n}function G(q){if(!Z(q))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function M(q){let{allowedPrivateKeyLengths:D,nByteLength:T,wrapPrivateKey:U,n:N}=Q;if(D&&typeof q!=="bigint"){if(q instanceof Uint8Array)q=f0(q);if(typeof q!=="string"||!D.includes(q.length))throw new Error("Invalid key");q=q.padStart(T*2,"0")}let A;try{A=typeof q==="bigint"?q:V0(t("private key",q,T))}catch(H){throw new Error(`private key must be ${T} bytes, hex or bigint, not ${typeof q}`)}if(U)A=r(A,N);return G(A),A}let W=new Map;function K(q){if(!(q instanceof I))throw new Error("ProjectivePoint expected")}class I{constructor(q,D,T){if(this.px=q,this.py=D,this.pz=T,q==null||!J.isValid(q))throw new Error("x required");if(D==null||!J.isValid(D))throw new Error("y required");if(T==null||!J.isValid(T))throw new Error("z required")}static fromAffine(q){let{x:D,y:T}=q||{};if(!q||!J.isValid(D)||!J.isValid(T))throw new Error("invalid affine point");if(q instanceof I)throw new Error("projective point not allowed");let U=(N)=>J.eql(N,J.ZERO);if(U(D)&&U(T))return I.ZERO;return new I(D,T,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(q){let D=J.invertBatch(q.map((T)=>T.pz));return q.map((T,U)=>T.toAffine(D[U])).map(I.fromAffine)}static fromHex(q){let D=I.fromAffine(X(t("pointHex",q)));return D.assertValidity(),D}static fromPrivateKey(q){return I.BASE.multiply(M(q))}_setWindowSize(q){this._WINDOW_SIZE=q,W.delete(this)}assertValidity(){if(this.is0()){if(Q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:q,y:D}=this.toAffine();if(!J.isValid(q)||!J.isValid(D))throw new Error("bad point: x or y not FE");let T=J.sqr(D),U=z(q);if(!J.eql(T,U))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:q}=this.toAffine();if(J.isOdd)return!J.isOdd(q);throw new Error("Field doesn't support isOdd")}equals(q){K(q);let{px:D,py:T,pz:U}=this,{px:N,py:A,pz:H}=q,R=J.eql(J.mul(D,H),J.mul(N,U)),P=J.eql(J.mul(T,H),J.mul(A,U));return R&&P}negate(){return new I(this.px,J.neg(this.py),this.pz)}double(){let{a:q,b:D}=Q,T=J.mul(D,wQ),{px:U,py:N,pz:A}=this,H=J.ZERO,R=J.ZERO,P=J.ZERO,j=J.mul(U,U),g=J.mul(N,N),_=J.mul(A,A),k=J.mul(U,N);return k=J.add(k,k),P=J.mul(U,A),P=J.add(P,P),H=J.mul(q,P),R=J.mul(T,_),R=J.add(H,R),H=J.sub(g,R),R=J.add(g,R),R=J.mul(H,R),H=J.mul(k,H),P=J.mul(T,P),_=J.mul(q,_),k=J.sub(j,_),k=J.mul(q,k),k=J.add(k,P),P=J.add(j,j),j=J.add(P,j),j=J.add(j,_),j=J.mul(j,k),R=J.add(R,j),_=J.mul(N,A),_=J.add(_,_),j=J.mul(_,k),H=J.sub(H,j),P=J.mul(_,g),P=J.add(P,P),P=J.add(P,P),new I(H,R,P)}add(q){K(q);let{px:D,py:T,pz:U}=this,{px:N,py:A,pz:H}=q,R=J.ZERO,P=J.ZERO,j=J.ZERO,g=Q.a,_=J.mul(Q.b,wQ),k=J.mul(D,N),p=J.mul(T,A),o=J.mul(U,H),I0=J.add(D,T),h=J.add(N,A);I0=J.mul(I0,h),h=J.add(k,p),I0=J.sub(I0,h),h=J.add(D,U);let V=J.add(N,H);return h=J.mul(h,V),V=J.add(k,o),h=J.sub(h,V),V=J.add(T,U),R=J.add(A,H),V=J.mul(V,R),R=J.add(p,o),V=J.sub(V,R),j=J.mul(g,h),R=J.mul(_,o),j=J.add(R,j),R=J.sub(p,j),j=J.add(p,j),P=J.mul(R,j),p=J.add(k,k),p=J.add(p,k),o=J.mul(g,o),h=J.mul(_,h),p=J.add(p,o),o=J.sub(k,o),o=J.mul(g,o),h=J.add(h,o),k=J.mul(p,h),P=J.add(P,k),k=J.mul(V,h),R=J.mul(I0,R),R=J.sub(R,k),k=J.mul(I0,p),j=J.mul(V,j),j=J.add(j,k),new I(R,P,j)}subtract(q){return this.add(q.negate())}is0(){return this.equals(I.ZERO)}wNAF(q){return C.wNAFCached(this,W,q,(D)=>{let T=J.invertBatch(D.map((U)=>U.pz));return D.map((U,N)=>U.toAffine(T[N])).map(I.fromAffine)})}multiplyUnsafe(q){let D=I.ZERO;if(q===O0)return D;if(G(q),q===Y0)return this;let{endo:T}=Q;if(!T)return C.unsafeLadder(this,q);let{k1neg:U,k1:N,k2neg:A,k2:H}=T.splitScalar(q),R=D,P=D,j=this;while(N>O0||H>O0){if(N&Y0)R=R.add(j);if(H&Y0)P=P.add(j);j=j.double(),N>>=Y0,H>>=Y0}if(U)R=R.negate();if(A)P=P.negate();return P=new I(J.mul(P.px,T.beta),P.py,P.pz),R.add(P)}multiply(q){G(q);let D=q,T,U,{endo:N}=Q;if(N){let{k1neg:A,k1:H,k2neg:R,k2:P}=N.splitScalar(D),{p:j,f:g}=this.wNAF(H),{p:_,f:k}=this.wNAF(P);j=C.constTimeNegate(A,j),_=C.constTimeNegate(R,_),_=new I(J.mul(_.px,N.beta),_.py,_.pz),T=j.add(_),U=g.add(k)}else{let{p:A,f:H}=this.wNAF(D);T=A,U=H}return I.normalizeZ([T,U])[0]}multiplyAndAddUnsafe(q,D,T){let U=I.BASE,N=(H,R)=>R===O0||R===Y0||!H.equals(U)?H.multiplyUnsafe(R):H.multiply(R),A=N(this,D).add(N(q,T));return A.is0()?void 0:A}toAffine(q){let{px:D,py:T,pz:U}=this,N=this.is0();if(q==null)q=N?J.ONE:J.inv(U);let A=J.mul(D,q),H=J.mul(T,q),R=J.mul(U,q);if(N)return{x:J.ZERO,y:J.ZERO};if(!J.eql(R,J.ONE))throw new Error("invZ was invalid");return{x:A,y:H}}isTorsionFree(){let{h:q,isTorsionFree:D}=Q;if(q===Y0)return!0;if(D)return D(I,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:q,clearCofactor:D}=Q;if(q===Y0)return this;if(D)return D(I,this);return this.multiplyUnsafe(Q.h)}toRawBytes(q=!0){return this.assertValidity(),Y(I,this,q)}toHex(q=!0){return f0(this.toRawBytes(q))}}I.BASE=new I(Q.Gx,Q.Gy,J.ONE),I.ZERO=new I(J.ZERO,J.ONE,J.ZERO);let w=Q.nBitLength,C=NQ(I,Q.endo?Math.ceil(w/2):w);return{CURVE:Q,ProjectivePoint:I,normPrivateKeyToScalar:M,weierstrassEquation:z,isWithinCurveOrder:Z}}function IY($){let Q=Y8($);return B0(Q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Q})}function CQ($){let Q=IY($),{Fp:J,n:Y}=Q,X=J.BYTES+1,z=2*J.BYTES+1;function Z(V){return O0<V&&V<J.ORDER}function G(V){return r(V,Y)}function M(V){return H$(V,Y)}let{ProjectivePoint:W,normPrivateKeyToScalar:K,weierstrassEquation:I,isWithinCurveOrder:w}=qY({...Q,toBytes(V,S,F){let b=S.toAffine(),x=J.toBytes(b.x),d=a0;if(F)return d(Uint8Array.from([S.hasEvenY()?2:3]),x);else return d(Uint8Array.from([4]),x,J.toBytes(b.y))},fromBytes(V){let S=V.length,F=V[0],b=V.subarray(1);if(S===X&&(F===2||F===3)){let x=V0(b);if(!Z(x))throw new Error("Point is not on curve");let d=I(x),z0=J.sqrt(d),s=(z0&Y0)===Y0;if((F&1)===1!==s)z0=J.neg(z0);return{x,y:z0}}else if(S===z&&F===4){let x=J.fromBytes(b.subarray(0,J.BYTES)),d=J.fromBytes(b.subarray(J.BYTES,2*J.BYTES));return{x,y:d}}else throw new Error(`Point of length ${S} was invalid. Expected ${X} compressed bytes or ${z} uncompressed bytes`)}}),C=(V)=>f0(L0(V,Q.nByteLength));function q(V){let S=Y>>Y0;return V>S}function D(V){return q(V)?G(-V):V}let T=(V,S,F)=>V0(V.slice(S,F));class U{constructor(V,S,F){this.r=V,this.s=S,this.recovery=F,this.assertValidity()}static fromCompact(V){let S=Q.nByteLength;return V=t("compactSignature",V,S*2),new U(T(V,0,S),T(V,S,2*S))}static fromDER(V){let{r:S,s:F}=v0.toSig(t("DER",V));return new U(S,F)}assertValidity(){if(!w(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!w(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(V){return new U(this.r,this.s,V)}recoverPublicKey(V){let{r:S,s:F,recovery:b}=this,x=j(t("msgHash",V));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");let d=b===2||b===3?S+Q.n:S;if(d>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");let z0=(b&1)===0?"02":"03",s=W.fromHex(z0+C(d)),T0=M(d),k0=G(-x*T0),h0=G(F*T0),F0=W.BASE.multiplyAndAddUnsafe(s,k0,h0);if(!F0)throw new Error("point at infinify");return F0.assertValidity(),F0}hasHighS(){return q(this.s)}normalizeS(){return this.hasHighS()?new U(this.r,G(-this.s),this.recovery):this}toDERRawBytes(){return x0(this.toDERHex())}toDERHex(){return v0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return x0(this.toCompactHex())}toCompactHex(){return C(this.r)+C(this.s)}}let N={isValidPrivateKey(V){try{return K(V),!0}catch(S){return!1}},normPrivateKeyToScalar:K,randomPrivateKey:()=>{let V=Q8(Q.n);return UQ(Q.randomBytes(V),Q.n)},precompute(V=8,S=W.BASE){return S._setWindowSize(V),S.multiply(BigInt(3)),S}};function A(V,S=!0){return W.fromPrivateKey(V).toRawBytes(S)}function H(V){let S=V instanceof Uint8Array,F=typeof V==="string",b=(S||F)&&V.length;if(S)return b===X||b===z;if(F)return b===2*X||b===2*z;if(V instanceof W)return!0;return!1}function R(V,S,F=!0){if(H(V))throw new Error("first arg must be private key");if(!H(S))throw new Error("second arg must be public key");return W.fromHex(S).multiply(K(V)).toRawBytes(F)}let P=Q.bits2int||function(V){let S=V0(V),F=V.length*8-Q.nBitLength;return F>0?S>>BigInt(F):S},j=Q.bits2int_modN||function(V){return G(P(V))},g=M$(Q.nBitLength);function _(V){if(typeof V!=="bigint")throw new Error("bigint expected");if(!(O0<=V&&V<g))throw new Error(`bigint expected < 2^${Q.nBitLength}`);return L0(V,Q.nByteLength)}function k(V,S,F=p){if(["recovered","canonical"].some((_0)=>(_0 in F)))throw new Error("sign() legacy options not supported");let{hash:b,randomBytes:x}=Q,{lowS:d,prehash:z0,extraEntropy:s}=F;if(d==null)d=!0;if(V=t("msgHash",V),z0)V=t("prehashed msgHash",b(V));let T0=j(V),k0=K(S),h0=[_(k0),_(T0)];if(s!=null){let _0=s===!0?x(J.BYTES):s;h0.push(t("extraEntropy",_0))}let F0=a0(...h0),W$=T0;function F$(_0){let d0=P(_0);if(!w(d0))return;let C8=M(d0),D0=W.BASE.multiply(d0).toAffine(),u0=G(D0.x);if(u0===O0)return;let q$=G(C8*G(W$+u0*k0));if(q$===O0)return;let R8=(D0.x===u0?0:2)|Number(D0.y&Y0),j8=q$;if(d&&q(q$))j8=D(q$),R8^=1;return new U(u0,j8,R8)}return{seed:F0,k2sig:F$}}let p={lowS:Q.lowS,prehash:!1},o={lowS:Q.lowS,prehash:!1};function I0(V,S,F=p){let{seed:b,k2sig:x}=k(V,S,F),d=Q;return a$(d.hash.outputLen,d.nByteLength,d.hmac)(b,x)}W.BASE._setWindowSize(8);function h(V,S,F,b=o){let x=V;if(S=t("msgHash",S),F=t("publicKey",F),"strict"in b)throw new Error("options.strict was renamed to lowS");let{lowS:d,prehash:z0}=b,s=void 0,T0;try{if(typeof x==="string"||x instanceof Uint8Array)try{s=U.fromDER(x)}catch(D0){if(!(D0 instanceof v0.Err))throw D0;s=U.fromCompact(x)}else if(typeof x==="object"&&typeof x.r==="bigint"&&typeof x.s==="bigint"){let{r:D0,s:u0}=x;s=new U(D0,u0)}else throw new Error("PARSE");T0=W.fromHex(F)}catch(D0){if(D0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(d&&s.hasHighS())return!1;if(z0)S=Q.hash(S);let{r:k0,s:h0}=s,F0=j(S),W$=M(h0),F$=G(F0*W$),_0=G(k0*W$),d0=W.BASE.multiplyAndAddUnsafe(T0,F$,_0)?.toAffine();if(!d0)return!1;return G(d0.x)===k0}return{CURVE:Q,getPublicKey:A,getSharedSecret:R,sign:I0,verify:h,ProjectivePoint:W,Signature:U,utils:N}}class X8 extends G${constructor($,Q){super();this.finished=!1,this.destroyed=!1,JQ($);let J=Z$(Q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let Y=this.blockLen,X=new Uint8Array(Y);X.set(J.length>Y?$.create().update(J).digest():J);for(let z=0;z<X.length;z++)X[z]^=54;this.iHash.update(X),this.oHash=$.create();for(let z=0;z<X.length;z++)X[z]^=106;this.oHash.update(X),X.fill(0)}update($){return r0(this),this.iHash.update($),this}digestInto($){r0(this),i$($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){let $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));let{oHash:Q,iHash:J,finished:Y,destroyed:X,blockLen:z,outputLen:Z}=this;return $=$,$.finished=Y,$.destroyed=X,$.blockLen=z,$.outputLen=Z,$.oHash=Q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var z8=($,Q,J)=>new X8($,Q).update(J).digest();z8.create=($,Q)=>new X8($,Q);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function DY($){return{hash:$,hmac:(Q,...J)=>z8($,Q,zQ(...J)),randomBytes:GQ}}function RQ($,Q){let J=(Y)=>CQ({...$,...DY(Y)});return Object.freeze({...J(Q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var HQ=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),jQ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),TY=BigInt(1),Z8=BigInt(2),SQ=($,Q)=>($+Q/Z8)/Q;function VY($){let Q=HQ,J=BigInt(3),Y=BigInt(6),X=BigInt(11),z=BigInt(22),Z=BigInt(23),G=BigInt(44),M=BigInt(88),W=$*$*$%Q,K=W*W*$%Q,I=e(K,J,Q)*K%Q,w=e(I,J,Q)*K%Q,C=e(w,Z8,Q)*W%Q,q=e(C,X,Q)*C%Q,D=e(q,z,Q)*q%Q,T=e(D,G,Q)*D%Q,U=e(T,M,Q)*T%Q,N=e(U,G,Q)*D%Q,A=e(N,J,Q)*K%Q,H=e(A,Z,Q)*q%Q,R=e(H,Y,Q)*W%Q,P=e(R,Z8,Q);if(!G8.eql(G8.sqr(P),$))throw new Error("Cannot find square root");return P}var G8=VQ(HQ,void 0,void 0,{sqrt:VY}),U0=RQ({a:BigInt(0),b:BigInt(7),Fp:G8,n:jQ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{let Q=jQ,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Y=-TY*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),z=J,Z=BigInt("0x100000000000000000000000000000000"),G=SQ(z*$,Q),M=SQ(-Y*$,Q),W=r($-G*J-M*X,Q),K=r(-G*Y-M*z,Q),I=W>Z,w=K>Z;if(I)W=Q-W;if(w)K=Q-K;if(W>Z||K>Z)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:I,k1:W,k2neg:w,k2:K}}}},KQ),bX=BigInt(0);var fX=U0.ProjectivePoint;var M8="0x0000000000000000000000000000000000000000";var P$="0x0000000000000000000000000000000000000000000000000000000000000000";var PQ=BigInt(0),EQ=BigInt(1),AQ=BigInt(2),LQ=BigInt(27),BQ=BigInt(28),E$=BigInt(35),s0={};function kQ($){return w0(a($),32)}class u{#$;#J;#Y;#Q;get r(){return this.#$}set r($){O(N0($)===32,"invalid r","value",$),this.#$=E($)}get s(){return this.#J}set s($){O(N0($)===32,"invalid s","value",$);let Q=E($);O(parseInt(Q.substring(0,3))<8,"non-canonical s","value",Q),this.#J=Q}get v(){return this.#Y}set v($){let Q=Q0($,"value");O(Q===27||Q===28,"invalid v","v",$),this.#Y=Q}get networkV(){return this.#Q}get legacyChainId(){let $=this.networkV;if($==null)return null;return u.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){let $=y(this.s);if(this.yParity)$[0]|=128;return E($)}get compactSerialized(){return G0([this.r,this.yParityAndS])}get serialized(){return G0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,Q,J,Y){b$($,s0,"Signature"),this.#$=Q,this.#J=J,this.#Y=Y,this.#Q=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){let $=new u(s0,this.r,this.s,this.v);if(this.networkV)$.#Q=this.networkV;return $}toJSON(){let $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){let Q=m($,"v");if(Q==LQ||Q==BQ)return PQ;return O(Q>=E$,"invalid EIP-155 v","v",$),(Q-E$)/AQ}static getChainIdV($,Q){return m($)*AQ+BigInt(35+Q-27)}static getNormalizedV($){let Q=m($);if(Q===PQ||Q===LQ)return 27;if(Q===EQ||Q===BQ)return 28;return O(Q>=E$,"invalid v","v",$),Q&EQ?27:28}static from($){function Q(M,W){O(M,W,"signature",$)}if($==null)return new u(s0,P$,P$,27);if(typeof $==="string"){let M=y($,"signature");if(M.length===64){let W=E(M.slice(0,32)),K=M.slice(32,64),I=K[0]&128?28:27;return K[0]&=127,new u(s0,W,E(K),I)}if(M.length===65){let W=E(M.slice(0,32)),K=M.slice(32,64);Q((K[0]&128)===0,"non-canonical s");let I=u.getNormalizedV(M[64]);return new u(s0,W,E(K),I)}Q(!1,"invalid raw signature length")}if($ instanceof u)return $.clone();let J=$.r;Q(J!=null,"missing r");let Y=kQ(J),X=function(M,W){if(M!=null)return kQ(M);if(W!=null){Q($0(W,32),"invalid yParityAndS");let K=y(W);return K[0]&=127,E(K)}Q(!1,"missing s")}($.s,$.yParityAndS);Q((y(X)[0]&128)==0,"non-canonical s");let{networkV:z,v:Z}=function(M,W,K){if(M!=null){let I=m(M);return{networkV:I>=E$?I:void 0,v:u.getNormalizedV(I)}}if(W!=null)return Q($0(W,32),"invalid yParityAndS"),{v:y(W)[0]&128?28:27};if(K!=null){switch(Q0(K,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Q(!1,"invalid yParity")}Q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),G=new u(s0,Y,X,Z);if(z)G.#Q=z;return Q($.yParity==null||Q0($.yParity,"sig.yParity")===G.yParity,"yParity mismatch"),Q($.yParityAndS==null||$.yParityAndS===G.yParityAndS,"yParityAndS mismatch"),G}}class X0{#$;constructor($){O(N0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=E($)}get privateKey(){return this.#$}get publicKey(){return X0.computePublicKey(this.#$)}get compressedPublicKey(){return X0.computePublicKey(this.#$,!0)}sign($){O(N0($)===32,"invalid digest length","digest",$);let Q=U0.sign(b0($),b0(this.#$),{lowS:!0});return u.from({r:D$(Q.r,32),s:D$(Q.s,32),v:Q.recovery?28:27})}computeSharedSecret($){let Q=X0.computePublicKey($);return E(U0.getSharedSecret(b0(this.#$),y(Q),!1))}static computePublicKey($,Q){let J=y($,"key");if(J.length===32){let X=U0.getPublicKey(J,!!Q);return E(X)}if(J.length===64){let X=new Uint8Array(65);X[0]=4,X.set(J,1),J=X}let Y=U0.ProjectivePoint.fromHex(J);return E(Y.toRawBytes(Q))}static recoverPublicKey($,Q){O(N0($)===32,"invalid digest length","digest",$);let J=u.from(Q),Y=U0.Signature.fromCompact(b0(G0([J.r,J.s])));Y=Y.addRecoveryBit(J.yParity);let X=Y.recoverPublicKey(b0($));return O(X!=null,"invalid signautre for digest","signature",Q),"0x"+X.toHex(!1)}static addPoints($,Q,J){let Y=U0.ProjectivePoint.fromHex(X0.computePublicKey($).substring(2)),X=U0.ProjectivePoint.fromHex(X0.computePublicKey(Q).substring(2));return"0x"+Y.add(X).toHex(!!J)}}var OY=BigInt(0),UY=BigInt(36);function FQ($){$=$.toLowerCase();let Q=$.substring(2).split(""),J=new Uint8Array(40);for(let X=0;X<40;X++)J[X]=Q[X].charCodeAt(0);let Y=y(J0(J));for(let X=0;X<40;X+=2){if(Y[X>>1]>>4>=8)Q[X]=Q[X].toUpperCase();if((Y[X>>1]&15)>=8)Q[X+1]=Q[X+1].toUpperCase()}return"0x"+Q.join("")}var K8={};for(let $=0;$<10;$++)K8[String($)]=String($);for(let $=0;$<26;$++)K8[String.fromCharCode(65+$)]=String(10+$);var _Q=15;function NY($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let Q=$.split("").map((Y)=>{return K8[Y]}).join("");while(Q.length>=_Q){let Y=Q.substring(0,_Q);Q=parseInt(Y,10)%97+Q.substring(Y.length)}let J=String(98-parseInt(Q,10)%97);while(J.length<2)J="0"+J;return J}var wY=function(){let $={};for(let Q=0;Q<36;Q++){let J="0123456789abcdefghijklmnopqrstuvwxyz"[Q];$[J]=BigInt(Q)}return $}();function CY($){$=$.toLowerCase();let Q=OY;for(let J=0;J<$.length;J++)Q=Q*UY+wY[$[J]];return Q}function W0($){if(O(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;let Q=FQ($);return O(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Q===$,"bad address checksum","address",$),Q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){O($.substring(2,4)===NY($),"bad icap checksum","address",$);let Q=CY($.substring(4)).toString(16);while(Q.length<40)Q="0"+Q;return FQ("0x"+Q)}O(!1,"invalid address","address",$)}function yQ($){return $&&typeof $.getAddress==="function"}async function W8($,Q){let J=await Q;if(J==null||J==="0x0000000000000000000000000000000000000000")L(typeof $!=="string","unconfigured name","UNCONFIGURED_NAME",{value:$}),O(!1,"invalid AddressLike value; did not resolve to a value address","target",$);return W0(J)}function A$($,Q){if(typeof $==="string"){if($.match(/^0x[0-9a-f]{40}$/i))return W0($);return L(Q!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),W8($,Q.resolveName($))}else if(yQ($))return W8($,$.getAddress());else if($&&typeof $.then==="function")return W8($,$);O(!1,"unsupported addressable value","target",$)}function q8($,Q){return{address:W0($),storageKeys:Q.map((J,Y)=>{return O($0(J,32),"invalid slot",`storageKeys[${Y}]`,J),J.toLowerCase()})}}function g0($){if(Array.isArray($))return $.map((J,Y)=>{if(Array.isArray(J))return O(J.length===2,"invalid slot set",`value[${Y}]`,J),q8(J[0],J[1]);return O(J!=null&&typeof J==="object","invalid address-slot set","value",$),q8(J.address,J.storageKeys)});O($!=null&&typeof $==="object","invalid access list","value",$);let Q=Object.keys($).map((J)=>{let Y=$[J].reduce((X,z)=>{return X[z]=!0,X},{});return q8(J,Object.keys(Y).sort())});return Q.sort((J,Y)=>J.address.localeCompare(Y.address)),Q}function RY($){let Q;if(typeof $==="string")Q=X0.computePublicKey($,!1);else Q=$.publicKey;return W0(J0("0x"+Q.substring(4)).substring(26))}function bQ($,Q){return RY(X0.recoverPublicKey($,Q))}var i=BigInt(0),jY=BigInt(2),SY=BigInt(27),HY=BigInt(28),PY=BigInt(35),EY=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),I8=131072;function fQ($,Q){let J=$.toString(16);while(J.length<2)J="0"+J;return J+=P0(Q).substring(4),"0x"+J}function L$($){if($==="0x")return null;return W0($)}function D8($,Q){try{return g0($)}catch(J){O(!1,J.message,Q,$)}}function K$($,Q){if($==="0x")return 0;return Q0($,Q)}function c($,Q){if($==="0x")return i;let J=m($,Q);return O(J<=EY,"value exceeds uint size",Q,J),J}function f($,Q){let J=m($,"value"),Y=a(J);return O(Y.length<=32,"value too large",`tx.${Q}`,J),Y}function T8($){return g0($).map((Q)=>[Q.address,Q.storageKeys])}function AY($,Q){O(Array.isArray($),`invalid ${Q}`,"value",$);for(let J=0;J<$.length;J++)O($0($[J],32),"invalid ${ param } hash",`value[${J}]`,$[J]);return $}function LY($){let Q=i0($);O(Array.isArray(Q)&&(Q.length===9||Q.length===6),"invalid field count for legacy transaction","data",$);let J={type:0,nonce:K$(Q[0],"nonce"),gasPrice:c(Q[1],"gasPrice"),gasLimit:c(Q[2],"gasLimit"),to:L$(Q[3]),value:c(Q[4],"value"),data:E(Q[5]),chainId:i};if(Q.length===6)return J;let Y=c(Q[6],"v"),X=c(Q[7],"r"),z=c(Q[8],"s");if(X===i&&z===i)J.chainId=Y;else{let Z=(Y-PY)/jY;if(Z<i)Z=i;J.chainId=Z,O(Z!==i||(Y===SY||Y===HY),"non-canonical legacy v","v",Q[6]),J.signature=u.from({r:w0(Q[7],32),s:w0(Q[8],32),v:Y})}return J}function BY($,Q){let J=[f($.nonce,"nonce"),f($.gasPrice||0,"gasPrice"),f($.gasLimit,"gasLimit"),$.to||"0x",f($.value,"value"),$.data],Y=i;if($.chainId!=i)Y=m($.chainId,"tx.chainId"),O(!Q||Q.networkV==null||Q.legacyChainId===Y,"tx.chainId/sig.v mismatch","sig",Q);else if($.signature){let z=$.signature.legacyChainId;if(z!=null)Y=z}if(!Q){if(Y!==i)J.push(a(Y)),J.push("0x"),J.push("0x");return C0(J)}let X=BigInt(27+Q.yParity);if(Y!==i)X=u.getChainIdV(Y,Q.v);else if(BigInt(Q.v)!==X)O(!1,"tx.chainId/sig.v mismatch","sig",Q);return J.push(a(X)),J.push(a(Q.r)),J.push(a(Q.s)),C0(J)}function V8($,Q){let J;try{if(J=K$(Q[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(Z){O(!1,"invalid yParity","yParity",Q[0])}let Y=w0(Q[1],32),X=w0(Q[2],32),z=u.from({r:Y,s:X,yParity:J});$.signature=z}function kY($){let Q=i0(y($).slice(1));O(Array.isArray(Q)&&(Q.length===9||Q.length===12),"invalid field count for transaction type: 2","data",E($));let J={type:2,chainId:c(Q[0],"chainId"),nonce:K$(Q[1],"nonce"),maxPriorityFeePerGas:c(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:c(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:c(Q[4],"gasLimit"),to:L$(Q[5]),value:c(Q[6],"value"),data:E(Q[7]),accessList:D8(Q[8],"accessList")};if(Q.length===9)return J;return V8(J,Q.slice(9)),J}function FY($,Q){let J=[f($.chainId,"chainId"),f($.nonce,"nonce"),f($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),f($.maxFeePerGas||0,"maxFeePerGas"),f($.gasLimit,"gasLimit"),$.to||"0x",f($.value,"value"),$.data,T8($.accessList||[])];if(Q)J.push(f(Q.yParity,"yParity")),J.push(a(Q.r)),J.push(a(Q.s));return G0(["0x02",C0(J)])}function _Y($){let Q=i0(y($).slice(1));O(Array.isArray(Q)&&(Q.length===8||Q.length===11),"invalid field count for transaction type: 1","data",E($));let J={type:1,chainId:c(Q[0],"chainId"),nonce:K$(Q[1],"nonce"),gasPrice:c(Q[2],"gasPrice"),gasLimit:c(Q[3],"gasLimit"),to:L$(Q[4]),value:c(Q[5],"value"),data:E(Q[6]),accessList:D8(Q[7],"accessList")};if(Q.length===8)return J;return V8(J,Q.slice(8)),J}function yY($,Q){let J=[f($.chainId,"chainId"),f($.nonce,"nonce"),f($.gasPrice||0,"gasPrice"),f($.gasLimit,"gasLimit"),$.to||"0x",f($.value,"value"),$.data,T8($.accessList||[])];if(Q)J.push(f(Q.yParity,"recoveryParam")),J.push(a(Q.r)),J.push(a(Q.s));return G0(["0x01",C0(J)])}function bY($){let Q=i0(y($).slice(1)),J="3",Y=null;if(Q.length===4&&Array.isArray(Q[0])){J="3 (network format)";let z=Q[1],Z=Q[2],G=Q[3];O(Array.isArray(z),"invalid network format: blobs not an array","fields[1]",z),O(Array.isArray(Z),"invalid network format: commitments not an array","fields[2]",Z),O(Array.isArray(G),"invalid network format: proofs not an array","fields[3]",G),O(z.length===Z.length,"invalid network format: blobs/commitments length mismatch","fields",Q),O(z.length===G.length,"invalid network format: blobs/proofs length mismatch","fields",Q),Y=[];for(let M=0;M<Q[1].length;M++)Y.push({data:z[M],commitment:Z[M],proof:G[M]});Q=Q[0]}O(Array.isArray(Q)&&(Q.length===11||Q.length===14),`invalid field count for transaction type: ${J}`,"data",E($));let X={type:3,chainId:c(Q[0],"chainId"),nonce:K$(Q[1],"nonce"),maxPriorityFeePerGas:c(Q[2],"maxPriorityFeePerGas"),maxFeePerGas:c(Q[3],"maxFeePerGas"),gasPrice:null,gasLimit:c(Q[4],"gasLimit"),to:L$(Q[5]),value:c(Q[6],"value"),data:E(Q[7]),accessList:D8(Q[8],"accessList"),maxFeePerBlobGas:c(Q[9],"maxFeePerBlobGas"),blobVersionedHashes:Q[10]};if(Y)X.blobs=Y;O(X.to!=null,`invalid address for transaction type: ${J}`,"data",$),O(Array.isArray(X.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",$);for(let z=0;z<X.blobVersionedHashes.length;z++)O($0(X.blobVersionedHashes[z],32),`invalid blobVersionedHash at index ${z}: must be length 32`,"data",$);if(Q.length===11)return X;return V8(X,Q.slice(11)),X}function fY($,Q,J){let Y=[f($.chainId,"chainId"),f($.nonce,"nonce"),f($.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),f($.maxFeePerGas||0,"maxFeePerGas"),f($.gasLimit,"gasLimit"),$.to||M8,f($.value,"value"),$.data,T8($.accessList||[]),f($.maxFeePerBlobGas||0,"maxFeePerBlobGas"),AY($.blobVersionedHashes||[],"blobVersionedHashes")];if(Q){if(Y.push(f(Q.yParity,"yParity")),Y.push(a(Q.r)),Y.push(a(Q.s)),J)return G0(["0x03",C0([Y,J.map((X)=>X.data),J.map((X)=>X.commitment),J.map((X)=>X.proof)])])}return G0(["0x03",C0(Y)])}class q0{#$;#J;#Y;#Q;#M;#K;#W;#q;#I;#D;#T;#V;#G;#z;#X;#Z;get type(){return this.#$}set type($){switch($){case null:this.#$=null;break;case 0:case"legacy":this.#$=0;break;case 1:case"berlin":case"eip-2930":this.#$=1;break;case 2:case"london":case"eip-1559":this.#$=2;break;case 3:case"cancun":case"eip-4844":this.#$=3;break;default:O(!1,"unsupported transaction type","type",$)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844"}return null}get to(){let $=this.#J;if($==null&&this.type===3)return M8;return $}set to($){this.#J=$==null?null:W0($)}get nonce(){return this.#Q}set nonce($){this.#Q=Q0($,"value")}get gasLimit(){return this.#M}set gasLimit($){this.#M=m($)}get gasPrice(){let $=this.#K;if($==null&&(this.type===0||this.type===1))return i;return $}set gasPrice($){this.#K=$==null?null:m($,"gasPrice")}get maxPriorityFeePerGas(){let $=this.#W;if($==null){if(this.type===2||this.type===3)return i;return null}return $}set maxPriorityFeePerGas($){this.#W=$==null?null:m($,"maxPriorityFeePerGas")}get maxFeePerGas(){let $=this.#q;if($==null){if(this.type===2||this.type===3)return i;return null}return $}set maxFeePerGas($){this.#q=$==null?null:m($,"maxFeePerGas")}get data(){return this.#Y}set data($){this.#Y=E($)}get value(){return this.#I}set value($){this.#I=m($,"value")}get chainId(){return this.#D}set chainId($){this.#D=m($)}get signature(){return this.#T||null}set signature($){this.#T=$==null?null:u.from($)}get accessList(){let $=this.#V||null;if($==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return $}set accessList($){this.#V=$==null?null:g0($)}get maxFeePerBlobGas(){let $=this.#G;if($==null&&this.type===3)return i;return $}set maxFeePerBlobGas($){this.#G=$==null?null:m($,"maxFeePerBlobGas")}get blobVersionedHashes(){let $=this.#z;if($==null&&this.type===3)return[];return $}set blobVersionedHashes($){if($!=null){O(Array.isArray($),"blobVersionedHashes must be an Array","value",$),$=$.slice();for(let Q=0;Q<$.length;Q++)O($0($[Q],32),"invalid blobVersionedHash",`value[${Q}]`,$[Q])}this.#z=$}get blobs(){if(this.#Z==null)return null;return this.#Z.map(($)=>Object.assign({},$))}set blobs($){if($==null){this.#Z=null;return}let Q=[],J=[];for(let Y=0;Y<$.length;Y++){let X=$[Y];if(Q$(X)){L(this.#X,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let z=y(X);if(O(z.length<=I8,"blob is too large",`blobs[${Y}]`,X),z.length!==I8){let M=new Uint8Array(I8);M.set(z),z=M}let Z=this.#X.blobToKzgCommitment(z),G=E(this.#X.computeBlobKzgProof(z,Z));Q.push({data:E(z),commitment:E(Z),proof:G}),J.push(fQ(1,Z))}else{let z=E(X.commitment);Q.push({data:E(X.data),commitment:z,proof:E(X.proof)}),J.push(fQ(1,z))}}this.#Z=Q,this.#z=J}get kzg(){return this.#X}set kzg($){this.#X=$}constructor(){this.#$=null,this.#J=null,this.#Q=0,this.#M=i,this.#K=null,this.#W=null,this.#q=null,this.#Y="0x",this.#I=i,this.#D=i,this.#T=null,this.#V=null,this.#G=null,this.#z=null,this.#Z=null,this.#X=null}get hash(){if(this.signature==null)return null;return J0(this.#O(!0,!1))}get unsignedHash(){return J0(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return bQ(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return X0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#O($,Q){L(!$||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});let J=$?this.signature:null;switch(this.inferType()){case 0:return BY(this,J);case 1:return yY(this,J);case 2:return FY(this,J);case 3:return fY(this,J,Q?this.blobs:null)}L(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#O(!0,!0)}get unsignedSerialized(){return this.#O(!1,!1)}inferType(){let $=this.inferTypes();if($.indexOf(2)>=0)return 2;return $.pop()}inferTypes(){let $=this.gasPrice!=null,Q=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,Y=this.#G!=null||this.#z;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)L(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});L(!Q||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),L(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});let X=[];if(this.type!=null)X.push(this.type);else if(Q)X.push(2);else if($){if(X.push(1),!J)X.push(0)}else if(J)X.push(1),X.push(2);else if(Y&&this.to)X.push(3);else X.push(0),X.push(1),X.push(2),X.push(3);return X.sort(),X}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return q0.from(this)}toJSON(){let $=(Q)=>{if(Q==null)return null;return Q.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:$(this.gasLimit),gasPrice:$(this.gasPrice),maxPriorityFeePerGas:$(this.maxPriorityFeePerGas),maxFeePerGas:$(this.maxFeePerGas),value:$(this.value),chainId:$(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from($){if($==null)return new q0;if(typeof $==="string"){let J=y($);if(J[0]>=127)return q0.from(LY(J));switch(J[0]){case 1:return q0.from(_Y(J));case 2:return q0.from(kY(J));case 3:return q0.from(bY(J))}L(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}let Q=new q0;if($.type!=null)Q.type=$.type;if($.to!=null)Q.to=$.to;if($.nonce!=null)Q.nonce=$.nonce;if($.gasLimit!=null)Q.gasLimit=$.gasLimit;if($.gasPrice!=null)Q.gasPrice=$.gasPrice;if($.maxPriorityFeePerGas!=null)Q.maxPriorityFeePerGas=$.maxPriorityFeePerGas;if($.maxFeePerGas!=null)Q.maxFeePerGas=$.maxFeePerGas;if($.maxFeePerBlobGas!=null)Q.maxFeePerBlobGas=$.maxFeePerBlobGas;if($.data!=null)Q.data=$.data;if($.value!=null)Q.value=$.value;if($.chainId!=null)Q.chainId=$.chainId;if($.signature!=null)Q.signature=u.from($.signature);if($.accessList!=null)Q.accessList=$.accessList;if($.blobVersionedHashes!=null)Q.blobVersionedHashes=$.blobVersionedHashes;if($.kzg!=null)Q.kzg=$.kzg;if($.blobs!=null)Q.blobs=$.blobs;if($.hash!=null)O(Q.isSigned(),"unsigned transaction cannot define '.hash'","tx",$),O(Q.hash===$.hash,"hash mismatch","tx",$);if($.from!=null)O(Q.isSigned(),"unsigned transaction cannot define '.from'","tx",$),O(Q.from.toLowerCase()===($.from||"").toLowerCase(),"from mismatch","tx",$);return Q}}var xQ=BigInt(0);function O8($){if($==null)return null;return $}function n($){if($==null)return null;return $.toString()}function U8($){let Q={};if($.to)Q.to=$.to;if($.from)Q.from=$.from;if($.data)Q.data=E($.data);let J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let X of J){if(!(X in $)||$[X]==null)continue;Q[X]=m($[X],`request.${X}`)}let Y="type,nonce".split(/,/);for(let X of Y){if(!(X in $)||$[X]==null)continue;Q[X]=Q0($[X],`request.${X}`)}if($.accessList)Q.accessList=g0($.accessList);if("blockTag"in $)Q.blockTag=$.blockTag;if("enableCcipRead"in $)Q.enableCcipRead=!!$.enableCcipRead;if("customData"in $)Q.customData=$.customData;if("blobVersionedHashes"in $&&$.blobVersionedHashes)Q.blobVersionedHashes=$.blobVersionedHashes.slice();if("kzg"in $)Q.kzg=$.kzg;if("blobs"in $&&$.blobs)Q.blobs=$.blobs.map((X)=>{if(Q$(X))return E(X);return Object.assign({},X)});return Q}class mQ{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#$;constructor($,Q){this.#$=$.transactions.map((J)=>{if(typeof J!=="string")return new B$(J,Q);return J}),Z0(this,{provider:Q,hash:O8($.hash),number:$.number,timestamp:$.timestamp,parentHash:$.parentHash,parentBeaconBlockRoot:$.parentBeaconBlockRoot,nonce:$.nonce,difficulty:$.difficulty,gasLimit:$.gasLimit,gasUsed:$.gasUsed,blobGasUsed:$.blobGasUsed,excessBlobGas:$.excessBlobGas,miner:$.miner,prevRandao:O8($.prevRandao),extraData:$.extraData,baseFeePerGas:O8($.baseFeePerGas),stateRoot:$.stateRoot,receiptsRoot:$.receiptsRoot})}get transactions(){return this.#$.map(($)=>{if(typeof $==="string")return $;return $.hash})}get prefetchedTransactions(){let $=this.#$.slice();if($.length===0)return[];return L(typeof $[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),$}toJSON(){let{baseFeePerGas:$,difficulty:Q,extraData:J,gasLimit:Y,gasUsed:X,hash:z,miner:Z,prevRandao:G,nonce:M,number:W,parentHash:K,parentBeaconBlockRoot:I,stateRoot:w,receiptsRoot:C,timestamp:q,transactions:D}=this;return{_type:"Block",baseFeePerGas:n($),difficulty:n(Q),extraData:J,gasLimit:n(Y),gasUsed:n(X),blobGasUsed:n(this.blobGasUsed),excessBlobGas:n(this.excessBlobGas),hash:z,miner:Z,prevRandao:G,nonce:M,number:W,parentHash:K,timestamp:q,parentBeaconBlockRoot:I,stateRoot:w,receiptsRoot:C,transactions:D}}[Symbol.iterator](){let $=0,Q=this.transactions;return{next:()=>{if($<this.length)return{value:Q[$++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#$.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction($){let Q=void 0;if(typeof $==="number")Q=this.#$[$];else{let J=$.toLowerCase();for(let Y of this.#$)if(typeof Y==="string"){if(Y!==J)continue;Q=Y;break}else{if(Y.hash!==J)continue;Q=Y;break}}if(Q==null)throw new Error("no such tx");if(typeof Q==="string")return await this.provider.getTransaction(Q);else return Q}getPrefetchedTransaction($){let Q=this.prefetchedTransactions;if(typeof $==="number")return Q[$];$=$.toLowerCase();for(let J of Q)if(J.hash===$)return J;O(!1,"no matching transaction","indexOrHash",$)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return xY(this)}}class N8{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor($,Q){this.provider=Q;let J=Object.freeze($.topics.slice());Z0(this,{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,removed:$.removed,address:$.address,data:$.data,topics:J,index:$.index,transactionIndex:$.transactionIndex})}toJSON(){let{address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:M}=this;return{_type:"log",address:$,blockHash:Q,blockNumber:J,data:Y,index:X,removed:z,topics:Z,transactionHash:G,transactionIndex:M}}async getBlock(){let $=await this.provider.getBlock(this.blockHash);return L(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransaction(){let $=await this.provider.getTransaction(this.transactionHash);return L(!!$,"failed to find transaction","UNKNOWN_ERROR",{}),$}async getTransactionReceipt(){let $=await this.provider.getTransactionReceipt(this.transactionHash);return L(!!$,"failed to find transaction receipt","UNKNOWN_ERROR",{}),$}removedEvent(){return mY(this)}}class vQ{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#$;constructor($,Q){this.#$=Object.freeze($.logs.map((Y)=>{return new N8(Y,Q)}));let J=xQ;if($.effectiveGasPrice!=null)J=$.effectiveGasPrice;else if($.gasPrice!=null)J=$.gasPrice;Z0(this,{provider:Q,to:$.to,from:$.from,contractAddress:$.contractAddress,hash:$.hash,index:$.index,blockHash:$.blockHash,blockNumber:$.blockNumber,logsBloom:$.logsBloom,gasUsed:$.gasUsed,cumulativeGasUsed:$.cumulativeGasUsed,blobGasUsed:$.blobGasUsed,gasPrice:J,blobGasPrice:$.blobGasPrice,type:$.type,status:$.status,root:$.root})}get logs(){return this.#$}toJSON(){let{to:$,from:Q,contractAddress:J,hash:Y,index:X,blockHash:z,blockNumber:Z,logsBloom:G,logs:M,status:W,root:K}=this;return{_type:"TransactionReceipt",blockHash:z,blockNumber:Z,contractAddress:J,cumulativeGasUsed:n(this.cumulativeGasUsed),from:Q,gasPrice:n(this.gasPrice),blobGasUsed:n(this.blobGasUsed),blobGasPrice:n(this.blobGasPrice),gasUsed:n(this.gasUsed),hash:Y,index:X,logs:M,logsBloom:G,root:K,status:W,to:$}}get length(){return this.logs.length}[Symbol.iterator](){let $=0;return{next:()=>{if($<this.length)return{value:this.logs[$++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){let $=await this.provider.getBlock(this.blockHash);if($==null)throw new Error("TODO");return $}async getTransaction(){let $=await this.provider.getTransaction(this.hash);if($==null)throw new Error("TODO");return $}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return cQ(this)}reorderedEvent($){return L(!$||$.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),gQ(this,$)}}class B${provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;#$;constructor($,Q){this.provider=Q,this.blockNumber=$.blockNumber!=null?$.blockNumber:null,this.blockHash=$.blockHash!=null?$.blockHash:null,this.hash=$.hash,this.index=$.index,this.type=$.type,this.from=$.from,this.to=$.to||null,this.gasLimit=$.gasLimit,this.nonce=$.nonce,this.data=$.data,this.value=$.value,this.gasPrice=$.gasPrice,this.maxPriorityFeePerGas=$.maxPriorityFeePerGas!=null?$.maxPriorityFeePerGas:null,this.maxFeePerGas=$.maxFeePerGas!=null?$.maxFeePerGas:null,this.maxFeePerBlobGas=$.maxFeePerBlobGas!=null?$.maxFeePerBlobGas:null,this.chainId=$.chainId,this.signature=$.signature,this.accessList=$.accessList!=null?$.accessList:null,this.blobVersionedHashes=$.blobVersionedHashes!=null?$.blobVersionedHashes:null,this.#$=-1}toJSON(){let{blockNumber:$,blockHash:Q,index:J,hash:Y,type:X,to:z,from:Z,nonce:G,data:M,signature:W,accessList:K,blobVersionedHashes:I}=this;return{_type:"TransactionResponse",accessList:K,blockNumber:$,blockHash:Q,blobVersionedHashes:I,chainId:n(this.chainId),data:M,from:Z,gasLimit:n(this.gasLimit),gasPrice:n(this.gasPrice),hash:Y,maxFeePerGas:n(this.maxFeePerGas),maxPriorityFeePerGas:n(this.maxPriorityFeePerGas),maxFeePerBlobGas:n(this.maxFeePerBlobGas),nonce:G,signature:W,to:z,index:J,type:X,value:n(this.value)}}async getBlock(){let $=this.blockNumber;if($==null){let J=await this.getTransaction();if(J)$=J.blockNumber}if($==null)return null;let Q=this.provider.getBlock($);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){let{tx:Q,blockNumber:J}=await y0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Q==null||Q.blockNumber==null)return 0;return J-Q.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait($,Q){let J=$==null?1:$,Y=Q==null?0:Q,X=this.#$,z=-1,Z=X===-1?!0:!1,G=async()=>{if(Z)return null;let{blockNumber:I,nonce:w}=await y0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(w<this.nonce){X=I;return}if(Z)return null;let C=await this.getTransaction();if(C&&C.blockNumber!=null)return;if(z===-1){if(z=X-3,z<this.#$)z=this.#$}while(z<=I){if(Z)return null;let q=await this.provider.getBlock(z,!0);if(q==null)return;for(let D of q)if(D===this.hash)return;for(let D=0;D<q.length;D++){let T=await q.getTransaction(D);if(T.from===this.from&&T.nonce===this.nonce){if(Z)return null;let U=await this.provider.getTransactionReceipt(T.hash);if(U==null)return;if(I-U.blockNumber+1<J)return;let N="replaced";if(T.data===this.data&&T.to===this.to&&T.value===this.value)N="repriced";else if(T.data==="0x"&&T.from===T.to&&T.value===xQ)N="cancelled";L(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:N==="replaced"||N==="cancelled",reason:N,replacement:T.replaceableTransaction(X),hash:T.hash,receipt:U})}}z++}return},M=(I)=>{if(I==null||I.status!==0)return I;L(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:I.to,from:I.from,data:""},receipt:I})},W=await this.provider.getTransactionReceipt(this.hash);if(J===0)return M(W);if(W){if(await W.confirmations()>=J)return M(W)}else if(await G(),J===0)return null;return await new Promise((I,w)=>{let C=[],q=()=>{C.forEach((T)=>T())};if(C.push(()=>{Z=!0}),Y>0){let T=setTimeout(()=>{q(),w(I$("wait for transaction timeout","TIMEOUT"))},Y);C.push(()=>{clearTimeout(T)})}let D=async(T)=>{if(await T.confirmations()>=J){q();try{I(M(T))}catch(U){w(U)}}};if(C.push(()=>{this.provider.off(this.hash,D)}),this.provider.on(this.hash,D),X>=0){let T=async()=>{try{await G()}catch(U){if(y$(U,"TRANSACTION_REPLACED")){q(),w(U);return}}if(!Z)this.provider.once("block",T)};C.push(()=>{this.provider.off("block",T)}),this.provider.once("block",T)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return L(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),cQ(this)}reorderedEvent($){return L(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),L(!$||$.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),gQ(this,$)}replaceableTransaction($){O(Number.isInteger($)&&$>=0,"invalid startBlock","startBlock",$);let Q=new B$(this,this.provider);return Q.#$=$,Q}}function xY($){return{orphan:"drop-block",hash:$.hash,number:$.number}}function gQ($,Q){return{orphan:"reorder-transaction",tx:$,other:Q}}function cQ($){return{orphan:"drop-transaction",tx:$}}function mY($){return{orphan:"drop-log",log:{transactionHash:$.transactionHash,blockHash:$.blockHash,blockNumber:$.blockNumber,address:$.address,data:$.data,topics:Object.freeze($.topics.slice()),index:$.index}}}function t0($,Q){if($.provider)return $.provider;L(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Q})}async function hQ($,Q){let J=U8(Q);if(J.to!=null)J.to=A$(J.to,$);if(J.from!=null){let Y=J.from;J.from=Promise.all([$.getAddress(),A$(Y,$)]).then(([X,z])=>{return O(X.toLowerCase()===z.toLowerCase(),"transaction from mismatch","tx.from",z),X})}else J.from=$.getAddress();return await y0(J)}class e0{provider;constructor($){Z0(this,{provider:$||null})}async getNonce($){return t0(this,"getTransactionCount").getTransactionCount(await this.getAddress(),$)}async populateCall($){return await hQ(this,$)}async populateTransaction($){let Q=t0(this,"populateTransaction"),J=await hQ(this,$);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);let Y=await this.provider.getNetwork();if(J.chainId!=null){let z=m(J.chainId);O(z===Y.chainId,"transaction chainId mismatch","tx.chainId",$.chainId)}else J.chainId=Y.chainId;let X=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||X))O(!1,"eip-1559 transaction do not support gasPrice","tx",$);else if((J.type===0||J.type===1)&&X)O(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",$);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){let z=await Q.getFeeData();if(L(z.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=z.gasPrice}else{let z=await Q.getFeeData();if(J.type==null)if(z.maxFeePerGas!=null&&z.maxPriorityFeePerGas!=null)if(J.type=2,J.gasPrice!=null){let Z=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=Z,J.maxPriorityFeePerGas=Z}else{if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}else if(z.gasPrice!=null){if(L(!X,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=z.gasPrice;J.type=0}else L(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3){if(J.maxFeePerGas==null)J.maxFeePerGas=z.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=z.maxPriorityFeePerGas}}return await y0(J)}async estimateGas($){return t0(this,"estimateGas").estimateGas(await this.populateCall($))}async call($){return t0(this,"call").call(await this.populateCall($))}async resolveName($){return await t0(this,"resolveName").resolveName($)}async sendTransaction($){let Q=t0(this,"sendTransaction"),J=await this.populateTransaction($);delete J.from;let Y=q0.from(J);return await Q.broadcastTransaction(await this.signTransaction(Y))}}class k$ extends e0{address;constructor($,Q){super(Q);Z0(this,{address:$})}async getAddress(){return this.address}connect($){return new k$(this.address,$)}#$($,Q){L(!1,`VoidSigner cannot sign ${$}`,"UNSUPPORTED_OPERATION",{operation:Q})}async signTransaction($){this.#$("transactions","signTransaction")}async signMessage($){this.#$("messages","signMessage")}async signTypedData($,Q,J){this.#$("typed-data","signTypedData")}}class w8 extends e0{#$;constructor($,Q){super(Q);this.#$=$}async getAddress(){let $=await this.#$.request({method:"eth_requestAccounts"});if(!$[0])throw new Error("No Account found");return $[0]}async signTransaction(){return await this.#$.request({method:"eth_signTransaction"})}async signMessage($){return await this.#$.request({method:"personal_sign",params:[$,await this.getAddress()]})}signTypedData=()=>{throw new Error("this method is not implemented")};connect($){return new w8(this.#$,$)}}var dQ=async({chain:$,ethplorerApiKey:Q,covalentApiKey:J,apis:Y,coinbaseWalletSettings:X={appName:"Developer App"}})=>{switch($){case $$.Ethereum:case $$.Avalanche:case $$.Arbitrum:case $$.Optimism:case $$.Polygon:case $$.BinanceSmartChain:{let z=new vY(X),Z=Y?.[$],G=Z?void 0:cY({chain:$,nonEthApiKey:J,ethApiKey:Q}),M=z.makeWeb3Provider(gY[$]);if(!M)throw new Error("No wallet provider");let{getToolboxByChain:W,getProvider:K}=await import("@swapkit/toolbox-evm"),I=K($),w=new w8(M,I),C={api:Z,provider:I,signer:w},q=W($)({...C,api:Z,apiKey:G});return{address:await w.getAddress(),...q}}default:throw new Error(`No wallet for chain ${$}`)}};var uY=[c0.Arbitrum,c0.Avalanche,c0.Base,c0.BinanceSmartChain,c0.Ethereum,c0.Optimism,c0.Polygon];function pY({addChain:$,apis:Q,config:{thorswapApiKey:J,covalentApiKey:Y,ethplorerApiKey:X},coinbaseWalletSettings:z}){return async function Z(G){dY({apiKey:J});let W=hY(G,uY,uQ.COINBASE_MOBILE).map(async(K)=>{let I=await dQ({apis:Q,chain:K,covalentApiKey:Y,ethplorerApiKey:X,coinbaseWalletSettings:z});$({...I,balance:[],chain:K,walletType:uQ.COINBASE_MOBILE})});return await Promise.all(W),!0}}var AZ={connectCoinbaseWallet:pY};export{AZ as coinbaseWallet,uY as COINBASE_SUPPORTED_CHAINS};

//# debugId=3573045C8FAD72E564756E2164756E21
