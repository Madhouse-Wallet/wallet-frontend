{
  "version": 3,
  "sources": ["../src/index.ts", "../src/signer.ts", "../../../../node_modules/ethers/lib.esm/_version.js", "../../../../node_modules/ethers/lib.esm/utils/properties.js", "../../../../node_modules/ethers/lib.esm/utils/errors.js", "../../../../node_modules/ethers/lib.esm/utils/data.js", "../../../../node_modules/ethers/lib.esm/utils/maths.js", "../../../../node_modules/ethers/lib.esm/utils/rlp-decode.js", "../../../../node_modules/ethers/lib.esm/utils/rlp-encode.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/utils.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha512.js", "../../../../node_modules/ethers/lib.esm/crypto/crypto-browser.js", "../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js", "../../../../node_modules/ethers/lib.esm/crypto/keccak.js", "../../../../node_modules/ethers/lib.esm/crypto/sha2.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js", "../../../../node_modules/@noble/curves/esm/abstract/utils.js", "../../../../node_modules/@noble/curves/esm/abstract/modular.js", "../../../../node_modules/@noble/curves/esm/abstract/curve.js", "../../../../node_modules/@noble/curves/esm/abstract/weierstrass.js", "../../../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js", "../../../../node_modules/@noble/curves/esm/_shortw_utils.js", "../../../../node_modules/@noble/curves/esm/secp256k1.js", "../../../../node_modules/ethers/lib.esm/constants/addresses.js", "../../../../node_modules/ethers/lib.esm/constants/hashes.js", "../../../../node_modules/ethers/lib.esm/crypto/signature.js", "../../../../node_modules/ethers/lib.esm/crypto/signing-key.js", "../../../../node_modules/ethers/lib.esm/address/address.js", "../../../../node_modules/ethers/lib.esm/address/checks.js", "../../../../node_modules/ethers/lib.esm/transaction/accesslist.js", "../../../../node_modules/ethers/lib.esm/transaction/address.js", "../../../../node_modules/ethers/lib.esm/transaction/transaction.js", "../../../../node_modules/ethers/lib.esm/providers/provider.js", "../../../../node_modules/ethers/lib.esm/providers/abstract-signer.js"],
  "sourcesContent": [
    "import type { CoinbaseWalletSDKOptions } from \"@coinbase/wallet-sdk/dist/CoinbaseWalletSDK\";\nimport { filterSupportedChains, setRequestClientConfig } from \"@swapkit/helpers\";\nimport { Chain, type ConnectWalletParams, WalletOption } from \"@swapkit/helpers\";\n\nimport { getWalletForChain } from \"./signer.js\";\n\nexport const COINBASE_SUPPORTED_CHAINS = [\n  Chain.Arbitrum,\n  Chain.Avalanche,\n  Chain.Base,\n  Chain.BinanceSmartChain,\n  Chain.Ethereum,\n  Chain.Optimism,\n  Chain.Polygon,\n] as const;\n\nfunction connectCoinbaseWallet({\n  addChain,\n  apis,\n  config: { thorswapApiKey, covalentApiKey, ethplorerApiKey },\n  coinbaseWalletSettings,\n}: ConnectWalletParams & { coinbaseWalletSettings?: CoinbaseWalletSDKOptions }) {\n  return async function connectCoinbaseWallet(chains: Chain[]) {\n    setRequestClientConfig({ apiKey: thorswapApiKey });\n\n    const supportedChains = filterSupportedChains(\n      chains,\n      COINBASE_SUPPORTED_CHAINS,\n      WalletOption.COINBASE_MOBILE,\n    );\n\n    const promises = supportedChains.map(async (chain) => {\n      const walletMethods = await getWalletForChain({\n        apis,\n        chain,\n        covalentApiKey,\n        ethplorerApiKey,\n        coinbaseWalletSettings,\n      });\n\n      addChain({ ...walletMethods, balance: [], chain, walletType: WalletOption.COINBASE_MOBILE });\n    });\n\n    await Promise.all(promises);\n\n    return true;\n  };\n}\n\nexport const coinbaseWallet = { connectCoinbaseWallet } as const;\n",
    "import { type CoinbaseWalletProvider, CoinbaseWalletSDK } from \"@coinbase/wallet-sdk\";\nimport type { CoinbaseWalletSDKOptions } from \"@coinbase/wallet-sdk/dist/CoinbaseWalletSDK\";\nimport { Chain, type ChainApis, ChainToRPC, pickEvmApiKey } from \"@swapkit/helpers\";\nimport type { getToolboxByChain } from \"@swapkit/toolbox-evm\";\nimport { AbstractSigner, type Provider } from \"ethers\";\n\nclass CoinbaseMobileSigner extends AbstractSigner {\n  #coinbaseProvider: CoinbaseWalletProvider;\n\n  constructor(coinbaseProvider: CoinbaseWalletProvider, provider?: Provider) {\n    super(provider);\n    this.#coinbaseProvider = coinbaseProvider;\n  }\n\n  async getAddress() {\n    const accounts = await this.#coinbaseProvider.request<string[]>({\n      method: \"eth_requestAccounts\",\n    });\n\n    if (!accounts[0]) throw new Error(\"No Account found\");\n\n    return accounts[0];\n  }\n\n  async signTransaction() {\n    return await this.#coinbaseProvider.request<string>({\n      method: \"eth_signTransaction\",\n    });\n  }\n\n  async signMessage(message: string | Uint8Array) {\n    return await this.#coinbaseProvider.request<string>({\n      method: \"personal_sign\",\n      params: [message, await this.getAddress()],\n    });\n  }\n\n  signTypedData = () => {\n    throw new Error(\"this method is not implemented\");\n  };\n\n  connect(provider: Provider) {\n    return new CoinbaseMobileSigner(this.#coinbaseProvider, provider);\n  }\n}\n\nexport const getWalletForChain = async ({\n  chain,\n  ethplorerApiKey,\n  covalentApiKey,\n  apis,\n  coinbaseWalletSettings = {\n    appName: \"Developer App\",\n  } as CoinbaseWalletSDKOptions,\n}: {\n  chain: Chain;\n  ethplorerApiKey?: string;\n  covalentApiKey?: string;\n  apis?: ChainApis;\n  coinbaseWalletSettings?: CoinbaseWalletSDKOptions;\n}): Promise<ReturnType<ReturnType<typeof getToolboxByChain>> & { address: string }> => {\n  switch (chain) {\n    case Chain.Ethereum:\n    case Chain.Avalanche:\n    case Chain.Arbitrum:\n    case Chain.Optimism:\n    case Chain.Polygon:\n    case Chain.BinanceSmartChain: {\n      const coinbaseWallet = new CoinbaseWalletSDK(coinbaseWalletSettings);\n\n      const api = apis?.[chain];\n\n      const apiKey = api\n        ? undefined\n        : pickEvmApiKey({\n            chain,\n            nonEthApiKey: covalentApiKey,\n            ethApiKey: ethplorerApiKey,\n          });\n\n      const walletProvider = coinbaseWallet.makeWeb3Provider(ChainToRPC[chain]);\n\n      // TODO fix error\n      if (!walletProvider) throw new Error(\"No wallet provider\");\n\n      const { getToolboxByChain, getProvider } = await import(\"@swapkit/toolbox-evm\");\n\n      const provider = getProvider(chain);\n\n      const signer = new CoinbaseMobileSigner(walletProvider, provider);\n\n      const params = {\n        api,\n        provider,\n        signer,\n      };\n\n      const toolbox = getToolboxByChain(chain)({\n        ...params,\n        api,\n        apiKey,\n      });\n\n      return {\n        address: await signer.getAddress(),\n        ...toolbox,\n      };\n    }\n\n    default:\n      throw new Error(`No wallet for chain ${chain}`);\n  }\n};\n",
    "/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nexport const version = \"6.13.5\";\n//# sourceMappingURL=_version.js.map",
    "/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map",
    "/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nimport { version } from \"../_version.js\";\nimport { defineProperties } from \"./properties.js\";\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    defineProperties(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        defineProperties(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexport function assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map",
    "/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map",
    "/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value, name) {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                assertArgument(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value) {\n    let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map",
    "//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map",
    "//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { getBytes } from \"./data.js\";\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call(getBytes(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */\nexport function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\n//# sourceMappingURL=rlp-encode.js.map",
    "function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map",
    "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map",
    "import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map",
    "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map",
    "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map",
    "import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map",
    "/* Browser Crypto Shims */\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport function createHash(algo) {\n    switch (algo) {\n        case \"sha256\": return sha256.create();\n        case \"sha512\": return sha512.create();\n    }\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexport function createHmac(_algo, key) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return hmac.create(algo, key);\n}\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });\n}\nexport function randomBytes(length) {\n    assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n//# sourceMappingURL=crypto-browser.js.map",
    "import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map",
    "/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\nimport { keccak_256 } from \"@noble/hashes/sha3\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\nconst _keccak256 = function (data) {\n    return keccak_256(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map",
    "import { createHash } from \"./crypto.js\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nconst _sha256 = function (data) {\n    return createHash(\"sha256\").update(data).digest();\n};\nconst _sha512 = function (data) {\n    return createHash(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nexport function sha256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function () { locked256 = true; };\nsha256.register = function (func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */\nexport function sha512(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function () { locked512 = true; };\nsha512.register = function (func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256);\n//# sourceMappingURL=sha2.js.map",
    "function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map",
    "export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map",
    "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map",
    "import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map",
    "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexport function equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map",
    "import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map",
    "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map",
    "/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nexport const ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map",
    "/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */\nexport const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map",
    "import { ZeroHash } from \"../constants/index.js\";\nimport { concat, dataLength, getBigInt, getBytes, getNumber, hexlify, toBeArray, isHexString, zeroPadValue, assertArgument, assertPrivate } from \"../utils/index.js\";\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return zeroPadValue(toBeArray(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r() { return this.#r; }\n    set r(value) {\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = hexlify(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s() { return this.#s; }\n    set s(_value) {\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = hexlify(_value);\n        assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v() { return this.#v; }\n    set v(value) {\n        const v = getNumber(value, \"value\");\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV() { return this.#networkV; }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity() {\n        return (this.v === 27) ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = getBytes(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return hexlify(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized() {\n        return concat([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n    get serialized() {\n        return concat([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\n    }\n    /**\n     *  @private\n     */\n    constructor(guard, r, s, v) {\n        assertPrivate(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString() : null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v) {\n        const bv = getBigInt(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId, v) {\n        return (getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v) {\n        const bv = getBigInt(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig) {\n        function assertError(check, message) {\n            assertArgument(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, ZeroHash, ZeroHash, 27);\n        }\n        if (typeof (sig) === \"string\") {\n            const bytes = getBytes(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function (s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = getBytes(yParityAndS);\n                bytes[0] &= 0x7f;\n                return hexlify(bytes);\n            }\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = getBigInt(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v : undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28 : 27) };\n            }\n            if (yParity != null) {\n                switch (getNumber(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\n//# sourceMappingURL=signature.js.map",
    "/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { concat, dataLength, getBytes, getBytesCopy, hexlify, toBeHex, assertArgument } from \"../utils/index.js\";\nimport { Signature } from \"./signature.js\";\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\nexport class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = hexlify(privateKey);\n    }\n    /**\n     *  The private key.\n     */\n    get privateKey() { return this.#privateKey; }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */\n    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */\n    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */\n    sign(digest) {\n        assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {\n            lowS: true\n        });\n        return Signature.from({\n            r: toBeHex(sig.r, 32),\n            s: toBeHex(sig.s, 32),\n            v: (sig.recovery ? 0x1c : 0x1b)\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */\n    computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */\n    static computePublicKey(key, compressed) {\n        let bytes = getBytes(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = secp256k1.getPublicKey(bytes, !!compressed);\n            return hexlify(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = secp256k1.ProjectivePoint.fromHex(bytes);\n        return hexlify(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */\n    static recoverPublicKey(digest, signature) {\n        assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = Signature.from(signature);\n        let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));\n        assertArgument(pubKey != null, \"invalid signautre for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */\n    static addPoints(p0, p1, compressed) {\n        const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n}\n//# sourceMappingURL=signing-key.js.map",
    "import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map",
    "import { assert, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nexport function isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nexport function isAddress(value) {\n    try {\n        getAddress(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        assert(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return getAddress(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nexport function resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return getAddress(target);\n        }\n        assert(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}\n//# sourceMappingURL=checks.js.map",
    "import { getAddress } from \"../address/index.js\";\nimport { assertArgument, isHexString } from \"../utils/index.js\";\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            assertArgument(isHexString(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nexport function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            assertArgument(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    assertArgument(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n//# sourceMappingURL=accesslist.js.map",
    "import { getAddress } from \"../address/index.js\";\nimport { keccak256, SigningKey } from \"../crypto/index.js\";\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nexport function computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nexport function recoverAddress(digest, signature) {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}\n//# sourceMappingURL=address.js.map",
    "import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) {\n        versioned = \"0\" + versioned;\n    }\n    versioned += sha256(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return accessListify(value);\n    }\n    catch (error) {\n        assertArgument(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatHashes(value, param) {\n    assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = decodeRlp(data);\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: hexlify(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n        //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return encodeRlp(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n    let fields = decodeRlp(getBytes(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n        fields = fields[0];\n    }\n    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", hexlify(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return concat([\n                \"0x03\",\n                encodeRlp([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n        }\n    }\n    return concat([\"0x03\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : getAddress(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = getNumber(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = getBigInt(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : getBigInt(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : getBigInt(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = hexlify(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = getBigInt(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = getBigInt(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : accessListify(value);\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : getBigInt(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b) => Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n            if (isBytesLike(blob)) {\n                assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = getBytes(blob);\n                assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: hexlify(data),\n                    commitment: hexlify(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n            else {\n                const commit = hexlify(blob.commitment);\n                blobs.push({\n                    data: hexlify(blob.data),\n                    commitment: commit,\n                    proof: hexlify(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() { return this.#kzg; }\n    set kzg(kzg) {\n        this.#kzg = kzg;\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#blobs = null;\n        this.#kzg = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return keccak256(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        const sig = signed ? this.signature : null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = getBytes(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map",
    "//import { resolveAddress } from \"@ethersproject/address\";\nimport { defineProperties, getBigInt, getNumber, hexlify, isBytesLike, resolveProperties, assert, assertArgument, isError, makeError } from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        defineProperties(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nexport function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = hexlify(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getBigInt(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getNumber(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = accessListify(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b) => {\n            if (isBytesLike(b)) {\n                return hexlify(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The hash tree root of the parent beacon block for the given\n     *  execution block. See [[link-eip-4788]].\n     */\n    parentBeaconBlockRoot;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The root hash for the global state after applying changes\n     *  in this block.\n     */\n    stateRoot;\n    /**\n     *  The hash of the transaction receipts trie.\n     */\n    receiptsRoot;\n    /**\n     *  The total amount of blob gas consumed by the transactions\n     *  within the block. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The running total of blob gas consumed in excess of the\n     *  target, prior to the block. See [[link-eip-4844]].\n     */\n    excessBlobGas;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  The latest RANDAO mix of the post beacon state of\n     *  the previous block.\n     */\n    prevRandao;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        defineProperties(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot,\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        assert(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash, miner, prevRandao, nonce, number, parentHash, timestamp,\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nexport class Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        defineProperties(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nexport class TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was sent to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The gas used for BLObs. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\n     */\n    blobGasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        defineProperties(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nexport class TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The [[link-eip-4844]] max fee per BLOb gas.\n     */\n    maxFeePerBlobGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    /**\n     *  The [[link-eip-4844]] BLOb versioned hashes.\n     */\n    blobVersionedHashes;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList, blockNumber, blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await resolveProperties({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await resolveProperties({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map",
    "/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\nimport { copyRequest } from \"./provider.js\";\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\nasync function populate(signer, tx) {\n    let pop = copyRequest(tx);\n    if (pop.to != null) {\n        pop.to = resolveAddress(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            resolveAddress(from, signer)\n        ]).then(([address, from]) => {\n            assertArgument(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    }\n    else {\n        pop.from = signer.getAddress();\n    }\n    return await resolveProperties(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nexport class AbstractSigner {\n    /**\n     *  The provider this signer is connected to.\n     */\n    provider;\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider) {\n        defineProperties(this, { provider: (provider || null) });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await (this.provider).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = getBigInt(pop.chainId);\n            assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        }\n        else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        }\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        }\n        else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        }\n        else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    }\n                    else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                }\n                else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                }\n                else {\n                    // getFeeData has failed us.\n                    assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            }\n            else if (pop.type === 2 || pop.type === 3) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await resolveProperties(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nexport class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    address;\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address, provider) {\n        super(provider);\n        defineProperties(this, { address });\n    }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        assert(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\n//# sourceMappingURL=abstract-signer.js.map"
  ],
  "mappings": "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",
  "debugId": "3573045C8FAD72E564756E2164756E21",
  "names": []
}